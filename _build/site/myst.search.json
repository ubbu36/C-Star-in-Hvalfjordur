{"version":"1","records":[{"hierarchy":{"lvl1":"BGC analysis"},"type":"lvl1","url":"/bgc-analysis-200m","position":0},{"hierarchy":{"lvl1":"BGC analysis"},"content":"This notebook conducts a comparison between observed and modeled values of DIC, alkalinity and nutrients\n\nimport subprocess\nimport os\nimport pandas as pd\n#import netCDF4\nimport numpy as np\nimport glob\nimport time\nimport matplotlib.pyplot as plt\nimport copy\nimport xarray as xr\nfrom datetime import datetime, timedelta \nimport dask\nfrom scipy.interpolate import griddata\n#from ocean_c_lab_tools import *\n#from celluloid import Camera \n#import PyCO2SYS as csys\nimport gsw as sw\nfrom roms_regrid import *\n\n\n\nxls = pd.ExcelFile('/home/x-uheede/R/HAFRO/20241210_biogeochemistry_format.xlsx')\ncombo = pd.read_excel(xls, 'Sheet1',decimal='.')\n\n\nobs=xr.Dataset.from_dataframe(combo)\nobs=obs.set_index(index=['HV','depth_bin','date'])\nobs=obs.drop_duplicates('index')\nobs=obs.unstack('index')\nobs=obs.rename(name_dict={'Latitude(°N)':'lat','Longitude(°E)':'lon'})\n\n\n\ndensity=sw.density.sigma0(obs['S'],obs['T'])\nobs['Alk']=obs['TA'] * (1 / 1000) * (density+1000)\nobs['DIC']=obs['DIC'] * (1 / 1000) * (density+1000)\n\n\n\n\n\n\n\nTA0=274\nSref=34\nDIC0=315\nnTA=((obs['Alk']-TA0)/obs['S'])*Sref+TA0\n\nnDIC=((obs['DIC']-DIC0)/obs['S'])*Sref+DIC0\n\n\n\n\nnDIC\n\n\n\nfrom roms_tools import Grid, ROMSOutput\n\n\n\ngrid = Grid.from_file(\n    \"/home/x-uheede/S/Iceland2_MARBL_2024_60m/P_INPUT/Iceland2_grid_MAT1.nc\"\n)\n\n\n\ngrid.update_vertical_coordinate(N=60, theta_s=5.0, theta_b=2.0, hc=300.0, verbose=False)\n\n\n\nroms_output_bgc = ROMSOutput(\n    grid=grid,\n    path=[\n        \"/home/x-uheede/S/Iceland2_MARBL_2024_60m/Iceland2_MARBL_2024_bgc.20240[4-9]????????.nc\",\n    ],\n    use_dask=True,\n)\n\nroms_output_phys = ROMSOutput(\n    grid=grid,\n    path=[\n        \"/home/x-uheede/S/Iceland2_MARBL_2024_60m/Iceland2_MARBL_2024_his.20240[4-9]????????.nc\",\n    ],\n    use_dask=True,\n)\n\n\n\n# open grid\ngrid=xr.open_mfdataset('/home/x-uheede/S/Iceland2_MARBL_2024_60m/P_INPUT/Iceland2_grid_MAT1.nc')\n\n# regridding\nh=roms_regrid(grid,grid['h'])\n\nmask=roms_regrid(grid,grid['mask_rho'])\n\n\n\nvar_names=['ALK','DIC','PO4','NO3','SiO3','NH4','O2']\ndepth_levels=np.arange(0, 40,5)\n\n\n\nbgc = roms_output_bgc.regrid(depth_levels=depth_levels,var_names=var_names).load()\nphys = roms_output_phys.regrid(depth_levels=depth_levels)\n\n\n\ntime_index = bgc.indexes['time']\nunique_time = ~time_index.duplicated()\n\nbgc = bgc.isel(time=unique_time)\nbgc = bgc.sortby('time')\n\n\n\ntime_index = phys.indexes['time']\nunique_time = ~time_index.duplicated()\n\nphys = phys.isel(time=unique_time)\nphys = phys.sortby('time')\n\n\n\nnTA_model=((bgc['ALK'].load()-TA0)/phys['salt'].load())*Sref+TA0\n\nnDIC_model=((bgc['DIC'].load()-DIC0)/phys['salt'].load())*Sref+DIC0\n\nbgc['nTA']=nTA_model\nbgc['nDIC']=nDIC_model\n\n\n\n\n\n\n\n# define location which calculations the average location of each station\ndef get_location(obs, hv_values):\n    locations = []\n    for hv in hv_values:\n        lat = (obs['lat'].sel(HV=hv).isel(depth_bin=0).mean('date').squeeze()).values+0\n        lon = obs['lon'].sel(HV=hv).isel(depth_bin=0).mean('date').squeeze().values + 360\n        locations.append([lat, lon])\n    return locations\n\n# List of HV values\nhv_values = 1,3,5,7,9,10,12\n\n# Get the locations\nlocations = get_location(obs, hv_values)\n\n\n\n# Assuming locations is a list of lat/lon pairs\nbgc_values = []\n\n# Loop over the first 10 locations and store each selection in t_values\nfor i in range(7):\n    lat, lon = locations[i]\n    \n    # Select the 't' values at the nearest lat/lon\n    bgc_selected = bgc.sel(lat=lat, method='nearest').sel(lon=lon, method='nearest')\n    \n    # Store the result in the list\n    bgc_values.append(bgc_selected)\n\n# Combine the selections into an xarray Dataset or DataArray\nbgc_values_combined = xr.concat(bgc_values, dim='location')\n\n# Assign a location coordinate for clarity (optional)\nbgc_values_combined = bgc_values_combined.assign_coords(location=('location', [1,3,5,7,9,10,12]))\nbgc_values_combined['depth']=bgc_values_combined.depth*(-1)\n\n\n\n\n\n\n\n\nbgc_sub=bgc_values_combined.sel(time=(['2024-04-04T00:00:00.000000000', '2024-04-18T00:00:00.000000000',\n       '2024-04-26T00:00:00.000000000', '2024-05-13T00:00:00.000000000',\n       '2024-05-28T00:00:00.000000000', '2024-06-11T00:00:00.000000000',\n       '2024-06-26T00:00:00.000000000','2024-07-09T00:00:00.000000000','2024-07-25T00:00:00.000000000','2024-08-04T00:00:00.000000000',\n                                      '2024-09-17T00:00:00.000000000']), method='nearest')\n\n\n\nbgc_sub.load()\n\n\n\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Define depth levels\nlevels = np.arange(0, 80)\n\n# Create figure and subplots (3 rows: 1 for the map, 2 for boxplots)\nfig = plt.figure(figsize=(12, 13))  # Wider figure for side-by-side plots\ngs = fig.add_gridspec(3, 2, height_ratios=[2, 1, 1], width_ratios=[1, 1])  \n\n# --- Shared Map (Top Row, Spanning Both Columns) ---\nax_map = fig.add_subplot(gs[0, :], projection=ccrs.PlateCarree())\n\n# Plot bathymetry\ncf1 = ax_map.contourf(h.lon, h.lat, h, levels, transform=ccrs.PlateCarree(), cmap='cividis')\nax_map.contourf(h.lon, h.lat, mask.where(mask != 1), cmap='Greys', transform=ccrs.PlateCarree())\n\n# Add station labels\nfor i, e in enumerate(locations):\n    ax_map.text(e[1], e[0], hv_values[i], color='red', size=10, ha='center', va='center', transform=ccrs.PlateCarree())\n\n# Gridlines\ngls = ax_map.gridlines(crs=ccrs.PlateCarree(), draw_labels=True, color='darkgray', alpha=0.5, linestyle='--')\ngls.top_labels = False\ngls.right_labels = False\n\n# Colorbar\ncb1 = plt.colorbar(cf1, shrink=0.5, ax=ax_map, orientation='horizontal', pad=0.05)\ncb1.set_label('Bottom Depth (m)', fontsize=10)\n\nax_map.set_extent([-22, -21.35, 64.25, 64.45], ccrs.PlateCarree())\nax_map.set_title('Station Overview')\n\n# --- Function for Extracting Data ---\ndef extract_cruise_data(var, depth=None, num_cruises=11):\n    \"\"\"Extracts non-NaN values for a given variable across cruises.\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(date=i) if depth is None else var.isel(date=i, depth_bin=depth))\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\ndef extract_model_data(var, depth=None, num_cruises=10):\n    \"\"\"Extracts non-NaN values from the model across time steps.\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(time=i) if depth is None else var.isel(time=i, depth=depth))\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\n# --- Boxplots for Observations (Left) and Model (Right) ---\nax_obs = fig.add_subplot(gs[1, 0])  # Observations\nax_model = fig.add_subplot(gs[1, 1])  # Model\n\nax_obs.boxplot(extract_cruise_data(nTA), patch_artist=True)\nax_obs.set_title('Salinity Normalized Alk Variation (Observed)')\nax_obs.set_ylabel('mmol/m$^3$')\nax_obs.set_xticklabels([])\nax_obs.set_ylim(2280,2370)\n\nax_model.boxplot(extract_model_data(bgc_sub['nTA']), patch_artist=True)\nax_model.set_title('Salinity Normalized Alk Variation (Model)')\nax_model.set_xticklabels([])\nax_model.set_ylim(2230,2320)\n\n# --- Surface-Only Boxplots for Observations (Left) and Model (Right) ---\nax_obs_surface = fig.add_subplot(gs[2, 0])  # Observations (Surface)\nax_model_surface = fig.add_subplot(gs[2, 1])  # Model (Surface)\n\nax_obs_surface.boxplot(extract_cruise_data(nTA, depth=0), patch_artist=True)\nax_obs_surface.set_title('Salinity Normalized Alk, Surface Only (Observed)')\nax_obs_surface.set_xlabel('Cruise')\nax_obs_surface.set_ylabel('mmol/m$^3$')\nax_obs_surface.set_xticklabels(pd.to_datetime(obs['date'].isel(date=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\nax_obs_surface.set_ylim(2310,2390)\n\nax_model_surface.boxplot(extract_model_data(bgc_sub['nTA'], depth=0), patch_artist=True)\nax_model_surface.set_title('Salinity Normalized Alk, Surface Only (Model)')\nax_model_surface.set_xlabel('Cruise')\nax_model_surface.set_ylabel('mmol/m$^3$')\nax_model_surface.set_xticklabels(pd.to_datetime(bgc_sub['time']).strftime('%d/%m/%Y'), rotation=45)\nax_model_surface.set_ylim(2230,2310)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Define depth levels\nlevels = np.arange(0, 80)\n\n# Create figure and subplots (3 rows: 1 for the map, 2 for boxplots)\nfig = plt.figure(figsize=(12, 7))  # Wider figure for side-by-side plots\ngs = fig.add_gridspec(2, 2, height_ratios=[1, 1], width_ratios=[1, 1])  \n\n\n\n# --- Function for Extracting Data ---\ndef extract_cruise_data(var, depth=None, num_cruises=10):\n    \"\"\"Extracts non-NaN values for a given variable across cruises.\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(date=i) if depth is None else var.isel(date=i, depth_bin=depth))\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\ndef extract_model_data(var, depth=None, num_cruises=10):\n    \"\"\"Extracts non-NaN values from the model across time steps.\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(time=i) if depth is None else var.isel(time=i, depth=depth))\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\n# --- Boxplots for Observations (Left) and Model (Right) ---\nax_obs = fig.add_subplot(gs[0, 0])  # Observations\nax_model = fig.add_subplot(gs[0, 1])  # Model\n\nax_obs.boxplot(extract_cruise_data(nDIC), patch_artist=True)\nax_obs.set_title('Salinity Normalized DIC Variation (Observed)')\nax_obs.set_ylabel('mmol/m$^3$')\nax_obs.set_xticklabels([])\nax_obs.set_ylim(2070,2180)\n\nax_model.boxplot(extract_model_data(bgc_sub['nDIC']), patch_artist=True)\nax_model.set_title('Salinity Normalized DIC Variation (Model)')\nax_model.set_xticklabels([])\nax_model.set_ylim(2030,2140)\n\n# --- Surface-Only Boxplots for Observations (Left) and Model (Right) ---\nax_obs_surface = fig.add_subplot(gs[1, 0])  # Observations (Surface)\nax_model_surface = fig.add_subplot(gs[1, 1])  # Model (Surface)\n\nax_obs_surface.boxplot(extract_cruise_data(nDIC, depth=0), patch_artist=True)\nax_obs_surface.set_title('Salinity Normalized DIC, Surface Only (Observed)')\nax_obs_surface.set_xlabel('Cruise')\nax_obs_surface.set_ylabel('mmol/m$^3$')\nax_obs_surface.set_xticklabels(pd.to_datetime(obs['date'].isel(date=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\nax_obs_surface.set_ylim(2070,2180)\n\nax_model_surface.boxplot(extract_model_data(bgc_sub['nDIC'], depth=0), patch_artist=True)\nax_model_surface.set_title('Salinity Normalized DIC, Surface Only (Model)')\nax_model_surface.set_xlabel('Cruise')\nax_model_surface.set_ylabel('mmol/m$^3$')\nax_model_surface.set_xticklabels(pd.to_datetime(bgc_sub['time'].isel(time=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\nax_model_surface.set_ylim()\nax_model_surface.set_ylim(2030,2150)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nloc = obs['lon'].sel(HV=[1,5,9,10]).isel(depth_bin=0).mean('date').values\ndepth=obs['depth_bin'].values\nlevels=np.arange(2290,2360,2)\n\nbins = np.arange(0, 90, 10) \n#depth_bins = xr.DataArray(pd.cut(depth, bins, labels=bins[:-1]), dims=\"depth\", name=\"binned_depth\")\n\ndata_alk1=nTA.sel(HV=[1,5,9,10]).isel(date=slice(0,10)).mean('date')\ndata_alk2=obs['Alk'].sel(HV=[1,5,9,10]).isel(date=slice(0,10)).mean('date')\n\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(6*2, 3), constrained_layout=True)\nax = axarr.flatten()\n\n#c0=ax[0].contourf(loc, data_alk.depth, data_alk.transpose())\nc0=ax[0].contourf(loc,data_alk1.depth_bin,data_alk1.transpose(),levels)\nplt.colorbar(c0,ax=ax[0], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[0].invert_yaxis()\nax[0].set_title('salinity normalized alkalinity along fjord (observed)')\nax[0].set_xlabel('longitude')\nax[0].set_ylabel('depth (m)')\n\nc0=ax[1].contourf(loc,data_alk2.depth_bin,data_alk2.transpose(),levels)\nplt.colorbar(c0,ax=ax[1], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[1].invert_yaxis()\nax[1].set_title('alkalinity along fjord (observed)')\nax[1].set_xlabel('longitude')\nax[1].set_ylabel('depth (m)')\n\n\n\nloc = obs['lon'].sel(HV=[1,5,9,10]).isel(depth_bin=0).mean('date').values\ndepth=obs['depth_bin'].values\nlevels=np.arange(2230,2300,2)\n\nbins = np.arange(0, 90, 10) \n#depth_bins = xr.DataArray(pd.cut(depth, bins, labels=bins[:-1]), dims=\"depth\", name=\"binned_depth\")\n\ndata_alk1=bgc_sub['nTA'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean('time')\ndata_alk2=bgc_sub['ALK'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean('time')\n\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(6*2, 3), constrained_layout=True)\nax = axarr.flatten()\n\n#c0=ax[0].contourf(loc, data_alk.depth, data_alk.transpose())\nc0=ax[0].contourf(loc,data_alk1.depth*(-1),data_alk1.transpose(),levels)\nplt.colorbar(c0,ax=ax[0], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[0].set_ylim(0,40)\nax[0].invert_yaxis()\nax[0].set_title('salinity normalized alkalinity along fjord (modeled)')\nax[0].set_xlabel('longitude')\nax[0].set_ylabel('depth (m)')\n\n\nc0=ax[1].contourf(loc,data_alk2.depth*(-1),data_alk2.transpose(),levels)\nplt.colorbar(c0,ax=ax[1], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[1].set_ylim(0,40)\nax[1].invert_yaxis()\nax[1].set_title('alkalinity along fjord (modeled)')\nax[1].set_xlabel('longitude')\nax[1].set_ylabel('depth (m)')\n\n\n\ndata_alk2\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Compute mean and standard deviation over time for observations\ndepth_obs = obs['depth_bin'].values\ndepth_model = bgc_sub['depth'].values\n\n# Observations (Mean and Std Dev)\nalk_mean_obs = obs['Alk'].sel(HV=[1,5,9,10]).isel(date=slice(0,10)).mean(dim=['date', 'HV'])\nalk_std_obs = obs['Alk'].sel(HV=[1,5,9,10]).isel(date=slice(0,10)).std(dim=['date', 'HV'])\n\nnalk_mean_obs = nTA.sel(HV=[1,5,9,10]).isel(date=slice(0,10)).mean(dim=['date', 'HV'])\nnalk_std_obs = nTA.sel(HV=[1,5,9,10]).isel(date=slice(0,10)).std(dim=['date', 'HV'])\n\n# Model (Mean and Std Dev)\nalk_mean_model = bgc_sub['ALK'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean(dim=['time', 'location'])\nalk_std_model = bgc_sub['ALK'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).std(dim=['time', 'location'])\n\nnalk_mean_model = bgc_sub['nTA'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean(dim=['time', 'location'])\nnalk_std_model = bgc_sub['nTA'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).std(dim=['time', 'location'])\n\n# Create figure with 2 columns (nTA on left, TA on right)\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(12, 6), constrained_layout=True)\nax = axarr.flatten()\n\n# --- Plot Salinity Normalized Alkalinity (nTA) ---\nax[0].plot(nalk_mean_obs, depth_obs, marker='o', linestyle='-', color='b', label='Observed nTA')\nax[0].fill_betweenx(depth_obs, nalk_mean_obs - nalk_std_obs, nalk_mean_obs + nalk_std_obs, color='gray', alpha=0.3)\n\nax[0].plot(nalk_mean_model, depth_model*(-1), marker='s', linestyle='--', color='r', label='Modeled nTA')\nax[0].fill_betweenx(depth_model*(-1), nalk_mean_model - nalk_std_model, nalk_mean_model + nalk_std_model, color='pink', alpha=0.3)\n\nax[0].set_ylim(0,30)\nax[0].invert_yaxis()\nax[0].set_xlabel('Salinity Normalized Alkalinity (mmol/m³)')\nax[0].set_ylabel('Depth (m)')\nax[0].set_title('Salinity Normalized Alkalinity Profile')\nax[0].legend()\nax[0].grid()\n\n# --- Plot Total Alkalinity (TA) ---\nax[1].plot(alk_mean_obs, depth_obs, marker='o', linestyle='-', color='b', label='Observed TA')\nax[1].fill_betweenx(depth_obs, alk_mean_obs - alk_std_obs, alk_mean_obs + alk_std_obs, color='gray', alpha=0.3)\n\nax[1].plot(alk_mean_model, depth_model*(-1), marker='s', linestyle='--', color='r', label='Modeled TA')\nax[1].fill_betweenx(depth_model*(-1), alk_mean_model - alk_std_model, alk_mean_model + alk_std_model, color='pink', alpha=0.3)\nax[1].set_ylim(0,30)\nax[1].invert_yaxis()\nax[1].set_xlabel('Total Alkalinity (mmol/m³)')\nax[1].set_title('Total Alkalinity Profile')\nax[1].legend()\nax[1].grid()\n\nplt.show()\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Compute mean and standard deviation over time for observations\ndepth_obs = obs['depth_bin'].values\ndepth_model = bgc_sub['depth'].values\n\n# Observations (Mean and Std Dev)\nalk_mean_obs = obs['DIC'].sel(HV=[1,5,9,10]).isel(date=slice(0,10)).mean(dim=['date', 'HV'])\nalk_std_obs = obs['DIC'].sel(HV=[1,5,9,10]).isel(date=slice(0,10)).std(dim=['date', 'HV'])\n\nnalk_mean_obs = nDIC.sel(HV=[1,5,9,10]).isel(date=slice(0,10)).mean(dim=['date', 'HV'])\nnalk_std_obs = nDIC.sel(HV=[1,5,9,10]).isel(date=slice(0,10)).std(dim=['date', 'HV'])\n\n# Model (Mean and Std Dev)\nalk_mean_model = bgc_sub['DIC'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean(dim=['time', 'location'])\nalk_std_model = bgc_sub['DIC'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).std(dim=['time', 'location'])\n\nnalk_mean_model = bgc_sub['nDIC'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean(dim=['time', 'location'])\nnalk_std_model = bgc_sub['nDIC'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).std(dim=['time', 'location'])\n\n# Create figure with 2 columns (nTA on left, TA on right)\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(12, 6), constrained_layout=True)\nax = axarr.flatten()\n\n# --- Plot Salinity Normalized Alkalinity (nTA) ---\nax[0].plot(nalk_mean_obs, depth_obs, marker='o', linestyle='-', color='b', label='Observed nTA')\nax[0].fill_betweenx(depth_obs, nalk_mean_obs - nalk_std_obs, nalk_mean_obs + nalk_std_obs, color='gray', alpha=0.3)\n\nax[0].plot(nalk_mean_model, depth_model*(-1), marker='s', linestyle='--', color='r', label='Modeled nTA')\nax[0].fill_betweenx(depth_model*(-1), nalk_mean_model - nalk_std_model, nalk_mean_model + nalk_std_model, color='pink', alpha=0.3)\n\nax[0].set_ylim(0,30)\nax[0].invert_yaxis()\nax[0].set_xlabel('Salinity Normalized DIC (mmol/m³)')\nax[0].set_ylabel('Depth (m)')\nax[0].set_title('Salinity Normalized DIC Profile')\nax[0].legend()\nax[0].grid()\n\n# --- Plot Total Alkalinity (TA) ---\nax[1].plot(alk_mean_obs, depth_obs, marker='o', linestyle='-', color='b', label='Observed TA')\nax[1].fill_betweenx(depth_obs, alk_mean_obs - alk_std_obs, alk_mean_obs + alk_std_obs, color='gray', alpha=0.3)\n\nax[1].plot(alk_mean_model, depth_model*(-1), marker='s', linestyle='--', color='r', label='Modeled TA')\nax[1].fill_betweenx(depth_model*(-1), alk_mean_model - alk_std_model, alk_mean_model + alk_std_model, color='pink', alpha=0.3)\nax[1].set_ylim(0,30)\nax[1].invert_yaxis()\nax[1].set_xlabel('Total DIC (mmol/m³)')\nax[1].set_title('Total DIC Profile')\nax[1].legend()\nax[1].grid()\n\nplt.show()\n\n\n\n\nloc = obs['lon'].sel(HV=[1,5,9,10]).isel(depth_bin=0).mean('date').values\ndepth=obs['depth_bin'].values\nlevels=np.arange(2070,2160,2)\n\nbins = np.arange(0, 90, 10) \n#depth_bins = xr.DataArray(pd.cut(depth, bins, labels=bins[:-1]), dims=\"depth\", name=\"binned_depth\")\n\ndata_alk1=nDIC.sel(HV=[1,5,9,10]).isel(date=slice(0,4)).mean('date')\ndata_alk2=nDIC.sel(HV=[1,5,9,10]).isel(date=slice(5,10)).mean('date')\n\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(6*2, 3), constrained_layout=True)\nax = axarr.flatten()\n\n#c0=ax[0].contourf(loc, data_alk.depth, data_alk.transpose())\nc0=ax[0].contourf(loc,data_alk1.depth_bin,data_alk1.transpose(),levels)\nplt.colorbar(c0,ax=ax[0], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[0].invert_yaxis()\nax[0].set_title('salinity normalized DIC along fjord April-May (observed)')\nax[0].set_xlabel('longitude')\nax[0].set_ylabel('depth (m)')\n\nc0=ax[1].contourf(loc,data_alk2.depth_bin,data_alk2.transpose(),levels)\nplt.colorbar(c0,ax=ax[1], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[1].invert_yaxis()\nax[1].set_title('salinity normalized DIC along fjord June-August (observed)')\nax[1].set_xlabel('longitude')\nax[1].set_ylabel('depth (m)')\n\n\n\nloc = obs['lon'].sel(HV=[1,5,9,10]).isel(depth_bin=0).mean('date').values\ndepth=obs['depth_bin'].values\nlevels=np.arange(2070,2160,2)\n\nbins = np.arange(0, 90, 10) \n#depth_bins = xr.DataArray(pd.cut(depth, bins, labels=bins[:-1]), dims=\"depth\", name=\"binned_depth\")\n\ndata_alk1=nDIC.sel(HV=[1,5,9,10]).isel(date=slice(0,4)).mean('date')\ndata_alk2=nDIC.sel(HV=[1,5,9,10]).isel(date=slice(5,10)).mean('date')\n\ndata_alk1=bgc_sub['nDIC'].sel(location=[1,5,9,10]).isel(time=slice(0,4)).mean('time')\ndata_alk2=bgc_sub['nDIC'].sel(location=[1,5,9,10]).isel(time=slice(5,10)).mean('time')\n\n\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(6*2, 3), constrained_layout=True)\nax = axarr.flatten()\n\n#c0=ax[0].contourf(loc, data_alk.depth, data_alk.transpose())\nc0=ax[0].contourf(loc,data_alk1.depth*(-1),data_alk1.transpose(),levels)\nplt.colorbar(c0,ax=ax[0], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[0].set_ylim(0,40)\nax[0].invert_yaxis()\nax[0].set_title('salinity normalized DIC along fjord April-May (modeled)')\nax[0].set_xlabel('longitude')\nax[0].set_ylabel('depth (m)')\n\nc0=ax[1].contourf(loc,data_alk2.depth*(-1),data_alk2.transpose(),levels)\nplt.colorbar(c0,ax=ax[1], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[1].set_ylim(0,40)\nax[1].invert_yaxis()\nax[1].set_title('salinity normalized DIC along fjord June-August (modeled )')\nax[1].set_xlabel('longitude')\nax[1].set_ylabel('depth (m)')\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Create figure and subplots (1 row for salinity-normalized DIC, 2 columns for observations vs. model)\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(12, 5), sharex=False)\n\n# --- Data Extraction Functions ---\ndef extract_depth_avg(var, depth_range, time_dim='date'):\n    \"\"\"Extracts mean value across a given depth range for each time step.\"\"\"\n    return var.sel(depth_bin=slice(*depth_range)).mean(dim='depth_bin', skipna=True)\n\ndef extract_depth_avg_model(var, depth_range, time_dim='time'):\n    \"\"\"Extracts mean value across a given depth range for each time step.\"\"\"\n    return var.sel(depth=slice(*depth_range)).mean(dim='depth', skipna=True)\n\n# Define depth ranges\nupper_depth_range = (0, 5)   # Upper level (0-10 m)\nlower_depth_range = (20, 40)  # Lower level (20-40 m)\n\nupper_depth_range_m = (-0.5,-5)   # Upper level (0-10 m)\nlower_depth_range_m = (-20, -40)  # Lower level (20-40 m)\n\n# --- Observations ---\nax_obs = axes[0]\nobs_upper = extract_depth_avg(nDIC.mean('HV'), upper_depth_range)\nobs_lower = extract_depth_avg(nDIC.mean('HV'), lower_depth_range)\n\nax_obs.plot(obs['date'], obs_upper, label='0-10m', marker='o', linestyle='-')\nax_obs.plot(obs['date'], obs_lower, label='20-40m', marker='s', linestyle='--')\nax_obs.set_title('Salinity-Normalized DIC (Observed)')\nax_obs.set_ylabel('mmol/m$^3$')\nax_obs.legend()\nax_obs.tick_params(axis='x', rotation=45)  # Rotate x-axis labels\n\n# --- Model ---\nax_model = axes[1]\nmodel_upper = extract_depth_avg_model(bgc_sub['nDIC'].mean('location'), upper_depth_range_m, time_dim='time')\nmodel_lower = extract_depth_avg_model(bgc_sub['nDIC'].mean('location'), lower_depth_range_m, time_dim='time')\n\nax_model.plot(bgc_sub['time'], model_upper, label='0-10m', marker='o', linestyle='-')\nax_model.plot(bgc_sub['time'], model_lower, label='20-40m', marker='s', linestyle='--')\nax_model.set_title('Salinity-Normalized DIC (Model)')\nax_model.legend()\nax_model.tick_params(axis='x', rotation=45)  # Rotate x-axis labels\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Create figure and subplots (4 rows for nutrients, 2 columns for observations vs. model)\nfig = plt.figure(figsize=(12, 13))  # Wider figure for side-by-side comparison\ngs = fig.add_gridspec(4, 2, height_ratios=[1, 1, 1, 1], width_ratios=[1, 1])  \n\n# --- Data Extraction Functions ---\ndef extract_cruise_data(var, depth=0, num_cruises=10):\n    \"\"\"Extracts non-NaN values for a given variable across cruises (observations).\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(date=i) if depth is None else var.isel(date=i, depth_bin=depth))\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\ndef extract_model_data(var, depth=0, num_cruises=10):\n    \"\"\"Extracts non-NaN values from the model across time steps.\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(time=i) if depth is None else var.isel(time=i, depth=depth))\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\n# --- NO3 Boxplots ---\nax1_obs = fig.add_subplot(gs[0, 0])  # Observations\nax1_model = fig.add_subplot(gs[0, 1])  # Model\n\nax1_obs.boxplot(extract_cruise_data(obs['NO3']), patch_artist=True)\nax1_obs.set_title('NO₃ Surface Only (Observed)')\nax1_obs.set_ylabel('mmol/m$^3$')\nax1_obs.set_xticklabels([])\n\nax1_model.boxplot(extract_model_data(bgc_sub['NO3']), patch_artist=True)\nax1_model.set_title('NO₃ Surface Only (Model)')\nax1_model.set_xticklabels([])\n\n# --- PO4 Boxplots ---\nax2_obs = fig.add_subplot(gs[1, 0])  # Observations\nax2_model = fig.add_subplot(gs[1, 1])  # Model\n\nax2_obs.boxplot(extract_cruise_data(obs['PO4']), patch_artist=True)\nax2_obs.set_title('PO₄ Surface Only (Observed)')\nax2_obs.set_ylabel('mmol/m$^3$')\nax2_obs.set_xticklabels([])\n\nax2_model.boxplot(extract_model_data(bgc_sub['PO4']), patch_artist=True)\nax2_model.set_title('PO₄ Surface Only (Model)')\nax2_model.set_xticklabels([])\n\n# --- SiO2 Boxplots ---\nax3_obs = fig.add_subplot(gs[2, 0])  # Observations\nax3_model = fig.add_subplot(gs[2, 1])  # Model\n\nax3_obs.boxplot(extract_cruise_data(obs['SiO2']), patch_artist=True)\nax3_obs.set_title('SiO₂ Surface Only (Observed)')\nax3_obs.set_ylabel('mmol/m$^3$')\nax3_obs.set_xticklabels([])\n\nax3_model.boxplot(extract_model_data(bgc_sub['SiO3']), patch_artist=True)\nax3_model.set_title('SiO₂ Surface Only (Model)')\nax3_model.set_xticklabels([])\n\n# --- NH4 Boxplots ---\nax4_obs = fig.add_subplot(gs[3, 0])  # Observations\nax4_model = fig.add_subplot(gs[3, 1])  # Model\n\nax4_obs.boxplot(extract_cruise_data(obs['NH4']), patch_artist=True)\nax4_obs.set_title('NH₄ Surface Only (Observed)')\nax4_obs.set_xlabel('Cruise')\nax4_obs.set_ylabel('mmol/m$^3$')\nax4_obs.set_xticklabels(pd.to_datetime(obs['date'].isel(date=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\n\nax4_model.boxplot(extract_model_data(bgc_sub['NH4']), patch_artist=True)\nax4_model.set_title('NH₄ Surface Only (Model)')\nax4_model.set_xlabel('Cruise')\nax4_model.set_ylabel('mmol/m$^3$')\nax4_model.set_xticklabels(pd.to_datetime(bgc_sub['time'].isel(time=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Create figure and subplots (4 rows for nutrients, 2 columns for observations vs. model)\nfig = plt.figure(figsize=(12, 13))  # Wider figure for side-by-side comparison\ngs = fig.add_gridspec(4, 2, height_ratios=[1, 1, 1, 1], width_ratios=[1, 1])  \n\n# --- Data Extraction Functions ---\ndef extract_cruise_data(var, num_cruises=10):\n    \"\"\"Extracts non-NaN values for a given variable across all depths and cruises (observations).\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(date=i))  # Include all depth levels\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\ndef extract_model_data(var, num_cruises=10):\n    \"\"\"Extracts non-NaN values for a given variable across all depths and time steps (model).\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(time=i))  # Include all depth levels\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\n# --- NO3 Boxplots (All Depths) ---\nax1_obs = fig.add_subplot(gs[0, 0])  # Observations\nax1_model = fig.add_subplot(gs[0, 1])  # Model\n\nax1_obs.boxplot(extract_cruise_data(obs['NO3']), patch_artist=True)\nax1_obs.set_title('NO₃ (All Depths, Observed)')\nax1_obs.set_ylabel('mmol/m$^3$')\nax1_obs.set_xticklabels([])\n\nax1_model.boxplot(extract_model_data(bgc_sub['NO3']), patch_artist=True)\nax1_model.set_title('NO₃ (All Depths, Model)')\nax1_model.set_xticklabels([])\n\n# --- PO4 Boxplots (All Depths) ---\nax2_obs = fig.add_subplot(gs[1, 0])  # Observations\nax2_model = fig.add_subplot(gs[1, 1])  # Model\n\nax2_obs.boxplot(extract_cruise_data(obs['PO4']), patch_artist=True)\nax2_obs.set_title('PO₄ (All Depths, Observed)')\nax2_obs.set_ylabel('mmol/m$^3$')\nax2_obs.set_xticklabels([])\n\nax2_model.boxplot(extract_model_data(bgc_sub['PO4']), patch_artist=True)\nax2_model.set_title('PO₄ (All Depths, Model)')\nax2_model.set_xticklabels([])\n\n# --- SiO2 Boxplots (All Depths) ---\nax3_obs = fig.add_subplot(gs[2, 0])  # Observations\nax3_model = fig.add_subplot(gs[2, 1])  # Model\n\nax3_obs.boxplot(extract_cruise_data(obs['SiO2']), patch_artist=True)\nax3_obs.set_title('SiO₂ (All Depths, Observed)')\nax3_obs.set_ylabel('mmol/m$^3$')\nax3_obs.set_xticklabels([])\n\nax3_model.boxplot(extract_model_data(bgc_sub['SiO3']), patch_artist=True)\nax3_model.set_title('SiO₂ (All Depths, Model)')\nax3_model.set_xticklabels([])\n\n# --- NH4 Boxplots (All Depths) ---\nax4_obs = fig.add_subplot(gs[3, 0])  # Observations\nax4_model = fig.add_subplot(gs[3, 1])  # Model\n\nax4_obs.boxplot(extract_cruise_data(obs['NH4']), patch_artist=True)\nax4_obs.set_title('NH₄ (All Depths, Observed)')\nax4_obs.set_xlabel('Cruise')\nax4_obs.set_ylabel('mmol/m$^3$')\nax4_obs.set_xticklabels(pd.to_datetime(obs['date'].isel(date=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\n\nax4_model.boxplot(extract_model_data(bgc_sub['NH4']), patch_artist=True)\nax4_model.set_title('NH₄ (All Depths, Model)')\nax4_model.set_xlabel('Cruise')\nax4_model.set_ylabel('mmol/m$^3$')\nax4_model.set_xticklabels(pd.to_datetime(bgc_sub['time'].isel(time=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Create figure and subplots (4 rows for nutrients, 2 columns for observations vs. model)\nfig, axes = plt.subplots(nrows=4, ncols=2, figsize=(12, 13), sharex=False)  \n\n# --- Data Extraction Functions ---\ndef extract_depth_avg(var, depth_range, time_dim='date'):\n    \"\"\"Extracts mean value across a given depth range for each time step.\"\"\"\n    return var.sel(depth_bin=slice(*depth_range)).mean(dim='depth_bin', skipna=True)\n\ndef extract_depth_avg_model(var, depth_range, time_dim='time'):\n    \"\"\"Extracts mean value across a given depth range for each time step.\"\"\"\n    return var.sel(depth=slice(*depth_range)).mean(dim='depth', skipna=True)\n\n# Define depth ranges\nupper_depth_range = (0,5)   # Upper level (0-10 m)\nlower_depth_range = (20, 40)  # Lower level (20-40 m)\n\nupper_depth_range_m = (-0.5,-5)   # Upper level (0-10 m)\nlower_depth_range_m = (-20, -40)  # Lower level (20-40 m)\n\n# Define nutrients and their respective labels\nnutrients = ['NO3', 'PO4', 'SiO2', 'NH4']\nnutrients_m = ['NO3', 'PO4', 'SiO3', 'NH4']\ntitles = ['NO₃', 'PO₄', 'SiO$_3$', 'NH₄']\n\n# --- Plot each nutrient ---\nfor i, nutrient in enumerate(nutrients):\n    # Observations\n    ax_obs = axes[i, 0]\n    obs_upper = extract_depth_avg(obs[nutrient].mean('HV'), upper_depth_range)\n    obs_lower = extract_depth_avg(obs[nutrient].mean('HV'), lower_depth_range)\n\n    ax_obs.plot(obs['date'], obs_upper, label='0-10m', marker='o', linestyle='-')\n    ax_obs.plot(obs['date'], obs_lower, label='20-40m', marker='s', linestyle='--')\n    ax_obs.set_title(f'{titles[i]} (Observed)')\n    ax_obs.set_ylabel('mmol/m$^3$')\n    ax_obs.legend()\n    ax_obs.tick_params(axis='x', rotation=45)  # Rotate x-axis labels\n\n\nfor i, nutrient in enumerate(nutrients_m):\n    # Model\n    ax_model = axes[i, 1]\n    model_upper = extract_depth_avg_model(bgc_sub[nutrient].mean('location'), upper_depth_range_m, time_dim='time')\n    model_lower = extract_depth_avg_model(bgc_sub[nutrient].mean('location'), lower_depth_range_m, time_dim='time')\n\n    ax_model.plot(bgc_sub['time'], model_upper, label='0-10m', marker='o', linestyle='-')\n    ax_model.plot(bgc_sub['time'], model_lower, label='20-40m', marker='s', linestyle='--')\n    ax_model.set_title(f'{titles[i]} (Model)')\n    ax_model.legend()\n    ax_model.tick_params(axis='x', rotation=45)  # Rotate x-axis labels\n\n\nplt.tight_layout()\nplt.show()\n\n\n","type":"content","url":"/bgc-analysis-200m","position":1},{"hierarchy":{"lvl1":"Comparison of the HAFRO CTD data with ROMS model output"},"type":"lvl1","url":"/ctd-comparison-200-wico","position":0},{"hierarchy":{"lvl1":"Comparison of the HAFRO CTD data with ROMS model output"},"content":"This notebook loads the observed CTD data and model data. It converts observed data to xarray format, and regrids model data onto lat,lon,z coordinates. There are some options available to reduce the model data loaded in for the sake of available memory. It then makes various plots of stratification and seasonal evolution of salinity and temperature. We use the roms-tools regridder.\n\n# Loading in modules\n\nimport subprocess\nimport os\nimport pandas as pd\nimport netCDF4\nimport numpy as np\nimport glob\nimport time\nimport matplotlib.pyplot as plt\nimport copy\n\nimport xarray as xr\nfrom datetime import datetime, timedelta \nimport dask\nfrom scipy.interpolate import griddata\n#from ocean_c_lab_tools import *\n#from celluloid import Camera \n#import PyCO2SYS as csys\n#import seawater as sw\nfrom roms_regrid import *\n\n\n\n","type":"content","url":"/ctd-comparison-200-wico","position":1},{"hierarchy":{"lvl1":"Comparison of the HAFRO CTD data with ROMS model output","lvl2":"Setting parameters and paths"},"type":"lvl2","url":"/ctd-comparison-200-wico#setting-parameters-and-paths","position":2},{"hierarchy":{"lvl1":"Comparison of the HAFRO CTD data with ROMS model output","lvl2":"Setting parameters and paths"},"content":"Here, all the parameters for model regridding, the paths for data storage, and the chosen length of model comparison are set, so that the remainder of the notebook needs minimal adjustment\n\nHAFRO_path='/home/x-uheede/R/HAFRO/Hafro_cruises.xls'\nmodel_grid_path=\"/home/x-uheede/S/Iceland2_MARBL_2024_60m/P_INPUT/Iceland2_grid_MAT1.nc\"\n# Grid parameters, only modify these if grid is made in MATLAB\nvert_levels=60\ntheta_s_model=5\ntheta_b_model=2\nhc_model=300\nmodel_data_path=\"/home/x-uheede/S/Iceland2_NOMARBL_2024_NewV/Iceland2_MARBL_2024_his.20240[4-8]????????.nc\"\nmonths_analysis=[4,5,6,7,8] # enter the months you want to analyze for the model\n# enter the dates you want to analyze for the observations\nmonths_string_begin='01-04-2024'\nmonths_string_end='31-08-2024'\ntarget_depth_levels=[1,2,3,4,5,7,9,10,12,14,15,16,18,20,26,30,36,40,50,80] # Specify depth levels of interest\nthinner=24*7 # specify the temporal frequency of data being read (i.e. no need to read in hourly data)\n\n\n\n\n# Read in observed data\nxls = pd.ExcelFile(HAFRO_path)\n\ncombo = pd.read_excel(xls, 'combo',decimal='.')\n\nobs=xr.Dataset.from_dataframe(combo)\n\n# reformat into xarray dataset, HV is our station number indicator\nobs=obs.set_index(index=['HV','Depth','mon/day/yr'])\nobs=obs.drop_duplicates('index')\nobs=obs.unstack('index')\n# renaming variables that have strange formatting in the excelsheet\nobs=obs.rename(name_dict={'mon/day/yr':'time','Depth':'depth','Latitude(¬∞N)':'lat','Longitude(¬∞E)':'lon'})\n\n\n\n\n# define location which calculations the average location of each station\ndef get_location(obs, hv_values):\n    locations = []\n    for hv in hv_values:\n        lat = obs['lat'].sel(HV=hv).isel(depth=0).mean('time').squeeze().values\n        lon = obs['lon'].sel(HV=hv).isel(depth=0).mean('time').squeeze().values + 360\n        locations.append([lat, lon])\n    return locations\n\n# List of HV values\nhv_values = range(1, 13)\n\n# Get the locations\nlocations = get_location(obs, hv_values)\n\n\n\nfrom roms_tools import Grid, ROMSOutput\n\n\n\ngrid = Grid.from_file(\n    model_grid_path\n)\n\n\n\n#Only run this cell if grid is made in MATLAB\ngrid.update_vertical_coordinate(N=vert_levels, theta_s=theta_s_model, theta_b=theta_b_model, hc=hc_model, verbose=False)\n\n\n\nimport xarray as xr\nimport numpy as np\n\n# Load ROMS output using your pattern\nroms_output = ROMSOutput(\n    grid=grid,\n    path=[\n        model_data_path,\n    ],\n    use_dask=True,\n)\n\nds = roms_output.regrid(var_names=[\"temp\", \"salt\"],depth_levels=target_depth_levels)\n\n# Extract month for each time entry\nmonths = ds.time.dt.month\n\n# Dimensions we want\nmonth_vals = months_analysis\ntypes = [\"mean\", \"std\"]\n\n# Create empty datasets for salt & temp\nsalt_data = []\ntemp_data = []\n\nfor m in month_vals:\n    ds_m = ds.sel(time=months == m)\n\n    # Calculate and append mean & std\n    salt_mean = ds_m[\"salt\"].thin({'time': thinner}).mean(\"time\").load()\n    salt_std  = ds_m[\"salt\"].thin({'time': thinner}).std(\"time\").load()\n    temp_mean = ds_m[\"temp\"].thin({'time': thinner}).mean(\"time\").load()\n    temp_std  = ds_m[\"temp\"].thin({'time': thinner}).std(\"time\").load()\n\n    salt_data.append(xr.concat([salt_mean, salt_std], dim=\"type\"))\n    temp_data.append(xr.concat([temp_mean, temp_std], dim=\"type\"))\n\n# Concatenate over month dimension\nsalt_all = xr.concat(salt_data, dim=\"month\")\ntemp_all = xr.concat(temp_data, dim=\"month\")\n\n# Assign coordinates\nsalt_all = salt_all.assign_coords(type=types, month=month_vals)\ntemp_all = temp_all.assign_coords(type=types, month=month_vals)\n\n# Build final dataset\nds_monthly = xr.Dataset(\n    {\n        \"salt\": salt_all,\n        \"temp\": temp_all,\n    }\n)\n\nprint(ds_monthly)\n\n\n\n\n\n[months_analysis]\n\n\n\nt=ds_monthly['temp']\ns=ds_monthly['salt']\n\n\n\n# Assuming locations is a list of lat/lon pairs\nt_values = []\ns_values = []\n# Loop over the first 10 locations and store each selection in t_values\nfor i in range(12):\n    lat, lon = locations[i]\n    \n    # Select the 't' values at the nearest lat/lon\n    t_selected = t.sel(lat=lat, method='nearest').sel(lon=lon, method='nearest')\n    s_selected = s.sel(lat=lat, method='nearest').sel(lon=lon, method='nearest')\n    \n    # Store the result in the listx\n    t_values.append(t_selected)\n    s_values.append(s_selected)\n\n# Combine the selections into an xarray Dataset or DataArray\nt_values_combined = xr.concat(t_values, dim='location')\ns_values_combined = xr.concat(s_values, dim='location')\n\n# Assign a location coordinate for clarity (optional)\nt_values_combined = t_values_combined.assign_coords(location=('location', range(1, 13)))\ns_values_combined = s_values_combined.assign_coords(location=('location', range(1, 13)))\nt_values_combined['depth']=t_values_combined.depth*(-1)\ns_values_combined['depth']=s_values_combined.depth*(-1)\n# Now you have t_values as an xarray object (Dataset or DataArray)\n#print(t_values_combined)\n\n\n\n\nimport matplotlib.pyplot as plt\n\n# Set up the subplots\nfig, axarr = plt.subplots(nrows=3, ncols=4, figsize=(12, 6*1.2), constrained_layout=True)\nax = axarr.flatten()  # Flatten to make indexing easier\npalette = plt.get_cmap('tab20')\n\n# Loop through 12 locations\nfor i in range(12):\n    loc = i + 1  # location index starts at 1\n\n    # Extract model data\n    model_mean = s_values_combined.isel(type=0).mean('month').sel(location=loc)\n    model_std = s_values_combined.isel(type=1).mean('month').sel(location=loc)\n\n    # Plot model average\n    ax[i].plot(model_mean, s_values_combined.depth*(-1), label='Model Avg', color='black')\n\n    # Plot shaded region for model standard deviation\n    ax[i].fill_betweenx(s_values_combined.depth*(-1), model_mean - model_std, model_mean + model_std, \n                         color='grey', alpha=0.4, label='Model Std Dev')\n\n    # Extract observed data\n    ax[i].plot(obs['Salinity'].sel(HV=loc).dropna(dim='depth', how='all').sel(time=slice(months_string_begin, months_string_end)).mean('time'),\n            obs.sel(HV=loc).dropna(dim='depth', how='all').depth, label='Obs', color=palette(2))\n\n    obs_std = obs['Salinity'].sel(HV=loc).dropna(dim='depth', how='all').sel(time=slice(months_string_begin, months_string_end)).std('time')\n\n\n    # Plot shaded region for observed standard deviation\n    ax[i].fill_betweenx(obs.depth, (obs['Salinity'].sel(HV=loc).sel(time=slice(months_string_begin, months_string_end)).mean('time')-obs['Salinity'].sel(HV=loc).sel(time=slice(months_string_begin, months_string_end)).std('time')),(obs['Salinity'].sel(HV=loc).sel(time=slice(months_string_begin, months_string_end)).mean('time')+obs['Salinity'].sel(HV=loc).sel(time=slice(months_string_begin, months_string_end)).std('time')), color=palette(2), alpha=0.4)\n\n    # Set depth limits for specific subplots\n    ax[0].set_ylim(0,35)\n    ax[2].set_ylim(0,25)\n    ax[3].set_ylim(0,30)\n    ax[4].set_ylim(0,70)\n    ax[5].set_ylim(0,28)\n    ax[6].set_ylim(0,25)\n    ax[7].set_ylim(0,25)\n    ax[8].set_ylim(0,20)\n    ax[9].set_ylim(0,60)\n    ax[11].set_ylim(0,6)\n\n    # Set title, labels\n    ax[i].set_title(f'Salinity CTD Station: {obs.HV[loc - 1].values}')\n    ax[i].set_xlabel('psu')\n    ax[i].set_ylabel('Depth')\n\n    # Show legend only for the first subplot\n    if i == 1:\n        ax[i].legend()\n\nfor i in range(12):\n    ax[i].invert_yaxis()\n    \n# Display the plot\nplt.show()\n\n\n\n\nloc = np.array(locations)\nlevels_psu=np.arange(31,35,0.1)\nlevels_t=np.arange(2.5,10,0.2)\ndata_psu1=obs['Salinity'].sel(time=slice(months_string_begin, months_string_end)).sel(HV=[1,3,5,7,9,10,12]).mean('time')\ndata_psu2=obs['Salinity'].sel(time=slice(months_string_begin, months_string_end)).sel(HV=[2,3,4]).mean('time')\ndata_t=obs['Temperature'].sel(time=slice(months_string_begin, months_string_end)).sel(HV=[1,3,5,7,9,10,12]).mean('time')\n\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(6*2, 3), constrained_layout=True)\nax = axarr.flatten()\nc0=ax[0].contourf(loc[[1-1,3-1,5-1,7-1,9-1,10-1,12-1],1]-360,data_psu1.depth, data_psu1.transpose(),levels_psu)\n\n#ax[1].contourf(loc[[1-1,3-1,5-1,7-1,9-1,10-1,12-1],1]-360,data.depth, data_t.transpose(),levels_t)\n#ax[1].invert_yaxis()\nc1=ax[1].contourf(loc[[2-1,3-1,4-1],0],data_psu2.depth, data_psu2.transpose(),levels_psu)\n\nax[0].set_title('along fjord mean salinity profile (Observed)')\nax[0].set_xlabel('longitude')\nax[0].set_ylabel('depth')\nax[0].set_ylim(0,40)\nplt.colorbar(c0,ax=ax[0], orientation='vertical', label='psu',shrink=0.5)\nax[0].invert_yaxis()\n\nax[1].set_title('across fjord mean salinity profile (Observed)')\nax[1].set_xlabel('latitude')\nax[1].set_ylabel('depth')\nax[1].set_ylim(0,40)\nplt.colorbar(c1, ax=ax[1], orientation='vertical', label='psu',shrink=0.5)\nax[1].invert_yaxis()\n\n\n\nloc = np.array(locations)\nlevels_psu=np.arange(31,35,0.1)\nlevels_t=np.arange(2.5,10,0.2)\ndata_psu1=s_values_combined.isel(type=0).mean('month').sel(location=[1,3,5,7,9,10,12])\ndata_psu2=s_values_combined.isel(type=0).mean('month').sel(location=[2,3,4])\n\n\n#data_t=obs['Temperature'].sel(HV=[1,3,5,7,9,10,12]).mean('time')\n\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(6*2, 3), constrained_layout=True)\nax = axarr.flatten()\nc0=ax[0].contourf(loc[[1-1,3-1,5-1,7-1,9-1,10-1,12-1],1]-360,data_psu1.depth*(-1), data_psu1.transpose(),levels_psu)\n\n#ax[1].contourf(loc[[1-1,3-1,5-1,7-1,9-1,10-1,12-1],1]-360,data.depth, data_t.transpose(),levels_t)\n#ax[1].invert_yaxis()\nc1=ax[1].contourf(loc[[2-1,3-1,4-1],0],data_psu2.depth*(-1), data_psu2.transpose(),levels_psu)\n\nax[0].set_title('along fjord mean salinity profile (model)')\nax[0].set_xlabel('longitude')\nax[0].set_ylabel('depth')\nax[0].set_ylim(0,40)\nplt.colorbar(c0,ax=ax[0], orientation='vertical', label='psu',shrink=0.5)\nax[0].invert_yaxis()\n\nax[1].set_title('across fjord mean salinity profile (model)')\nax[1].set_xlabel('latitude')\nax[1].set_ylabel('depth')\nax[1].set_ylim(0,40)\nplt.colorbar(c1, ax=ax[1], orientation='vertical', label='psu',shrink=0.5)\nax[1].invert_yaxis()\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# --- CONFIG ---\nmonth_names = [\"May\", \"June\", \"July\", \"August\", \"September\"]\nn_months = 4   # May–Sep\npalette = plt.get_cmap(\"tab20\")\n\n# --- TAKE MEAN OVER ALL 12 STATIONS ---\nmodel_mean = s_values_combined.isel(type=0).mean(dim=\"location\")\nmodel_std  = s_values_combined.isel(type=1).mean(dim=\"location\")\n\n# --- OBSERVATIONS: MEAN + STD ACROSS STATIONS ---\nobs_monthly_mean = []\nobs_monthly_std = []\n\nfor m in range(n_months):\n    month_str = f\"2024-{m+5:02d}\"   # 05–09\n    obs_sel = obs[\"Salinity\"].sel(\n        time=slice('2024-0'+str(m+4)+'-01','2024-0'+str(m+4)+'-30')\n    )\n\n    # mean over stations, then mean over time\n    obs_mean_m = obs_sel.mean(dim=\"time\").mean(dim=\"HV\")\n    obs_std_m  = obs_sel.std(dim=\"time\").mean(dim=\"HV\")\n\n    obs_monthly_mean.append(obs_mean_m)\n    obs_monthly_std.append(obs_std_m)\n\n# --- SET UP FIGURE ---\nfig, axarr = plt.subplots(\n    nrows=3, ncols=2, figsize=(5, 7), constrained_layout=True\n)\nax = axarr.flatten()\n\nfor m in range(n_months):\n\n    # MODEL DATA FOR MONTH m\n    model_mean_m = model_mean.isel(month=m+1)\n    model_std_m  = model_std.isel(month=m+1)\n\n    # OBS DATA FOR MONTH m\n    obs_mean_m = obs_monthly_mean[m]\n    obs_std_m  = obs_monthly_std[m]\n\n    # --- PLOTTING ---\n    ax[m].plot(model_mean_m, s_values_combined.depth*(-1), color='black', label=\"Model Mean\")\n    ax[m].fill_betweenx(\n        s_values_combined.depth*(-1),\n        model_mean_m - model_std_m,\n        model_mean_m + model_std_m,\n        color=\"grey\", alpha=0.4, label=\"Model Std\"\n    )\n\n    ax[m].plot(obs_mean_m, obs.sel(HV=1).depth, color=palette(3), label=\"Obs Mean\")\n    ax[m].fill_betweenx(\n        obs.sel(HV=1).depth,\n        obs_mean_m - obs_std_m,\n        obs_mean_m + obs_std_m,\n        color=palette(3), alpha=0.3, label=\"Obs Std\"\n    )\n\n    # TITLE + LABELS\n    ax[m].set_title(f\"Average Salinity Profile – {month_names[m]}\")\n    ax[m].set_xlabel(\"psu\")\n    ax[m].set_ylabel(\"Depth (m)\")\n    ax[m].set_ylim(0,40)\n    # invert depth\n    ax[m].invert_yaxis()\n\n    # legend on first panel\n    if m == 0:\n        ax[m].legend()\n\n# Remove empty subplot (6th)\nfig.delaxes(ax[5])\n\nplt.show()\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# --- CONFIG ---\nmonth_names = [\"May\", \"June\", \"July\", \"August\", \"September\"]\nn_months = 4# May–Sep\npalette = plt.get_cmap(\"tab20\")\n\n# --- TAKE MEAN OVER ALL 12 STATIONS ---\nmodel_mean = t_values_combined.isel(type=0).mean(dim=\"location\")\nmodel_std  = t_values_combined.isel(type=1).mean(dim=\"location\")\n\n# --- OBSERVATIONS: MEAN + STD ACROSS STATIONS ---\nobs_monthly_mean = []\nobs_monthly_std = []\n\nfor m in range(n_months):\n    month_str = f\"2024-{m+4:02d}\"   # 05–09\n    obs_sel = obs[\"Temperature\"].sel(\n        time=slice('2024-0'+str(m+5)+'-01','2024-0'+str(m+5)+'-30')\n    )\n\n    # mean over stations, then mean over time\n    obs_mean_m = obs_sel.mean(dim=\"time\").mean(dim=\"HV\")\n    obs_std_m  = obs_sel.std(dim=\"time\").mean(dim=\"HV\")\n\n    obs_monthly_mean.append(obs_mean_m)\n    obs_monthly_std.append(obs_std_m)\n\n# --- SET UP FIGURE ---\nfig, axarr = plt.subplots(\n    nrows=3, ncols=2, figsize=(5, 7), constrained_layout=True\n)\nax = axarr.flatten()\n\nfor m in range(n_months):\n\n    # MODEL DATA FOR MONTH m\n    model_mean_m = model_mean.isel(month=m+1)\n    model_std_m  = model_std.isel(month=m+1)\n\n    # OBS DATA FOR MONTH m\n    obs_mean_m = obs_monthly_mean[m]\n    obs_std_m  = obs_monthly_std[m]\n\n    # --- PLOTTING ---\n    ax[m].plot(model_mean_m, s_values_combined.depth*(-1), color='black', label=\"Model Mean\")\n    ax[m].fill_betweenx(\n        s_values_combined.depth*(-1),\n        model_mean_m - model_std_m,\n        model_mean_m + model_std_m,\n        color=\"grey\", alpha=0.4, label=\"Model Std\"\n    )\n\n    ax[m].plot(obs_mean_m, obs.sel(HV=1).depth, color=palette(3), label=\"Obs Mean\")\n    ax[m].fill_betweenx(\n        obs.sel(HV=1).depth,\n        obs_mean_m - obs_std_m,\n        obs_mean_m + obs_std_m,\n        color=palette(3), alpha=0.3, label=\"Obs Std\"\n    )\n\n    # TITLE + LABELS\n    ax[m].set_title(f\"Average Temperature Profile – {month_names[m]}\")\n    ax[m].set_xlabel(\"degrees C\")\n    ax[m].set_ylabel(\"Depth (m)\")\n    ax[m].set_ylim(0,40)\n    # invert depth\n    ax[m].invert_yaxis()\n\n    # legend on first panel\n    if m == 0:\n        ax[m].legend()\n\n# Remove empty subplot (6th)\nfig.delaxes(ax[5])\n\nplt.show()\n\n\n\n\nimport xarray as xr\nimport numpy as np\n\n# Load ROMS output using your pattern\nroms_output = ROMSOutput(\n    grid=grid,\n    path=[\n        model_data_path,\n    ],\n    use_dask=True,\n)\n\nds = roms_output.regrid(var_names=[\"temp\", \"salt\"],depth_levels=[5])\n\n\n\n\nt=ds['temp'].thin({'time': 24}).load()\ns=ds['salt'].thin({'time': 24}).load()\n\n\n\n# Define file paths and station names\nstations = [\"HVIN_1\", \"HVNA_1\", \"HVNV_1\", \"HVSA_1\", \"HVSV_1\"]\nfile_paths = {name: f\"/global/cfs/cdirs/m4632/uheede/Hafro_obsdata/{name}new.nc\" for name in stations}\n# Define file paths and station names\nstations = [\"HVIN_1\", \"HVNA_1\", \"HVNV_1\", \"HVSA_1\", \"HVSV_1\"]\nfile_paths = {name: f\"/home/x-uheede/R/HAFRO/{name}_TS.nc\" for name in stations}\n\n# Dictionary to store datasets\ndatasets = {}\n\nfor name, path in file_paths.items():\n    ds = xr.open_dataset(path)\n    \n    # Store dataset with adjusted longitude\n    datasets[name] = ds.assign_coords(lon=ds['lon'].load() + 360)\n\nsubtract = 739674 - 9189  # Computed constant\nreference_date = pd.to_datetime(\"2000-01-01\")  # Reference date\n\n# Apply transformation to all datasets\nfor name, ds in datasets.items():\n    datetime_series = reference_date + pd.to_timedelta((ds['time'].values - subtract), unit='D')\n    datasets[name] = ds.assign_coords(time_dim=datetime_series)  # Update the time coordinate\n\nds_list = []\n\nfor name, ds in datasets.items():\n    # Add station as a new dimension\n    ds_expanded = ds.expand_dims(station=[name])\n    ds_list.append(ds_expanded)\n    \ncombined = xr.concat(ds_list, dim=\"station\")\nmean_ts = combined.mean(dim=\"station\", skipna=True)\n\n\n\nplt.plot(mean_ts['temperature'])\n\n\n\n# Assuming locations is a list of lat/lon pairs\nt_values = []\ns_values = []\n# Loop over the first 10 locations and store each selection in t_values\nfor i in range(12):\n    lat, lon = locations[i]\n    \n    # Select the 't' values at the nearest lat/lon\n    t_selected = t.sel(lat=lat, method='nearest').sel(lon=lon, method='nearest')\n    s_selected = s.sel(lat=lat, method='nearest').sel(lon=lon, method='nearest')\n    \n    # Store the result in the listx\n    t_values.append(t_selected)\n    s_values.append(s_selected)\n\n# Combine the selections into an xarray Dataset or DataArray\nt_values_combined = xr.concat(t_values, dim='location')\ns_values_combined = xr.concat(s_values, dim='location')\n\n# Assign a location coordinate for clarity (optional)\nt_values_combined = t_values_combined.assign_coords(location=('location', range(1, 13)))\ns_values_combined = s_values_combined.assign_coords(location=('location', range(1, 13)))\n#t_values_combined['depth']=t_values_combined.depth*(-1)\n#s_values_combined['depth']=s_values_combined.depth*(-1)\n# Now you have t_values as an xarray object (Dataset or DataArray)\n#print(t_values_combined)\n\n\n\n\nimport matplotlib.pyplot as plt\n\n# Set up the subplots\nfig, axarr = plt.subplots(nrows=2, ncols=4, figsize=(12, 4*1.2), constrained_layout=True)\nax = axarr.flatten()  # Flatten to make indexing easier\npalette = plt.get_cmap('tab20')\n\n# Plot observed salinity for May 2024\nax[1].plot(mean_ts['salinity'].time_dim.sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           mean_ts['salinity'].sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           label='May', color=palette(2))\n\nax[0].plot(s_values_combined.time, s_values_combined.sel(location=[1,3,4,5,6,7,8,9,10,12]).mean('location'),\n           label='May', color=palette(1))\n\n# Plot observed salinity for May 2024\nax[3].plot(mean_ts['temperature'].time_dim.sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           mean_ts['temperature'].sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           label='May', color=palette(2))\nax[3].set_ylim(2,12.5)\n\nax[2].plot(s_values_combined.time, t_values_combined.sel(location=[1,3,4,5,6,7,8,9,10,12]).mean('location'),\n           label='May', color=palette(1))\nax[2].set_ylim(2,12.5)\nax[5].plot(datasets['HVSV_1'].time_dim.sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           datasets['HVSV_1']['salinity'].sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           label='May', color=palette(2))\n\nax[4].plot(s_values_combined.time, s_values_combined.sel(location=[1]).mean('location'),\n           label='May', color=palette(1))\n\n# Plot observed salinity for May 2024\nax[7].plot(datasets['HVSV_1'].time_dim.sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           datasets['HVSV_1']['temperature'].sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           label='May', color=palette(2))\nax[7].set_ylim(2,12.5)\nax[6].plot(s_values_combined.time, t_values_combined.sel(location=[1]).mean('location'),\n           label='May', color=palette(1))\nax[6].set_ylim(2,12.5)\n# Rotate x-axis labels for all subplots\nfor a in ax:\n    a.tick_params(axis='x', rotation=45)  # Adjust rotation angle as needed\n    \n    \nax[0].set_title('salinity for all stations,\\n 5 m depth MODEL')\nax[1].set_title('salinity for all stations,\\n 5 m depth OBS')\nax[2].set_title('temperature for all stations,\\n 5 m depth MODEL')\nax[3].set_title('temperate for all stations,\\n 5 m depth OBS')\nax[4].set_title('salinity for station 1,\\n 5 m depth MODEL')\nax[5].set_title('salinity for station 1,\\n 5 m depth OBS')\nax[6].set_title('temperature for station 1,\\n 5 m depth MODEL')\nax[7].set_title('temperate for station 1,\\n 5 m depth OBS')\nplt.show()\n\n\n\n\n\nimport matplotlib.pyplot as plt\n\n# Set up the subplots\nfig, axarr = plt.subplots(nrows=2, ncols=4, figsize=(12, 4*1.2), constrained_layout=True)\nax = axarr.flatten()  # Flatten to make indexing easier\npalette = plt.get_cmap('tab20')\n\n# Plot observed salinity for May 2024\nax[1].plot(obs.time.sel(time=slice('04-01-2024', '09-01-2024')),\n           obs['Salinity'].sel(depth=slice(2,5)).mean('depth').sel(HV=[1,3,4,5,6,7,8,9,10,12]).sel(time=slice('04-01-2024', '09-01-2024')).mean('HV'),\n           label='May', color=palette(2))\n\nax[0].plot(s_values_combined.time, s_values_combined.sel(location=[1,3,4,5,6,7,8,9,10,12]).mean('location'),\n           label='May', color=palette(1))\n\n# Plot observed salinity for May 2024\nax[3].plot(obs.time.sel(time=slice('04-01-2024', '09-01-2024')),\n           obs['Temperature'].sel(depth=slice(2,5)).mean('depth').sel(HV=[1,3,4,5,6,7,8,9,10,12]).sel(time=slice('04-01-2024', '09-01-2024')).mean('HV'),\n           label='May', color=palette(2))\nax[3].set_ylim(4.5,12.5)\n\nax[2].plot(s_values_combined.time, t_values_combined.sel(location=[1,3,4,5,6,7,8,9,10,12]).mean('location'),\n           label='May', color=palette(1))\nax[2].set_ylim(4.5,12.5)\nax[5].plot(obs.time.sel(time=slice('04-01-2024', '09-01-2024')),\n           obs['Salinity'].sel(depth=slice(2,5)).mean('depth').sel(HV=[1]).sel(time=slice('04-01-2024', '09-01-2024')).mean('HV'),\n           label='May', color=palette(2))\n\nax[4].plot(s_values_combined.time, s_values_combined.sel(location=[1]).mean('location'),\n           label='May', color=palette(1))\n\n# Plot observed salinity for May 2024\nax[7].plot(obs.time.sel(time=slice('04-01-2024', '09-01-2024')),\n           obs['Temperature'].sel(depth=slice(2,5)).mean('depth').sel(HV=[1]).sel(time=slice('04-01-2024', '09-01-2024')).mean('HV'),\n           label='May', color=palette(2))\nax[7].set_ylim(4.5,12.5)\nax[6].plot(s_values_combined.time, t_values_combined.sel(location=[1]).mean('location'),\n           label='May', color=palette(1))\nax[6].set_ylim(4.5,12.5)\n# Rotate x-axis labels for all subplots\nfor a in ax:\n    a.tick_params(axis='x', rotation=45)  # Adjust rotation angle as needed\n    \n    \nax[0].set_title('salinity for all stations,\\n 5 m depth MODEL')\nax[1].set_title('salinity for all stations,\\n 5 m depth OBS')\nax[2].set_title('temperature for all stations,\\n 5 m depth MODEL')\nax[3].set_title('temperate for all stations,\\n 5 m depth OBS')\nax[4].set_title('salinity for station 1,\\n 5 m depth MODEL')\nax[5].set_title('salinity for station 1,\\n 5 m depth OBS')\nax[6].set_title('temperature for station 1,\\n 5 m depth MODEL')\nax[7].set_title('temperate for station 1,\\n 5 m depth OBS')\nplt.show()\n\n\n\n\n\ns_values_combined\n\n","type":"content","url":"/ctd-comparison-200-wico#setting-parameters-and-paths","position":3},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/model-solution","position":0},{"hierarchy":{"lvl1":""},"content":"import subprocess\nimport os\nimport pandas as pd\nimport netCDF4\nimport numpy as np\nimport glob\nimport time\nimport matplotlib.pyplot as plt\nimport copy\nimport xarray as xr\nfrom datetime import datetime, timedelta \nimport dask\nfrom scipy.interpolate import griddata\n#from ocean_c_lab_tools import *\n#from celluloid import Camera \n#import PyCO2SYS as csys\nimport seawater as sw\nfrom roms_regrid import *\n\n\n\nHAFRO_path='/home/x-uheede/R/HAFRO/Hafro_cruises.xls'\nmodel_grid_path=\"/home/x-uheede/S/Iceland2_MARBL_2024_60m/P_INPUT/Iceland2_grid_MAT1.nc\"\n# Grid parameters, only modify these if grid is made in MATLAB\nvert_levels=60\ntheta_s_model=5\ntheta_b_model=2\nhc_model=300\nmodel_data_path=\"/anvil/scratch/x-uheede/Iceland2_NOMARBL_2024_RHALF/Iceland2_MARBL_2024_his.20240[4][0-14]???????.nc\"\nmonths_analysis=[4] # enter the months you want to analyze for the model\n# enter the dates you want to analyze for the observations\ntarget_depth_levels=[10] # Specify depth levels of interest\nthinner=1 # specify the temporal frequency of data being read (i.e. no need to read in hourly data)\n\n\n\n\nfrom roms_tools import Grid, ROMSOutput\ngrid = Grid.from_file(\n    model_grid_path\n)\n\n\n\n\n#Only run this cell if grid is made in MATLAB\ngrid.update_vertical_coordinate(N=vert_levels, theta_s=theta_s_model, theta_b=theta_b_model, hc=hc_model, verbose=False)\n\n\n\nimport xarray as xr\nimport numpy as np\ntarget_depth_levels=[1,2,3,4,5,7,9,10,12,14,15,16,18,20,26,30,36,40,50,80] # Specify depth levels of interest\n# Load ROMS output using your pattern\nroms_output = ROMSOutput(\n    grid=grid,\n    path=[\n        model_data_path,\n    ],\n    use_dask=True,\n)\n\nds = roms_output.regrid(var_names=[\"u\", \"v\"],depth_levels=target_depth_levels)\n\n\n\nu_rg=ds['u'].mean('time').load()\nv_rg=ds['v'].mean('time').load()\n\n\n\nimport cartopy.crs as ccrs\nimport cartopy.mpl.ticker as cticker\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# -------------------------------------------------------\n#  Select depths and prepare surface/20 m vector plotting\n# -------------------------------------------------------\nsurface_depth = 0\ndepth20 = 20\n\nu_surf = u_rg.sel(depth=surface_depth, method=\"nearest\")\nv_surf = v_rg.sel(depth=surface_depth, method=\"nearest\")\n\nu_20 = u_rg.sel(depth=depth20, method=\"nearest\")\nv_20 = v_rg.sel(depth=depth20, method=\"nearest\")\n\nlon = u_rg.lon\nlat = u_rg.lat\n\n# -------------------------------------------------------\n# 1) Compute full-resolution land mask (before thinning)\n# -------------------------------------------------------\nmask_surf_full = np.isnan(u_surf) | np.isnan(v_surf)\nmask_200_full  = np.isnan(u_20)   | np.isnan(v_20)\n\n# -------------------------------------------------------\n# 2) Thin vectors\n# -------------------------------------------------------\nstep = 3\nlon_thin = lon[::step]\nlat_thin = lat[::step]\n\nu_surf_thin = u_surf[::step, ::step]\nv_surf_thin = v_surf[::step, ::step]\n\nu_200_thin = u_20[::step, ::step]\nv_200_thin = v_20[::step, ::step]\n\n# -------------------------------------------------------\n#  Data for vertical sections\n# -------------------------------------------------------\nlonA = 360 - 21.85\nlonB = 360 - 21.55\n\nuA = u_rg.sel(lon=lonA, method=\"nearest\")\nif \"time\" in uA.dims:\n    uA = uA.isel(time=0)\nuA = uA.transpose(\"depth\", \"lat\")\n\nuB = u_rg.sel(lon=lonB, method=\"nearest\")\nif \"time\" in uB.dims:\n    uB = uB.isel(time=0)\nuB = uB.transpose(\"depth\", \"lat\")\n\ndepth_vals = uA.depth.values\nlat_vals_A = uA.lat.values\nlat_vals_B = uB.lat.values\n\nextent_hval = [-22.2543190362897, -21.3469394652069, \n               64.25114671, 64.45802068]\n\n# -------------------------------------------------------\n# Plotting using GridSpec\n# -------------------------------------------------------\nfig = plt.figure(figsize=(14, 10))\ngs = fig.add_gridspec(2, 2, height_ratios=[1, 1])\n\n# ===========================\n# Panel 1 — Surface vectors\n# ===========================\nax1 = fig.add_subplot(gs[0, 0], projection=ccrs.Mercator())\nax1.set_extent(extent_hval)\n\n# Mask\nax1.contourf(\n    lon, lat, mask_surf_full,\n    levels=[0.5, 1.5],\n    colors=[\"lightgray\"],\n    transform=ccrs.PlateCarree(),\n    zorder=1\n)\n\n# Vectors (store handle)\nQ1 = ax1.quiver(\n    lon_thin.values,\n    lat_thin.values,\n    u_surf_thin.values,\n    v_surf_thin.values,\n    transform=ccrs.PlateCarree(),\n    scale=3,\n    zorder=2\n)\n\n# --- NEW: reference arrow using quiverkey ---\nax1.quiverkey(\n    Q1, \n    X=0.12, Y=0.92,  # position within axes (0–1)\n    U=0.1,           # reference speed in m/s\n    label=\"0.1 m/s\",\n    labelpos=\"E\",\n    coordinates='axes'\n)\n\n# --- vertical slice lines ---\nax1.plot([lonA-360, lonA-360], [lat.min(), lat.max()], \n         color='black', alpha=0.6, linewidth=2, transform=ccrs.PlateCarree())\nax1.plot([lonB-360, lonB-360], [lat.min(), lat.max()], \n         color='black', alpha=0.6, linewidth=2, transform=ccrs.PlateCarree())\n\nax1.set_title(\"Surface velocity vectors (thinned)\")\n...\n\n\n# ===========================\n# Panel 2 — 20 m vectors\n# ===========================\nax2 = fig.add_subplot(gs[0, 1], projection=ccrs.Mercator())\nax2.set_extent(extent_hval)\n\n# Mask\nax2.contourf(\n    lon, lat, mask_200_full,\n    levels=[0.5, 1.5],\n    colors=[\"lightgray\"],\n    transform=ccrs.PlateCarree(),\n    zorder=1\n)\n\n# Vectors (store handle)\nQ2 = ax2.quiver(\n    lon_thin.values, lat_thin.values,\n    u_200_thin.values, v_200_thin.values,\n    color=\"red\",\n    transform=ccrs.PlateCarree(),\n    zorder=2, scale=3\n)\n\n# --- NEW: reference arrow ---\nax2.quiverkey(\n    Q2, \n    X=0.12, Y=0.92,\n    U=0.1, \n    label=\"0.1 m/s\",\n    labelpos=\"E\",\n    coordinates='axes'\n)\n\nax2.set_title(\"20 m velocity vectors (thinned)\")\n...\n\n\n# ===========================\n# Panel 3 — Vertical section at A\n# ===========================\nax3 = fig.add_subplot(gs[1, 0])\ncf = ax3.contourf(lat_vals_A, depth_vals, uA, levels=30,cmap='RdBu')\nax3.set_title(f\"Zonal velocity u(z, lat) at {lonA-360:.2f}°E\")\nax3.set_xlabel(\"Latitude\")\nax3.set_ylabel(\"Depth (m)\")\nfig.colorbar(cf, ax=ax3, label=\"u (m/s)\")\n\nax3.set_ylim(0, 40)\nax3.invert_yaxis()\nax3.set_xlim(64.26, 64.32)\n\n# ===========================\n# Panel 4 — Vertical section at B\n# ===========================\nax4 = fig.add_subplot(gs[1, 1])\ncf = ax4.contourf(lat_vals_B, depth_vals, uB, levels=30, cmap='RdBu')\nax4.set_title(f\"Zonal velocity u(z, lat) at {lonB-360:.2f}°E\")\nax4.set_xlabel(\"Latitude\")\nax4.set_ylabel(\"Depth (m)\")\nfig.colorbar(cf, ax=ax4, label=\"u (m/s)\")\n\nax4.set_ylim(0, 40)\nax4.invert_yaxis()\nax4.set_xlim(64.375, 64.39)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n# ===========================\n# Panel 1 — Surface vectors\n# ===========================\nax1 = fig.add_subplot(gs[0, 0], projection=ccrs.Mercator())\nax1.set_extent(extent_hval)\n\n# Mask\nax1.contourf(\n    lon, lat, mask_surf_full,\n    levels=[0.5, 1.5],\n    colors=[\"lightgray\"],\n    transform=ccrs.PlateCarree(),\n    zorder=1\n)\n\n# Vectors (store handle)\nQ1 = ax1.quiver(\n    lon_thin.values,\n    lat_thin.values,\n    u_surf_thin.values,\n    v_surf_thin.values,\n    transform=ccrs.PlateCarree(),\n    scale=3,\n    zorder=2\n)\n\n# --- NEW: reference arrow using quiverkey ---\nax1.quiverkey(\n    Q1, \n    X=0.12, Y=0.92,  # position within axes (0–1)\n    U=0.1,           # reference speed in m/s\n    label=\"0.1 m/s\",\n    labelpos=\"E\",\n    coordinates='axes'\n)\n\n# --- vertical slice lines ---\nax1.plot([lonA-360, lonA-360], [lat.min(), lat.max()], \n         color='black', alpha=0.6, linewidth=2, transform=ccrs.PlateCarree())\nax1.plot([lonB-360, lonB-360], [lat.min(), lat.max()], \n         color='black', alpha=0.6, linewidth=2, transform=ccrs.PlateCarree())\n\nax1.set_title(\"Surface velocity vectors (thinned)\")\n...\n\n\n# ===========================\n# Panel 2 — 20 m vectors\n# ===========================\nax2 = fig.add_subplot(gs[0, 1], projection=ccrs.Mercator())\nax2.set_extent(extent_hval)\n\n# Mask\nax2.contourf(\n    lon, lat, mask_200_full,\n    levels=[0.5, 1.5],\n    colors=[\"lightgray\"],\n    transform=ccrs.PlateCarree(),\n    zorder=1\n)\n\n# Vectors (store handle)\nQ2 = ax2.quiver(\n    lon_thin.values, lat_thin.values,\n    u_200_thin.values, v_200_thin.values,\n    color=\"red\",\n    transform=ccrs.PlateCarree(),\n    zorder=2, scale=3\n)\n\n# --- NEW: reference arrow ---\nax2.quiverkey(\n    Q2, \n    X=0.12, Y=0.92,\n    U=0.1, \n    label=\"0.1 m/s\",\n    labelpos=\"E\",\n    coordinates='axes'\n)\n\nax2.set_title(\"20 m velocity vectors (thinned)\")\n...\n\n\n","type":"content","url":"/model-solution","position":1},{"hierarchy":{"lvl1":"ROMS-TOOLS setup for Iceland0_MARBL_2024"},"type":"lvl1","url":"/setup-iceland0-marbl-2024","position":0},{"hierarchy":{"lvl1":"ROMS-TOOLS setup for Iceland0_MARBL_2024"},"content":"First step is to set up the outer grid using ROMS-TOOLS and save the grid file.\n\nimport xarray as xr\nfrom roms_tools import Grid\n\n\n\nproject='/anvil/projects/x-ees250129/x-uheede/INPUT_files/Iceland0_MARBL_2024/'\ndatasets='/anvil/projects/x-ees250129/Datasets_subset/'\nmodel_name='Iceland0'\nchild_name='Iceland1'\ngrid_path='/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_s2r_phys+bgc/1.Make_grid/Iceland0_grid_MAT.nc'\n\n\n\n#%%time\n\n#grid = Grid(\n#    nx=512,  # number of grid points in x-direction\n#    ny=512,  # number of grid points in y-direction\n#    size_x=1280,  # domain size in x-direction (in km)\n#    size_y=1280,  # domain size in y-direction (in km)\n#    center_lon=-25,  # longitude of the center of the domain\n#    center_lat=63,  # latitude of the center of the domain\n#    rot=-20,  # rotation of the grid (in degrees)\n#    topography_source={\n#        \"name\": \"SRTM15\",\n#        \"path\":datasets+\"SRTM15/SRTM15_V2.6.nc\"},\n#    N=100,  # number of vertical layers\n#    verbose=True,\n#)\n\n\n\ngrid = Grid.from_file(grid_path)\n\n\n\n#mat_grid=xr.open_dataset('/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_s2r_phys+bgc/1.Make_grid/Iceland0_grid_MAT.nc')\n\n\n\n#mat_grid['h'].plot()\n\n\n\ngrid.plot()\n\n\n\n\nfilepath = project+model_name+'_grid.nc'\n\n\n\ngrid.save(filepath)\n\n\n\n\n\ntpxo_path = datasets+\"TPXO/TPXO10.v2/\"\ntpxo_dict = {\n    \"grid\": tpxo_path + \"grid_tpxo10v2.nc\",\n    \"h\": tpxo_path + \"h_tpxo10.v2.nc\",\n    \"u\": tpxo_path + \"u_tpxo10.v2.nc\",\n}\n\n\n\nNext, we set up tidal forcing:\n\nfrom roms_tools import TidalForcing\n\n\n\nfrom datetime import datetime\n\n\n\nmodel_reference_date = datetime(2000, 1, 1)\n\n\n\n\ntidal_forcing = TidalForcing(\n    grid=grid,\n    source={\"name\": \"TPXO\", \"path\": tpxo_dict},\n    ntides=15,  # Number of constituents to consider <= 15. Default is 10.\n    model_reference_date=model_reference_date,  # Model reference date. Default is January 1, 2000.\n    use_dask=True\n)\n\n\n\nfilepath = project+model_name+\"_tides.nc\"\n\n\n\n%time tidal_forcing.save(filepath)\n\n\n\n\n\n\n\nFor the surface forcing, we use ERA5 plus the unified BGC dataset\n\nfrom roms_tools import Grid, SurfaceForcing\n\n\n\nstart_time = datetime(2024, 1, 1)\nend_time = datetime(2024, 6, 1)\n\n\n\nsurface_forcing_kwargs = {\n    \"grid\": grid,\n    \"start_time\": start_time,\n    \"end_time\": end_time,\n    \"type\": \"physics\",\n    \"model_reference_date\": datetime(2000, 1, 1), # this is the default\n}\n\n\n\n%%time\n\nsurface_forcing = SurfaceForcing(\n    **surface_forcing_kwargs,\n    source={\"name\": \"ERA5\"},\n    use_dask=True,\n)\n\n\n\n\n\nsurface_forcing.plot(\"uwnd\", time=0)\n\n\n\n\n\n#cesm_bgc_path = \"/global/cfs/projectdirs/m4746/Datasets/CESM_REGRIDDED/CESM-surface_lowres_regridded.nc\"\nunified_bgc_path = datasets+\"UNIFIED/BGCdataset.nc\"\n\n\n\n%%time\n\nunified_bgc_surface_forcing = SurfaceForcing(\n    grid=grid,\n    start_time=start_time,\n    end_time=end_time,\n    source={\"name\": \"UNIFIED\", \"path\": unified_bgc_path, \"climatology\": True},\n    type=\"bgc\",\n    use_dask=True,\n)\n\n\n\n\n\nfilepath = project+model_name+\"_surface_forcing2024.nc\"\n\n\n\n%time surface_forcing.save(filepath)\n\n\n\n\n\n\n\nfilepath = project+model_name+\"_bgc_surface_forcing.nc\"\n\n\n\n%time unified_bgc_surface_forcing.save(filepath)\n\n\n\n\n\n\n\nNext we generate the initial file\n\nfrom roms_tools import Grid, InitialConditions\n\n\n\nfrom datetime import datetime\n\n\n\nini_time = datetime(2024, 1, 5)\n\n\n\npath = datasets+\"GLORYS/ICELAND_DOMAIN/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-05_no_depth_zos.nc\"\n\n\n\n%%time\n\ninitial_conditions_with_unified_bgc = InitialConditions(\n    grid=grid,\n    ini_time=ini_time,\n    source={\"name\": \"GLORYS\", \"path\": path},\n    bgc_source={\n        \"name\": \"UNIFIED\",\n        \"path\": unified_bgc_path,\n        \"climatology\": True,\n    },  # bgc_source is optional\n    model_reference_date=datetime(2000, 1, 1), # this is the default\n    use_dask=True,\n)\n\n\n\n\n\nfilepath = project+model_name+\"_initial_conditions.nc\"\n\n\n\n%time initial_conditions_with_unified_bgc.save(filepath)\n\n\n\n\n\n\n\nglorys_path = [\n    datasets+\"/GLORYS/ICELAND_DOMAIN/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-*_no_depth_zos.nc\"]\n\n\n\n#glorys_path = [\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-04_no_depth_zos.nc\",  # include data from day before start time\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-05_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-06_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-07_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-08_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-09_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-10_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-11_no_depth_zos.nc\",  # include data from day after end time\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-12_no_depth_zos.nc\", \n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-13_no_depth_zos.nc\", \n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-14_no_depth_zos.nc\",  # include data from day before start time\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-15_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-16_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-17_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-18_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-19_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-20_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-21_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-22_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-23_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-24_no_depth_zos.nc\",  # include data from day before start time\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-25_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-26_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-27_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-28_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-29_no_depth_zos.nc\",\n#    \"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-30_no_depth_zos.nc\",\n#    #\"/global/cfs/cdirs/m4632/uheede/GLORYS/2024/cmems_mod_glo_phy_myint_0.083deg_P1D-m_multi-vars_52.50W-2.67E_44.33N-74.42N_1.54-3992.48m_2024-01-31_no_depth_zos.nc\"\n#]\n\n\n\nfrom roms_tools import Grid, BoundaryForcing\n\n\n\nstart_time = datetime(2024, 1, 1)\nend_time = datetime(2024, 6, 30)\n\n\n\n%%time\n\nboundary_forcing = BoundaryForcing(\n    grid=grid,\n    start_time=start_time,\n    end_time=end_time,\n    boundaries={\n        \"south\": True,\n        \"east\": True,\n        \"north\": True,  \n        \"west\": True,\n    },\n    source={\"name\": \"GLORYS\", \"path\": glorys_path},\n    type=\"physics\",  # \"physics\" or \"bgc\"; default is \"physics\"\n    model_reference_date=datetime(2000, 1, 1), # this is the default\n    use_dask=True,\n)\n\n\n\n\n\n%%time\n\nunified_bgc_boundary_forcing = BoundaryForcing(\n    grid=grid,\n    start_time=start_time,\n    end_time=end_time,\n    boundaries={\n        \"south\": True,\n        \"east\": True,\n        \"north\": True,  \n        \"west\": True,\n    },\n    source={\"name\": \"UNIFIED\", \"path\": unified_bgc_path, \"climatology\": True},\n    type=\"bgc\",\n    use_dask=True,\n)\n\n\n\n\n\nfilepath = project+model_name+\"_bgc_boundary_forcing_2024.nc\"\n%time unified_bgc_boundary_forcing.save(filepath)\n\n\n\n\n\n\n\n\nfilepath = project+model_name+\"_boundary_forcing_2024.nc\"\n%time boundary_forcing.save(filepath, group=True)\n\n\n\n\n\n\n\n\n\n\n\nfrom roms_tools import Grid, ChildGrid\n\n\n\nparent_grid = grid\n\n\n\nchild_grid_parameters = {\n    \"nx\": 512,\n    \"ny\": 512,\n    \"size_x\": 384,\n    \"size_y\": 384,\n    \"center_lon\": -24,\n    \"center_lat\": 64.9,\n    \"rot\": 0,\n    \"topography_source\": {\n        \"name\": \"SRTM15\",\n        \"path\": datasets+\"SRTM15/SRTM15_V2.6.nc\"},\n    \"N\":60  # number of vertical layers\n}\n\n\n\nchild_grid = ChildGrid(\n    **child_grid_parameters,\n    parent_grid=parent_grid,\n    boundaries={\n        \"south\": True,\n        \"east\": True,\n        \"north\": True,\n        \"west\": True,\n    },  # this is the default\n    metadata={\"prefix\": \"child\", \"period\": 900.0}  # this is the default\n)\n\n\n\nchild_grid.plot_nesting(with_dim_names=True)\n\n\n\nfilepath = project+child_name+\"_grid.nc\"\nchild_grid.save(filepath=filepath)\n\n\n\n\n\nfilepath_nesting = project+child_name+\"_edata.nc\"\n\n\n\nchild_grid.save_nesting(filepath=filepath_nesting)\n\n\n\n\n\nfrom roms_tools import partition_netcdf\n\n\n\n%time partition_netcdf(project+model_name+'_grid.nc', np_eta=16, np_xi=16, output_dir='/home/x-uheede/S/Iceland0_MARBL_2024/P_INPUT')\n\n\n\n\n\n%time partition_netcdf(project+model_name+'_tides.nc', np_eta=16, np_xi=16, output_dir='/home/x-uheede/S/Iceland0_MARBL_2024/P_INPUT')\n\n\n\n","type":"content","url":"/setup-iceland0-marbl-2024","position":1},{"hierarchy":{"lvl1":"ROMS-TOOLS setup for Iceland1_MARBL_2024"},"type":"lvl1","url":"/setup-iceland1-marbl-2024-copy1","position":0},{"hierarchy":{"lvl1":"ROMS-TOOLS setup for Iceland1_MARBL_2024"},"content":"First step is to set up the outer grid using ROMS-TOOLS and save the grid file.\n\nfrom roms_tools import Grid\n\n\n\nproject='/anvil/projects/x-ees250129/x-uheede/INPUT_files/Iceland1_MARBL_2024/'\ndatasets='/anvil/projects/x-ees250129/Datasets_subset/'\nmodel_name='Iceland1'\nchild_name='Iceland2'\ngrid_path='/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_r2r_phys+bgc/1.Make_grid/Iceland1_grid_MAT1.nc'\n\n\n\n#%%time\n\n#grid = Grid(\n#    nx=512,\n#    ny=512,\n#    size_x=384,\n#    size_y=384,\n#    center_lon=-24,\n#    center_lat=64.9,\n#    rot=0,\n#    topography_source={\n#        \"name\": \"SRTM15\",\n#        \"path\": datasets+\"SRTM15/SRTM15_V2.6.nc\"},\n#    N=60  # number of vertical layers\n#)\n\n\n\n#%%time\n\n#grid = Grid(\n#    nx=512,\n#    ny=384,\n#    size_x=384,\n#    size_y=288,\n#    center_lon=-22.6,\n#    center_lat=63.55,\n#    rot=0,\n#    topography_source={\n#        \"name\": \"SRTM15\",\n#        \"path\": datasets+\"SRTM15/SRTM15_V2.6.nc\"},\n#    N=60  # number of vertical layers\n#)\n\n\n\ngrid = Grid.from_file(grid_path)\n\n\n\ngrid.update_vertical_coordinate(N=60, theta_s=5.0, theta_b=2.0, hc=300.0, verbose=False)\n\n\n\ngrid.plot()\n\n\n\nfilepath = project+model_name+'_grid.nc'\nyaml_filepath=project+model_name+'_grid_60.yaml'\n\n\n\nyaml_filepath\n\n\n\ngrid.save(filepath)\n\n\n\n\n\ngrid.to_yaml(yaml_filepath)\n\n\n\ntpxo_path = datasets+\"TPXO/TPXO10.v2/\"\ntpxo_dict = {\n    \"grid\": tpxo_path + \"grid_tpxo10v2.nc\",\n    \"h\": tpxo_path + \"h_tpxo10.v2.nc\",\n    \"u\": tpxo_path + \"u_tpxo10.v2.nc\",\n}\n\n\n\nNext, we set up tidal forcing:\n\nfrom roms_tools import TidalForcing\n\n\n\nfrom datetime import datetime\n\n\n\nmodel_reference_date = datetime(2000, 1, 1)\n\n\n\n\ntidal_forcing = TidalForcing(\n    grid=grid,\n    source={\"name\": \"TPXO\", \"path\": tpxo_dict},\n    ntides=15,  # Number of constituents to consider <= 15. Default is 10.\n    model_reference_date=model_reference_date,  # Model reference date. Default is January 1, 2000.\n    use_dask=True\n)\n\n\n\nfilepath = project+model_name+\"_tides.nc\"\n\n\n\n%time tidal_forcing.save(filepath)\n\n\n\n\n\n\n\nFor the surface forcing, we use ERA5 plus the unified BGC dataset\n\nfrom roms_tools import Grid, SurfaceForcing\n\n\n\nstart_time = datetime(2023, 12, 1)\nend_time = datetime(2024, 6, 30)\n\n\n\nstart_time1 = datetime(2024, 6, 1)\nend_time1 = datetime(2024, 12, 1)\n\n\n\nsurface_forcing_kwargs = {\n    \"grid\": grid,\n    \"start_time\": start_time,\n    \"end_time\": end_time,\n    \"type\": \"physics\",\n    \"model_reference_date\": datetime(2000, 1, 1), # this is the default\n}\n\n\n\nsurface_forcing_kwargs1 = {\n    \"grid\": grid,\n    \"start_time\": start_time1,\n    \"end_time\": end_time1,\n    \"type\": \"physics\",\n    \"model_reference_date\": datetime(2000, 1, 1), # this is the default\n}\n\n\n\n%%time\n\nsurface_forcing = SurfaceForcing(\n    **surface_forcing_kwargs,\n    source={\"name\": \"ERA5\"},\n    use_dask=True,\n)\n\n\n\n\n\n%%time\n\nsurface_forcing1 = SurfaceForcing(\n    **surface_forcing_kwargs1,\n    source={\"name\": \"ERA5\"},\n    use_dask=True,\n)\n\n\n\n\n\nsurface_forcing.plot(\"uwnd\", time=0)\n\n\n\n\n\n#cesm_bgc_path = \"/global/cfs/projectdirs/m4746/Datasets/CESM_REGRIDDED/CESM-surface_lowres_regridded.nc\"\nunified_bgc_path = datasets+\"UNIFIED/BGCdataset.nc\"\n\n\n\n%%time\n\nunified_bgc_surface_forcing = SurfaceForcing(\n    grid=grid,\n    start_time=start_time,\n    end_time=end_time,\n    source={\"name\": \"UNIFIED\", \"path\": unified_bgc_path, \"climatology\": True},\n    type=\"bgc\",\n    use_dask=True,\n)\n\n\n\n\n\nfilepath = project+model_name+\"_surface_forcing2024.nc\"\n\n\n\n%time surface_forcing.save(filepath, group=True)\n\n\n\n\n\n\n\n%time surface_forcing1.save(filepath, group=True)\n\n\n\n\n\n\n\nfilepath = project+model_name+\"_bgc_surface_forcing.nc\"\n\n\n\n%time unified_bgc_surface_forcing.save(filepath)\n\n\n\n\n\n\n\nNext we generate the initial file\n\nfrom roms_tools import Grid, ChildGrid\n\n\n\nparent_grid = grid\n\n\n\nchild_grid_parameters = {\n    \"nx\": 512,\n    \"ny\": 512,\n    \"size_x\": 102.4,\n    \"size_y\": 102.4,\n    \"center_lon\": -22.4,\n    \"center_lat\": 64.39,\n    \"rot\": 0,\n    \"topography_source\": {\n        \"name\": \"SRTM15\",\n        \"path\": datasets+\"SRTM15/SRTM15_V2.6.nc\"},\n    \"N\":40  # number of vertical layers\n}\n\n\n\nchild_grid = ChildGrid(\n    **child_grid_parameters,\n    parent_grid=parent_grid,\n    boundaries={\n        \"south\": True,\n        \"east\": False,\n        \"north\": False,\n        \"west\": True,\n    },  # this is the default\n    metadata={\"prefix\": \"child\", \"period\": 1800.0}  # this is the default\n)\n\n\n\nchild_grid.plot_nesting(with_dim_names=True)\n\n\n\nfilepath = project+child_name+\"_grid.nc\"\nchild_grid.save(filepath=filepath)\n\n\n\nfilepath_nesting = project+child_name+\"_edata.nc\"\n\n\n\nchild_grid.save_nesting(filepath=filepath_nesting)\n\n","type":"content","url":"/setup-iceland1-marbl-2024-copy1","position":1},{"hierarchy":{"lvl1":"ROMS-TOOLS setup for Iceland3_MARBL_2024"},"type":"lvl1","url":"/setup-iceland2-marbl-2024","position":0},{"hierarchy":{"lvl1":"ROMS-TOOLS setup for Iceland3_MARBL_2024"},"content":"First step is to set up the outer grid using ROMS-TOOLS and save the grid file.\n\nfrom roms_tools import Grid\n\n\n\nproject='/anvil/projects/x-ees250129/x-uheede/INPUT_files/Iceland2_MARBL_2024/'\ndatasets='/anvil/projects/x-ees250129/Datasets_subset/'\nmodel_name='Iceland2'\nchild_name='Iceland3'\ngrid_path='/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_r2r_phys+bgc/1.Make_grid/Iceland2_grid_MAT1.nc'\n\n\n\n#%%time\n\n#grid = Grid(\n#    nx=512,\n#    ny=512,\n#    size_x=102.4,\n#    size_y=102.4,\n#    center_lon=-22.3,\n#    center_lat=64.39,\n#    rot=0,\n#    topography_source={\n#        \"name\": \"SRTM15\",\n#        \"path\": datasets+\"SRTM15/SRTM15_V2.6.nc\"},\n#    N=40  # number of vertical layers\n#)\n\n\n\ngrid = Grid.from_file(grid_path)\n\n\n\ngrid.plot()\n\n\n\nfilepath = project+model_name+'_grid.nc'\n\n\n\ngrid.update_vertical_coordinate(N=60, theta_s=5.0, theta_b=2.0, hc=300.0, verbose=False)\n\n\n\ngrid.plot_vertical_coordinate(eta=250, max_nr_layer_contours=10,)\n\n\n\ngrid.plot_vertical_coordinate(eta=250, max_nr_layer_contours=10,)\n\n\n\ngrid.save(filepath)\n\n\n\n\n\ntpxo_path = datasets+\"TPXO/TPXO10.v2/\"\ntpxo_dict = {\n    \"grid\": tpxo_path + \"grid_tpxo10v2.nc\",\n    \"h\": tpxo_path + \"h_tpxo10.v2.nc\",\n    \"u\": tpxo_path + \"u_tpxo10.v2.nc\",\n}\n\n\n\nNext, we set up tidal forcing:\n\nfrom roms_tools import TidalForcing\n\n\n\nfrom datetime import datetime\n\n\n\nmodel_reference_date = datetime(2000, 1, 1)\n\n\n\n\ntidal_forcing = TidalForcing(\n    grid=grid,\n    source={\"name\": \"TPXO\", \"path\": tpxo_dict},\n    ntides=15,  # Number of constituents to consider <= 15. Default is 10.\n    model_reference_date=model_reference_date,  # Model reference date. Default is January 1, 2000.\n    use_dask=True\n)\n\n\n\nfilepath = project+model_name+\"_tides.nc\"\n\n\n\n%time tidal_forcing.save(filepath)\n\n\n\n\n\n\n\nFor the surface forcing, we use ERA5 plus the unified BGC dataset\n\nfrom roms_tools import Grid, SurfaceForcing\n\n\n\nstart_time = datetime(2024, 7, 1)\nend_time = datetime(2024, 12, 31)\n\n\n\nsurface_forcing_kwargs = {\n    \"grid\": grid,\n    \"start_time\": start_time,\n    \"end_time\": end_time,\n    \"type\": \"physics\",\n    \"model_reference_date\": datetime(2000, 1, 1), # this is the default\n}\n\n\n\n%%time\n\nsurface_forcing = SurfaceForcing(\n    **surface_forcing_kwargs,\n    source={\"name\": \"ERA5\"},\n    use_dask=True,\n)\n\n\n\n\n\nsurface_forcing.plot(\"uwnd\", time=0)\n\n\n\n\n\n#cesm_bgc_path = \"/global/cfs/projectdirs/m4746/Datasets/CESM_REGRIDDED/CESM-surface_lowres_regridded.nc\"\nunified_bgc_path = datasets+\"UNIFIED/BGCdataset.nc\"\n\n\n\n%%time\n\nunified_bgc_surface_forcing = SurfaceForcing(\n    grid=grid,\n    start_time=start_time,\n    end_time=end_time,\n    source={\"name\": \"UNIFIED\", \"path\": unified_bgc_path, \"climatology\": True},\n    type=\"bgc\",\n    use_dask=True,\n)\n\n\n\n\n\nfilepath = project+model_name+\"_surface_forcing2024.nc\"\n\n\n\n%time surface_forcing.save(filepath, group=True)\n\n\n\n\n\n\n\nfilepath = project+model_name+\"_bgc_surface_forcing.nc\"\n\n\n\n%time unified_bgc_surface_forcing.save(filepath)\n\n\n\n\n\n\n\nNext we generate the initial file\n\nfrom roms_tools import Grid, ChildGrid\n\n\n\nparent_grid = grid\n\n\n\nchild_grid_parameters = {\n    \"nx\": 512,\n    \"ny\": 512,\n    \"size_x\": 102.4/4,\n    \"size_y\": 102.4/4,\n    \"center_lon\": -21.75,\n    \"center_lat\": 64.3,\n    \"rot\": 0,\n    \"topography_source\": {\n        \"name\": \"SRTM15\",\n        \"path\": datasets+\"SRTM15/SRTM15_V2.6.nc\"},\n    \"N\":40  # number of vertical layers\n}\n\n\n\nchild_grid = ChildGrid(\n    **child_grid_parameters,\n    parent_grid=parent_grid,\n    boundaries={\n        \"south\": True,\n        \"east\": False,\n        \"north\": False,\n        \"west\": True,\n    },  # this is the default\n    metadata={\"prefix\": \"child\", \"period\": 1800.0}  # this is the default\n)\n\n\n\nchild_grid.plot_nesting(with_dim_names=True)\n\n\n\nfilepath = project+child_name+\"_grid.nc\"\nchild_grid.save(filepath=filepath)\n\n\n\n\n\nfilepath_nesting = project+child_name+\"_edata.nc\"\n\n\n\nchild_grid.save_nesting(filepath=filepath_nesting)\n\n\n\n\n\nimport xarray as xr\n\n\n\nfrom roms_tools import RiverForcing, Grid\n\n\n\nfrom datetime import datetime\n\n\n\nriv0=xr.open_dataset('/anvil/projects/x-ees250129/Datasets/Iceland_river_dataset/Hvalfjordur_rivers_2023.nc')\n\n\n\nriv0['time']=[202401., 202402., 202403., 202404., 202405., 202406., 202407., 202408.,\n       202409., 202410., 202411., 202412.]\n\n\n\nriv0.to_netcdf('/anvil/projects/x-ees250129/Datasets/Iceland_river_dataset/Hvalfjordur_rivers_2024.nc')\n\n\n\nstart_time = datetime(2024, 1, 1)\nend_time = datetime(2024, 12, 31)\n\n\n\nriver_forcing = RiverForcing(\n    grid=grid,\n    start_time=start_time,\n    end_time=end_time,\n    model_reference_date=datetime(2000, 1, 1), # this is the default\n    include_bgc=True,\n    source = {\n    \"name\": \"DAI\",\n    \"path\": \"/anvil/projects/x-ees250129/Datasets/Iceland_river_dataset/Hvalfjordur_rivers_2024.nc\",\n    \"climatology\": False\n}\n    \n)\n\n\n\nriver_forcing.ds\n\n\n\nriver_forcing.plot_locations()\n\n\n\nriver_forcing.plot(\"river_volume\")\n\n\n\nfilepath = project+model_name+\"_rivers.nc\"\n\n\n\nriver_forcing.save(filepath=filepath)\n\n\n\n\n\nMaking some customizations to the river forcing (we have observed values of alk and DIC in the rivers and we also know the water is not going to be 17 degrees warm!). We add nutrients (observed values in fjord before spring bloom) and we add observed riverine values of Alk and DIC. These should be subject to change.\n\nimport xarray as xr\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nriv=xr.open_dataset(filepath)\nriv.load()\n\n\n\n\n\n#riv['river_time']=pd.to_datetime(['2024-01-15T00:00:00.000000000', '2024-02-15T00:00:00.000000000',\n#       '2024-03-15T00:00:00.000000000', '2024-04-15T00:00:00.000000000',\n#       '2024-05-15T00:00:00.000000000', '2024-06-15T00:00:00.000000000',\n#       '2024-07-15T00:00:00.000000000', '2024-08-15T00:00:00.000000000',\n#       '2024-09-15T00:00:00.000000000', '2024-10-15T00:00:00.000000000',\n#       '2024-11-15T00:00:00.000000000', '2024-12-15T00:00:00.000000000'])\n\n\n\n\nriv['river_time']\n\n\n\nriv['tracer_name']\n\n\n\n# Create new array\nnew_tracer = np.zeros_like(riv['river_tracer'].values)\n\n# Temperature varies sinusoidally with time\ntemp = 10 * np.sin(np.linspace(0, np.pi, riv.dims['river_time']))  # 12-month cycle\n\n# Loop through tracers\nfor i, tracer in enumerate(riv['tracer_name'].values):\n    if tracer == 'temp':\n        new_tracer[:, i, :] = temp[:, np.newaxis]  # vary with time\n    elif tracer == 'salt':\n        new_tracer[:, i, :] = 1\n    elif tracer == 'PO4':\n        new_tracer[:, i, :] = 0.4\n    elif tracer == 'NO3':\n        new_tracer[:, i, :] = 6\n    elif tracer == 'SiO3':\n        new_tracer[:, i, :] = 3\n    elif tracer == 'NH4':\n        new_tracer[:, i, :] = 0.4\n    elif tracer == 'Fe':\n        new_tracer[:, i, :] = 0.000197\n    elif tracer == 'Lig':\n        new_tracer[:, i, :] = 0.000465    \n    elif tracer == 'O2':\n        new_tracer[:, i, :] = 360    \n    elif tracer == 'DIC':\n        new_tracer[:, i, :] = 313    \n    elif tracer == 'DIC_ALT_CO2':\n        new_tracer[:, i, :] = 313  \n    elif tracer == 'ALK':\n        new_tracer[:, i, :] = 282 \n    elif tracer == 'ALK_ALT_CO2':\n        new_tracer[:, i, :] = 282 \n    else:\n        new_tracer[:, i, :] = 0.0\nriv['river_tracer'] = (riv['river_tracer'].dims, new_tracer)\n\n\n\nupdated_tracer_values=[10,1,0.4,6,3,0.4,0.000197,0.000465,360,313,313,282,282,14,1.18,0.05,0.0257,1.35,26,0.260,0.0442,0.02,0.000171,0.0000004,0.00056,0.0143,0.044,0.000375,0.0000004,0.019,0.0001225,0.001,0.00000066,0.000000046]\n\n\n\nplt.plot(temp)\n\n\n\nriv.to_netcdf(project+model_name+\"_rivers_modified.nc\")\n\n\n\n\n\n\n\nimport xarray as xr\n\n# Open your modified file\nriver = xr.open_dataset(project+model_name+\"_rivers_modified.nc\")\nriver.load()\n# Show what tracers exist\nriver['river_tracer'].isel(ntracers=10).isel(nriver=6).plot()\n\n\n\n\n\nNow, we make another river forcing file with half as much volume\n\nriv['river_volume'][:] = riv['river_volume'].isel(river_time=7)*0.6\n\n\n\nwinter_months = [1, 2, 3, 4, 11, 12]\n\n# Create a boolean mask for winter times\nwinter_mask = riv['abs_time'].dt.month.isin(winter_months)\n\n# Set river_volume to zero where the mask is True\nriv['river_volume'] = riv['river_volume'].where(~winter_mask, 0.0)\n\n\n\nriv\n\n\n\nriv.to_netcdf(project+model_name+\"_rivers_modified_new40off.nc\")\n\n\n\nimport xarray as xr\n\n# Open your modified file\nriver1 = xr.open_dataset(project+model_name+\"_rivers_modified_new40off.nc\")\nriver1.load()\n# Show what tracers exist\nriver1['river_volume'].isel(nriver=3).plot()\n\n\n\n\nriver1['river_volume'].isel(nriver=6)\n\n\n\nimport xarray as xr\n\n# Open your modified file\nriver2 = xr.open_dataset(project+model_name+\"_rivers_modified_HALF.nc\")\nriver2.load()\n# Show what tracers exist\nriver2['river_volume'].isel(nriver=0).plot()\n\n\n\nproject+model_name+\"_rivers_modified_HALF.nc\n\n\n\nproject+model_name\n\n","type":"content","url":"/setup-iceland2-marbl-2024","position":1},{"hierarchy":{"lvl1":"ROMS-TOOLS setup for Iceland3_MARBL_2024"},"type":"lvl1","url":"/setup-iceland3-marbl-2024","position":0},{"hierarchy":{"lvl1":"ROMS-TOOLS setup for Iceland3_MARBL_2024"},"content":"First step is to set up the outer grid using ROMS-TOOLS and save the grid file.\n\nfrom roms_tools import Grid\nimport xarray as xr\n\n\n\nproject='/anvil/projects/x-ees250129/x-uheede/INPUT_files/Iceland3_MARBL_2024/'\ndatasets='/anvil/projects/x-ees250129/Datasets_subset/'\nmodel_name='Iceland3'\nchild_name='Iceland4'\ngrid_path='/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_r2r_phys+bgc/1.Make_grid/Iceland3_grid_MAT.nc'\n\n\n\n#%%time\n\n#grid = Grid(\n#    nx=640,\n#    ny=386,\n#    size_x=32,\n#    size_y=19.2,\n#    center_lon=-21.68,\n#    center_lat=64.325,\n#    rot=0,\n#    topography_source={\n#        \"name\": \"SRTM15\",\n#        \"path\": datasets+\"SRTM15/SRTM15_V2.6.nc\"},\n#    N=40  # number of vertical layers\n#)\n\n\n\ngrid = Grid.from_file(grid_path)\n\n\n\ngrid.plot()\n\n\n\nfilepath = project+model_name+'_grid.nc'\n\n\n\ngrid.update_vertical_coordinate(N=60, theta_s=5.0, theta_b=5.0, hc=5.0, verbose=False)\n\n\n\ngrid.plot_vertical_coordinate(eta=120, max_nr_layer_contours=20)\n\n\n\ngrid.save(filepath)\n\n\n\n\n\ngrid.ds\n\n\n\ntpxo_path = datasets+\"TPXO/TPXO10.v2/\"\ntpxo_dict = {\n    \"grid\": tpxo_path + \"grid_tpxo10v2.nc\",\n    \"h\": tpxo_path + \"h_tpxo10.v2.nc\",\n    \"u\": tpxo_path + \"u_tpxo10.v2.nc\",\n}\n\n\n\nNext, we set up tidal forcing:\n\nfrom roms_tools import TidalForcing\n\n\n\nfrom datetime import datetime\n\n\n\nmodel_reference_date = datetime(2000, 1, 1)\n\n\n\n\ntidal_forcing = TidalForcing(\n    grid=grid,\n    source={\"name\": \"TPXO\", \"path\": tpxo_dict},\n    ntides=15,  # Number of constituents to consider <= 15. Default is 10.\n    model_reference_date=model_reference_date,  # Model reference date. Default is January 1, 2000.\n    use_dask=True\n)\n\n\n\nfilepath = project+model_name+\"_tides.nc\"\n\n\n\n%time tidal_forcing.save(filepath)\n\n\n\n\n\n\n\nFor the surface forcing, we use ERA5 plus the unified BGC dataset\n\nfrom roms_tools import Grid, SurfaceForcing\n\n\n\nstart_time = datetime(2023, 12, 1)\nend_time = datetime(2024, 12, 31)\n\n\n\nsurface_forcing_kwargs = {\n    \"grid\": grid,\n    \"start_time\": start_time,\n    \"end_time\": end_time,\n    \"type\": \"physics\",\n    \"model_reference_date\": datetime(2000, 1, 1), # this is the default\n}\n\n\n\n%%time\n\nsurface_forcing = SurfaceForcing(\n    **surface_forcing_kwargs,\n    source={\"name\": \"ERA5\"},\n    use_dask=True,\n)\n\n\n\n\n\nsurface_forcing.plot(\"uwnd\", time=0)\n\n\n\n\n\n#cesm_bgc_path = \"/global/cfs/projectdirs/m4746/Datasets/CESM_REGRIDDED/CESM-surface_lowres_regridded.nc\"\nunified_bgc_path = datasets+\"UNIFIED/BGCdataset.nc\"\n\n\n\n%%time\n\nunified_bgc_surface_forcing = SurfaceForcing(\n    grid=grid,\n    start_time=start_time,\n    end_time=end_time,\n    source={\"name\": \"UNIFIED\", \"path\": unified_bgc_path, \"climatology\": True},\n    type=\"bgc\",\n    use_dask=True,\n)\n\n\n\n\n\nfilepath = project+model_name+\"_surface_forcing2024.nc\"\n\n\n\n%time surface_forcing.save(filepath, group=True)\n\n\n\n\n\n\n\nfilepath = project+model_name+\"_bgc_surface_forcing.nc\"\n\n\n\n%time unified_bgc_surface_forcing.save(filepath)\n\n\n\n\n\n\n\nNext we generate the initial file\n\nfrom roms_tools import RiverForcing, Grid\n\n\n\nfrom datetime import datetime\n\n\n\nstart_time = datetime(2024, 1, 1)\nend_time = datetime(2024, 12, 31)\n\n\n\nriver_forcing = RiverForcing(\n    grid=grid,\n    start_time=start_time,\n    end_time=end_time,\n    model_reference_date=datetime(2000, 1, 1), # this is the default\n    include_bgc=True,\n    source = {\n    \"name\": \"DAI\",\n    \"path\": \"/anvil/projects/x-ees250129/Datasets_subset/Iceland_river_dataset/Hvalfjordur_rivers_2024.nc\",\n    \"climatology\": False\n}\n    \n)\n\n\n\nriver_forcing.ds\n\n\n\nriver_forcing.plot_locations()\n\n\n\nriver_forcing.plot(\"river_volume\")\n\n\n\nfilepath = project+model_name+\"_rivers.nc\"\n\n\n\nriver_forcing.save(filepath=filepath)\n\n\n\n\n\nimport xarray as xr\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nriv=xr.open_dataset(filepath)\nriv.load()\n\n\n\n\n\n# Create new array\nnew_tracer = np.zeros_like(riv['river_tracer'].values)\n\n# Temperature varies sinusoidally with time\ntemp = 10 * np.sin(np.linspace(0, np.pi, riv.dims['river_time']))  # 12-month cycle\n\n# Loop through tracers\nfor i, tracer in enumerate(riv['tracer_name'].values):\n    if tracer == 'temp':\n        new_tracer[:, i, :] = temp[:, np.newaxis]  # vary with time\n    elif tracer == 'salt':\n        new_tracer[:, i, :] = 1\n    elif tracer == 'PO4':\n        new_tracer[:, i, :] = 0.4\n    elif tracer == 'NO3':\n        new_tracer[:, i, :] = 6\n    elif tracer == 'SiO3':\n        new_tracer[:, i, :] = 3\n    elif tracer == 'NH4':\n        new_tracer[:, i, :] = 0.4\n    elif tracer == 'Fe':\n        new_tracer[:, i, :] = 0.000197\n    elif tracer == 'Lig':\n        new_tracer[:, i, :] = 0.000465    \n    elif tracer == 'O2':\n        new_tracer[:, i, :] = 360    \n    elif tracer == 'DIC':\n        new_tracer[:, i, :] = 313    \n    elif tracer == 'DIC_ALT_CO2':\n        new_tracer[:, i, :] = 313  \n    elif tracer == 'ALK':\n        new_tracer[:, i, :] = 282 \n    elif tracer == 'ALK_ALT_CO2':\n        new_tracer[:, i, :] = 282 \n    else:\n        new_tracer[:, i, :] = 0.0\nriv['river_tracer'] = (riv['river_tracer'].dims, new_tracer)\n\n\n\nriv.to_netcdf(project+model_name+\"_rivers_modified.nc\")\n\n\n\n","type":"content","url":"/setup-iceland3-marbl-2024","position":1},{"hierarchy":{"lvl1":"ROMS-TOOLS setup for Iceland3_MARBL_2024","lvl2":"CDR release"},"type":"lvl2","url":"/setup-iceland3-marbl-2024#cdr-release","position":2},{"hierarchy":{"lvl1":"ROMS-TOOLS setup for Iceland3_MARBL_2024","lvl2":"CDR release"},"content":"\n\nfrom roms_tools import VolumeRelease\n\n\n\ntimes = [\n    datetime(2024, 2, 17, 12, 0),\n    datetime(2024, 2, 18, 12, 0),\n    datetime(2024, 2, 19, 12, 0),\n    datetime(2024, 2, 20, 12, 0),\n    datetime(2024, 2, 21, 12, 0),\n    datetime(2024, 2, 22, 12, 0),\n    datetime(2024, 2, 23, 12, 0),\n    datetime(2024, 2, 24, 12, 0),\n    datetime(2024, 2, 25, 12, 0),\n    datetime(2024, 2, 26, 12, 0),\n    datetime(2024, 2, 27, 12, 0),\n]\n\n\n\nconstant_volume_release_iceland = VolumeRelease(\n    name=\"iceland_release\",\n    lat=64.394213,  # degree N\n    lon=-21.465904,  # degree E\n    depth=2,  # m\n    times=times,\n    volume_fluxes=[0,0.000583,0.000583,0.000583,0.000583,0,0,0,0,0,0],  # m3/s\n    tracer_concentrations={\n        \"temp\": 10.0,  # degrees C\n        \"salt\": 1.0,  # psu\n        \"ALK\": 1800000  # meq/m3\n        },\n    fill_values=\"zero\"\n)\n\n\n\nconstant_volume_release_iceland\n\n\n\nfrom roms_tools import CDRForcing\n\n\n\nstart_time_release = datetime(2024, 2, 17)\nend_time_release = datetime(2024, 2, 28)\n\n\n\n\n\n\n\ncdr_forcing_with_volume_releases = CDRForcing(\n    grid=grid,\n    start_time=start_time_release,\n    end_time=end_time_release,\n    model_reference_date=datetime(2000, 1, 1), # this is the default\n    releases=[\n        constant_volume_release_iceland],\n)\n\n\n\ncdr_forcing_with_volume_releases.plot_locations()  # By default, this plots all available releases (but max 20).\n\n\n\n\ncdr_forcing_with_volume_releases.plot_volume_flux()\n\n\n\nfilepath = project+model_name+'_cdr_forcing.nc'\n\n\n\ncdr_forcing_with_volume_releases.save(filepath=filepath)\n\n\n\n\n\nfrom roms_tools import partition_netcdf\n\n\n\npartition_netcdf(filepath, 16, 16,'/home/x-uheede/S/Iceland3_MARBL_2024_60m_CDR/P_INPUT')\n\n","type":"content","url":"/setup-iceland3-marbl-2024#cdr-release","position":3},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/sf6-comparison","position":0},{"hierarchy":{"lvl1":""},"content":"import subprocess\nimport os\n\nimport netCDF4\nimport numpy as np\nimport glob\nimport time\nimport matplotlib.pyplot as plt\nimport copy\nimport xarray as xr\nfrom datetime import datetime, timedelta \n#from ocean_c_lab_tools import *\nfrom celluloid import Camera \n#import PyCO2SYS as csys\nimport seawater as sw\nimport cartopy.crs as ccrs\nfrom roms_regrid import *\n\n\n\nx=xr.open_mfdataset('/global/cfs/cdirs/m4632/uheede/dye_tracer/Iceland4_multidye_np4/Iceland4_linedye_rnd.2012060[2-6]000000.nc', combine='nested', concat_dim=[\"time\"])\nattrs = {'units': 'seconds since 2000-01-01'}\nds = xr.Dataset({'time': ( x['ocean_time'].load())})\nds = xr.Dataset({'time': ('time', x['ocean_time'].values, attrs)})\ntest=xr.decode_cf(ds)\n\n\n\nx=xr.open_mfdataset('/global/cfs/cdirs/m4632/uheede/dye_tracer/Iceland4_multidye_np4/Iceland4_linedye_rnd.2012060[2-8]000000.nc', combine='nested', concat_dim=[\"time\"])\n#dye1=x['dye1'].isel(s_rho=99).load()\ndye2=x['dye2'].isel(s_rho=99).load()\n\n\n\ndye2\n\n\n\nmean=dye2.where(dye2>0.0000001).mean('eta_rho',skipna=True).mean('xi_rho',skipna=True)\n\n\n\nobs_patch=[1543773,171709,45353,24234,16910,7120,3936,2949,2778]\nhrs=[0,24,24*2,24*3,24*4,24*5,24*6,24*7,24*8]\n\n\n\nplt.plot(mean*10**7.55,color='black',label='ROMS dye passive tracer mean scaled to SF6')\nplt.plot(hrs,obs_patch,color='red',label='SF6 mean of daily observations, uncalibrated')\n#plt.plot(y)\nplt.yscale(\"log\") \nplt.title('ROMS passive tracer release compared to SF6 surface underway')\n#plt.xlabel('hours since release')\n#plt.ylim(10**3,1.2**5)\nplt.grid()\nplt.legend()\nplt.xlabel('hours since release')\nplt.ylabel('SF6 area')\n#plt.xscale(\"log\") \n\n","type":"content","url":"/sf6-comparison","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/sf6-observations","position":0},{"hierarchy":{"lvl1":""},"content":"import subprocess\nimport os\nimport pandas as pd\nimport netCDF4\nimport numpy as np\nimport glob\nimport time\nimport matplotlib.pyplot as plt\nimport copy\nimport xarray as xr\nfrom datetime import datetime, timedelta \nimport dask\nfrom scipy.interpolate import griddata\n#from ocean_c_lab_tools import *\n#from celluloid import Camera \n#import PyCO2SYS as csys\nimport seawater as sw\nfrom roms_regrid import *\n\n\n\nxls = pd.ExcelFile('20241119_combined_data.xlsx')\n\n\ncombo = pd.read_excel(xls, '20241119_combined_data',decimal='.')\ncombo\n\n\n\nobs=xr.Dataset.from_dataframe(combo)\nobs=obs.set_index(index=['Date','Obs_no'])\n#obs=obs.drop_duplicates('index')\nobs=obs.unstack('index')\n#obs=obs.rename(name_dict={'mon/day/yr':'time','Depth':'depth','Latitude(¬∞N)':'lat','Longitude(¬∞E)':'lon'})\n\n\n\n\ngrid=xr.open_mfdataset('/global/cfs/cdirs/m4632/uheede/roms_setups/Iceland3_MARBL/1.Make_grid/Iceland4_grd.nc')\nmask=roms_regrid(grid,grid['mask_rho'])\n\n\n\ngrid\n\n\n\nimport numpy as np\n\ndef get_daily_locations(obs_ds):\n    dates = obs_ds['Date'].values\n    num_days = len(dates)\n    num_obs = obs_ds.dims['Obs_no']\n    \n    # Initialize empty array: (days, obs, 2)\n    locations = np.empty((num_days, num_obs, 2))\n    \n    for i in range(0,num_days):\n        lat = obs_ds['Lat'].isel(Date=i).values\n        lon = obs_ds['Long'].isel(Date=i).values + 360  # convert to 0–360 range\n        locations[i, :, 0] = lat\n        locations[i, :, 1] = lon\n    \n    return locations\n\n# Example usage\nlocations_array = get_daily_locations(obs)\nprint(\"Shape of locations array:\", locations_array.shape)  # should be (9, 2729, 2)\n\n\n\n\n\n\nfrom matplotlib.colors import LogNorm\nimport cartopy.crs as ccrs\nfrom cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER\n\n\nfigures = [\n    {'days': [0, 1]},       # Figure 1: Days 1–2\n    {'days': [2, 3]},       # Figure 2: Days 3–4\n    {'days': [4, 5]},       # Figure 3: Days 5–6\n    {'days': [6]},          # Figure 4: Day 7\n]\n\nfor fig_idx, group in enumerate(figures):\n    nrows = len(group['days'])\n    fig, axs = plt.subplots(nrows=nrows, figsize=(6, 2.5 * nrows), dpi=200,\n                            subplot_kw={'projection': ccrs.Mercator()})\n\n    if nrows == 1:\n        axs = [axs]  # make iterable\n\n    for ax, day in zip(axs, group['days']):\n        obs_day=obs['SF6 (fmol/L)'].isel(Date=day).values\n        obs_lat=obs['Lat'].isel(Date=day).values\n        obs_lon=obs['Long'].isel(Date=day).values\n        obs_clear = obs_day[~np.isnan(obs_day)]\n        obs_lat = obs_lat[~np.isnan(obs_lat)]\n        obs_lon = obs_lon[~np.isnan(obs_lon)]\n        \n        ax.contourf(mask.lon, mask.lat, mask.load(), transform=ccrs.PlateCarree(), cmap='bone')\n        \n        scatter = ax.scatter(obs_lat, obs_lon, c=obs_clear, cmap='jet', edgecolor='none',\n                             transform=ccrs.PlateCarree(), s=5,\n                             norm=LogNorm(vmin=1e-1, vmax=5e4))\n    gl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True,\n                      linewidth=1, color='gray', alpha=0.5, linestyle='--')\n    gl.top_labels = False\n    gl.right_labels = False\n    gl.xlines = False\n    gl.ylines = False\n    gl.xformatter = LONGITUDE_FORMATTER\n    gl.yformatter = LATITUDE_FORMATTER\n\n    ax.set_title(f'Day {day+1}: Avg SF6 over 24 hrs', fontsize=8)\n    # Get the bounding box of the mask\n    lon_min = float(mask.lon.min())\n    lon_max = float(mask.lon.max())\n    lat_min = float(mask.lat.min())\n    lat_max = float(mask.lat.max())\n\n    # Set map extent to match mask\n    ax.set_extent([lon_min, lon_max, lat_min, lat_max], crs=ccrs.PlateCarree())\n\n# Colorbar\n#cbar = ax.colorbar(scatter, ax=axs, orientation='vertical', shrink=0.5, pad=0.05)\n#cbar.set_label('SF6 (fmol/L)')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nfrom matplotlib.colors import LogNorm\nimport cartopy.crs as ccrs\nfrom cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER\nimport matplotlib.pyplot as plt\n\nfigures = [\n    {'days': [0, 1]},       # Figure 1: Days 1–2\n    {'days': [2, 3]},       # Figure 2: Days 3–4\n    {'days': [4, 5]},       # Figure 3: Days 5–6\n    {'days': [6]},          # Figure 4: Day 7\n]\n\nfor fig_idx, group in enumerate(figures):\n    nrows = len(group['days'])\n    fig, axs = plt.subplots(nrows=nrows, figsize=(6, 2.5 * nrows), dpi=200,\n                            subplot_kw={'projection': ccrs.Mercator()})\n\n    if nrows == 1:\n        axs = [axs]  # Make iterable if only one subplot\n\n    for ax, day in zip(axs, group['days']):\n        # Extract observation values\n        obs_day = obs['SF6 (fmol/L)'].isel(Date=day).values\n        obs_lat = obs['Lat'].isel(Date=day).values\n        obs_lon = obs['Long'].isel(Date=day).values\n\n        # Remove NaNs\n        mask_valid = ~np.isnan(obs_day)\n        obs_clear = obs_day[mask_valid]\n        obs_lat = obs_lat[mask_valid]\n        obs_lon = obs_lon[mask_valid]\n\n        # Plot the land mask\n        ax.contourf(mask.lon, mask.lat, mask.load(), transform=ccrs.PlateCarree(), cmap='bone')\n\n        # Plot the observations as scatter points\n        scatter = ax.scatter(obs_lon, obs_lat, c=obs_clear, cmap='jet', edgecolor='none',\n                             transform=ccrs.PlateCarree(), s=5,\n                             norm=LogNorm(vmin=1e-1, vmax=5e4))\n\n        # Set map extent to match mask\n        lon_min = float(mask.lon.min())\n        lon_max = float(mask.lon.max())\n        lat_min = float(mask.lat.min())\n        lat_max = float(mask.lat.max())\n        ax.set_extent([lon_min, lon_max, lat_min, lat_max], crs=ccrs.PlateCarree())\n\n        # Add gridlines\n        gl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True,\n                          linewidth=1, color='gray', alpha=0.5, linestyle='--')\n        gl.top_labels = False\n        gl.right_labels = False\n        gl.xlines = False\n        gl.ylines = False\n        gl.xformatter = LONGITUDE_FORMATTER\n        gl.yformatter = LATITUDE_FORMATTER\n\n        # Title\n        ax.set_title(f'Day {day+1}: SF6 Observations', fontsize=8)\n\n    # Optional colorbar for each figure (shared across subplots)\n    # cbar = fig.colorbar(scatter, ax=axs, orientation='vertical', shrink=0.6, pad=0.05)\n    # cbar.set_label('SF6 (fmol/L)')\n\n    plt.tight_layout()\n    plt.show()\n\n\n\n\n\n\n\n\n\n\nfor fig_idx, group in enumerate(figures):\n    nrows = len(group['days'])\n    fig, axs = plt.subplots(nrows=nrows, figsize=(6, 2.5 * nrows), dpi=200,\n                            subplot_kw={'projection': ccrs.Mercator()})\n\n    if nrows == 1:\n        axs = [axs]\n\n    all_scatters = []\n    for ax, day in zip(axs, group['days']):\n        obs_day = obs['SF6 (fmol/L)'].isel(Date=day).values\n        obs_lat = obs['Lat'].isel(Date=day).values\n        obs_lon = obs['Long'].isel(Date=day).values\n\n        mask_valid = ~np.isnan(obs_day)\n        obs_clear = obs_day[mask_valid]\n        obs_lat = obs_lat[mask_valid]\n        obs_lon = obs_lon[mask_valid]\n\n        ax.contourf(mask.lon, mask.lat, mask.load(), transform=ccrs.PlateCarree(), cmap='bone')\n\n        scatter = ax.scatter(obs_lon, obs_lat, c=obs_clear, cmap='jet', edgecolor='none',\n                             transform=ccrs.PlateCarree(), s=5,\n                             norm=LogNorm(vmin=1e-1, vmax=5e4))\n        all_scatters.append(scatter)\n\n        lon_min = float(mask.lon.min())\n        lon_max = float(mask.lon.max())\n        lat_min = float(mask.lat.min())\n        lat_max = float(mask.lat.max())\n        ax.set_extent([lon_min, lon_max, lat_min, lat_max], crs=ccrs.PlateCarree())\n\n        gl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True,\n                          linewidth=1, color='gray', alpha=0.5, linestyle='--')\n        gl.top_labels = False\n        gl.right_labels = False\n        gl.xlines = False\n        gl.ylines = False\n        gl.xformatter = LONGITUDE_FORMATTER\n        gl.yformatter = LATITUDE_FORMATTER\n\n        ax.set_title(f'Day {day+1}: SF6 Observations', fontsize=8)\n\n    # Optional: add shared colorbar\n    #cbar = fig.colorbar(all_scatters[0], ax=axs, orientation='vertical', shrink=0.6, pad=0.05)\n    #cbar.set_label('SF6 (fmol/L)')\n\n    plt.tight_layout()\n    plt.savefig(f'sf6_obs_group_{fig_idx+1}.png', dpi=300, bbox_inches='tight')\n    plt.show()\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport xarray as xr\n\n\n\nnum_days = 7\n\n# Precompute the mask\nmask = roms_regrid(grid, grid['mask_rho'])\n\n# Set up plotting\nplt.figure(figsize=(10, 5), dpi=300)\nvmin, vmax = 1e-1, 5e4\n\nfor day in range(num_days):\n\n\n    obs_day = obs['SF6 (fmol/L)'].isel(Date=day).values\n    obs_lat = obs['Lat'].isel(Date=day).values\n    obs_lon = obs['Long'].isel(Date=day).values\n\n    mask_valid = ~np.isnan(obs_day)\n    obs_clear = obs_day[mask_valid]\n    obs_lat = obs_lat[mask_valid]\n    obs_lon = obs_lon[mask_valid]\n\n    # Convert to numpy arrays and sort by longitude\n    lons = np.array(obs_lon)+360\n    dye_values = np.array(obs_clear)\n    sort_idx = np.argsort(lons)\n    lons_sorted = lons[sort_idx]\n    dye_sorted = dye_values[sort_idx]\n\n    # Plot\n    plt.plot(lons_sorted, dye_sorted, label=f'Day {day + 1}')\n\n# Final plot formatting\n#plt.yscale('log')\nplt.xlabel('Longitude')\nplt.ylabel('SF6 (fmol/L)')\nplt.title('SF6 vs Longitude (Days 1–7)')\nplt.legend(title='Day')\nplt.grid(True, which='both', linestyle='--', alpha=0.5)\nplt.tight_layout()\nplt.ylim([0,3000])\nplt.show()\n\n\n","type":"content","url":"/sf6-observations","position":1},{"hierarchy":{"lvl1":"Site description figures"},"type":"lvl1","url":"/site-description","position":0},{"hierarchy":{"lvl1":"Site description figures"},"content":"import subprocess\nimport os\n\nimport netCDF4\nimport numpy as np\nimport glob\nimport time\nimport matplotlib.pyplot as plt\nimport copy\nimport xarray as xr\nfrom datetime import datetime, timedelta \nfrom roms_regrid import *\nfrom celluloid import Camera \nimport cartopy.crs as ccrs\nimport seawater as sw\nimport pandas as pd\n\n\n\ngrid=xr.open_dataset('/global/cfs/cdirs/m4632/uheede/work/Iceland4_BGC/INPUT/Iceland4_grd.nc')\ngrid_pr=grid\nh=grid['h'].values\nmask_rho=grid['mask_rho'].values\npm=grid['pm'].values\npn=grid['pn'].values\n\n\n\nh_regrid=roms_regrid(grid,grid_pr['h'])\nmask_regrid=roms_regrid(grid,grid['mask_rho'])\n\n\n\nf='/global/cfs/cdirs/m4632/uheede/Vedur_data/Grundartangi_01072024-30072024.xls'\ngrundartangi = pd.read_excel(f,decimal=',')\ngrundartangi\n\n\n\n\ntime =grundartangi[' Timabil ']\ntime=time.str.strip()\ntime = pd.to_datetime(time, format=\"%H:%M\\n%d.%m.%Y\",dayfirst=True)\ntime\n\n\n\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.io.img_tiles as cimgt\n\n# Define the basemap\nrequest = cimgt.OSM()\nextent = [-22.2543190362897, -21.3469394652069, 64.22114671, 64.41802068]\n\n# Create figure with GridSpec: 2 rows, 2 columns\nfig = plt.figure(figsize=(12, 10))\ngs = fig.add_gridspec(2, 2, height_ratios=[1, 1])\n\n# Top row: span both columns\nax1 = fig.add_subplot(gs[0, :], projection=request.crs)\nax1.set_extent(extent)\nax1.add_image(request, 10)\nax1.set_title(\"Hvalfjordur Bathymetry\")\n\n# Your contourf plot\ncf1 = ax1.contourf(\n    h_regrid.lon,\n    h_regrid.lat,\n    h_regrid.where(mask_regrid != 0),\n    transform=ccrs.PlateCarree(),\n    cmap=\"PuRd\"\n)\n\n# Add colorbar\ncbar = fig.colorbar(cf1, ax=ax1, orientation=\"vertical\", shrink=0.7, pad=0.05)\ncbar.set_label(\"Depth (m) \")\n\n# Bottom row\n\nfrom windrose import WindroseAxes\nax2 = WindroseAxes(fig, gs[1, 0])\nfig.add_axes(ax2)  \n\nax2.bar(grundartangi['Vindatt (deg)'], grundartangi['Vindur (m/s)'], normed=True, opening=0.8, edgecolor='white')\nax2.set_legend()\nax2.set_title('wind rose for July 2024')\n\npalette = plt.get_cmap('tab20')\nax3 = fig.add_subplot(gs[1, 1])\nax3.set_title('surface water anomalies (m) for July 2024')\nax3.plot(time,grundartangi[' Flodatafla (m)'],color=palette(1))\nax3.set_ylabel('m')\n#ax3.set_xlabel('time')\nplt.setp(ax3.get_xticklabels(), rotation=45, ha=\"right\")\n\n#plt.tight_layout()\nplt.show()\n\n\n\n\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.io.img_tiles as cimgt\nimport cartopy.mpl.ticker as cticker\n\n# Define the basemap\nrequest = cimgt.OSM()\nextent = [-22.2543190362897, -21.3469394652069, 64.22114671, 64.41802068]\n\n# Create figure with GridSpec: 2 rows, 2 columns\nfig = plt.figure(figsize=(12, 10))\ngs = fig.add_gridspec(2, 2, height_ratios=[1, 1])\n\n# Top row: span both columns\nax1 = fig.add_subplot(gs[0, :], projection=request.crs)\nax1.set_extent(extent)\nax1.add_image(request, 10)\nax1.set_title(\"Hvalfjörður Bathymetry\")\n\n# Your contourf plot\ncf1 = ax1.contourf(\n    h_regrid.lon,\n    h_regrid.lat,\n    h_regrid.where(mask_regrid != 0),\n    transform=ccrs.PlateCarree(),\n    cmap=\"PuRd\"\n)\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport cartopy.mpl.ticker as cticker\n\n# --------------------\n# Panel 1 — Surface vectors\n# --------------------\nax = plt.subplot(2, 2, 1, projection=ccrs.PlateCarree())\nax.coastlines()\nax.add_feature(cfeature.LAND, zorder=0, edgecolor='black')\n\nax.quiver(\n    lon_thin, lat_thin,\n    u_surf0_thin, v_surf0_thin,\n    transform=ccrs.PlateCarree()\n)\nax.set_title(\"Surface velocity vectors (thinned)\")\n\n# ---- CUSTOM LAT/LON TICKS ----\nax.set_xticks([-22.2, -22.0, -21.8, -21.6, -21.4], crs=ccrs.PlateCarree())\nax.set_yticks([64.24, 64.28, 64.32, 64.36, 64.40], crs=ccrs.PlateCarree())\n\nlon_formatter = cticker.LongitudeFormatter()\nlat_formatter = cticker.LatitudeFormatter()\nax.xaxis.set_major_formatter(lon_formatter)\nax.yaxis.set_major_formatter(lat_formatter)\n\nax.tick_params(labelbottom=True, labelright=False, bottom=True, right=False)\n\nax.set_xlabel(\"Longitude\")\nax.set_ylabel(\"Latitude\")\n\n\n# --------------------\n# Panel 2 — 20 m vectors\n# --------------------\nax = plt.subplot(2, 2, 2, projection=ccrs.PlateCarree())\nax.coastlines()\nax.add_feature(cfeature.LAND, zorder=0, edgecolor='black')\n\nax.quiver(\n    lon_thin, lat_thin,\n    u_200_thin, v_200_thin,\n    transform=ccrs.PlateCarree(),\n    color='red'\n)\nax.set_title(\"20 m velocity vectors (thinned)\")\n\n# ---- SAME TICKS FOR CONSISTENCY ----\nax.set_xticks([-22.2, -22.0, -21.8, -21.6, -21.4], crs=ccrs.PlateCarree())\nax.set_yticks([64.24, 64.28, 64.32, 64.36, 64.40], crs=ccrs.PlateCarree())\n\nax.xaxis.set_major_formatter(lon_formatter)\nax.yaxis.set_major_formatter(lat_formatter)\n\nax.tick_params(labelbottom=True, labelright=False, bottom=True, right=False)\n\nax.set_xlabel(\"Longitude\")\nax.set_ylabel(\"Latitude\")\n\n\n# Bottom row\nfrom windrose import WindroseAxes\nax2 = WindroseAxes(fig, gs[1, 0])\nfig.add_axes(ax2)\n\nax2.bar(grundartangi['Vindatt (deg)'], grundartangi['Vindur (m/s)'],\n        normed=True, opening=0.8, edgecolor='white')\nax2.set_legend()\nax2.set_title('Wind rose for July 2024')\n\npalette = plt.get_cmap('tab20')\nax3 = fig.add_subplot(gs[1, 1])\nax3.set_title('Surface water anomalies (m) for July 2024')\nax3.plot(time, grundartangi[' Flodatafla (m)'], color=palette(1))\nax3.set_ylabel('m')\nplt.setp(ax3.get_xticklabels(), rotation=45, ha=\"right\")\n\n# Add subplot labels (a), (b), (c)\nax1.text(0.01, 0.99, \"(a)\", transform=ax1.transAxes, fontsize=14, va=\"top\", ha=\"left\", fontweight=\"bold\")\nax2.text(0.01, 0.99, \"(b)\", transform=ax2.transAxes, fontsize=14, va=\"top\", ha=\"left\", fontweight=\"bold\")\nax3.text(0.01, 0.99, \"(c)\", transform=ax3.transAxes, fontsize=14, va=\"top\", ha=\"left\", fontweight=\"bold\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.io.img_tiles as cimgt\nfrom windrose import WindroseAxes\n\n# Define the basemap\nrequest = cimgt.OSM()\nextent = [-22.2543190362897, -21.3469394652069, 64.22114671, 64.41802068]\n\nextent2 = [-24.5, -13.5, 63.3, 66.6]\n\n# Create figure with GridSpec: 2 rows, 2 columns, with unequal widths\nfig = plt.figure(figsize=(14, 10))\ngs = fig.add_gridspec(2, 2, width_ratios=[2, 1], height_ratios=[1, 1], wspace=0.25, hspace=0.25)\n\n# --- Left column: Bathymetry maps ---\n\nax_map = fig.add_subplot(gs[0, 0], projection=request.crs)\nax_map.set_extent(extent2)\nax_map.add_image(request, 7)\nax_map.set_title(f\"Hvalfjörður Location\")\n\n\nax_bat = fig.add_subplot(gs[1, 0], projection=request.crs)\nax_bat.set_extent(extent)\nax_bat.add_image(request, 10)\nax_bat.set_title(f\"Hvalfjörður Bathymetry\")\n# Bathymetry contourf\ncf = ax_bat.contourf(\n     h_regrid.lon,\n     h_regrid.lat,\n     h_regrid.where(mask_regrid != 0),\n     transform=ccrs.PlateCarree(),\n      cmap=\"PuRd\"\n)\nax_bat.set_xticks([-22.2, -22.0, -21.8, -21.6, -21.4], crs=ccrs.PlateCarree())\nax_bat.set_yticks([64.24, 64.28, 64.32, 64.36, 64.40], crs=ccrs.PlateCarree())\nlon_formatter = cticker.LongitudeFormatter()\nlat_formatter = cticker.LatitudeFormatter()\nax_bat.xaxis.set_major_formatter(lon_formatter)\nax_bat.yaxis.set_major_formatter(lat_formatter)\n\n\ncbar = fig.colorbar(cf, ax=ax_bat, orientation=\"vertical\", shrink=0.7, pad=0.05)\ncbar.set_label(\"Depth (m)\")\n\n# --- Right column top: Sea level anomalies ---\npalette = plt.get_cmap('tab20')\nax_sea = fig.add_subplot(gs[0, 1])\nax_sea.set_title('Surface water anomalies (m) for July 2024')\nax_sea.plot(time, grundartangi[' Flodatafla (m)'], color=palette(1))\nax_sea.set_ylabel('m')\nplt.setp(ax_sea.get_xticklabels(), rotation=45, ha=\"right\")\n\n# --- Right column bottom: Wind rose ---\nax_wind = WindroseAxes(fig, gs[1, 1])\nfig.add_axes(ax_wind)  \nax_wind.bar(\n    grundartangi['Vindatt (deg)'],\n    grundartangi['Vindur (m/s)'],\n    normed=True, opening=0.8, edgecolor='white'\n)\nax_wind.set_legend()\nax_wind.set_title('Wind rose for July 2024')\n\nplt.show()\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.io.img_tiles as cimgt\nimport cartopy.mpl.ticker as cticker\nfrom matplotlib.patches import Rectangle\nfrom windrose import WindroseAxes\n\n# Define the basemap\nrequest = cimgt.OSM()\n\n# Extents\nextent_hval = [-22.2543190362897, -21.3469394652069, 64.25114671, 64.45802068]  # Hvalfjörður zoom\nextent_iceland = [-24.5, -13.5, 63.3, 66.6]  # Iceland\n\n# Create figure with GridSpec: 2 rows, 2 columns\nfig = plt.figure(figsize=(14, 10))\ngs = fig.add_gridspec(2, 2, width_ratios=[1, 1], height_ratios=[1, 1], wspace=0.25, hspace=0.25)\n\n# --- Top left: Iceland map with box ---\nax_map = fig.add_subplot(gs[0, 0], projection=request.crs)\nax_map.set_extent(extent_iceland)\nax_map.add_image(request, 7)\nax_map.set_title(\"Hvalfjörður Location\")\n\n# Add rectangle showing Hvalfjörður extent\nrect = Rectangle(\n    (extent_hval[0], extent_hval[2]),  # bottom-left corner (lon, lat)\n    extent_hval[1] - extent_hval[0],   # width (lon range)\n    extent_hval[3] - extent_hval[2],   # height (lat range)\n    linewidth=2, edgecolor='red', facecolor='none', transform=ccrs.PlateCarree()\n)\nax_map.add_patch(rect)\nax_map.text(\n    extent_hval[0], extent_hval[3] + 0.05,\n    \"Hvalfjörður\",\n    transform=ccrs.PlateCarree(),\n    fontsize=10, color='red', ha='left', va='bottom'\n)\n\n# --- Top right: Hvalfjörður Bathymetry ---\nax_bat = fig.add_subplot(gs[0, 1], projection=request.crs)\nax_bat.set_extent(extent_hval)\nax_bat.add_image(request, 10)\nax_bat.set_title(\"Hvalfjörður Bathymetry\")\n\n# Bathymetry contourf\ncf = ax_bat.contourf(\n    h_regrid.lon,\n    h_regrid.lat,\n    h_regrid.where(mask_regrid != 0),\n    transform=ccrs.PlateCarree(),\n    cmap=\"PuRd\"\n)\n\n# Format ticks\nax_bat.set_xticks([-22.2, -22.0, -21.8, -21.6, -21.4], crs=ccrs.PlateCarree())\nax_bat.set_yticks([64.24, 64.28, 64.32, 64.36, 64.40], crs=ccrs.PlateCarree())\nlon_formatter = cticker.LongitudeFormatter()\nlat_formatter = cticker.LatitudeFormatter()\nax_bat.xaxis.set_major_formatter(lon_formatter)\nax_bat.yaxis.set_major_formatter(lat_formatter)\n\n# Colorbar\ncbar = fig.colorbar(cf, ax=ax_bat, orientation=\"vertical\", shrink=0.7, pad=0.05)\ncbar.set_label(\"Depth (m)\")\n\n# --- Bottom left: Sea level anomalies ---\npalette = plt.get_cmap('tab20')\nax_sea = fig.add_subplot(gs[1, 0])\nax_sea.set_title(\"Surface water anomalies (m) for July 2024\")\nax_sea.plot(time, grundartangi[' Flodatafla (m)'], color=palette(1))\nax_sea.set_ylabel(\"m\")\nplt.setp(ax_sea.get_xticklabels(), rotation=45, ha=\"right\")\n\n# --- Bottom right: Wind rose ---\nax_wind = WindroseAxes(fig, gs[1, 1])\nfig.add_axes(ax_wind)\nax_wind.bar(\n    grundartangi['Vindatt (deg)'],\n    grundartangi['Vindur (m/s)'],\n    normed=True, opening=0.8, edgecolor=\"white\"\n)\nax_wind.set_legend()\nax_wind.set_title(\"Wind rose for July 2024\")\n\nplt.show()\n\n\n\n\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.io.img_tiles as cimgt\nimport cartopy.mpl.ticker as cticker\nfrom matplotlib.patches import Rectangle\nfrom windrose import WindroseAxes\n\n# Define the basemap\nrequest = cimgt.OSM()\n\n# Extents\nextent_hval = [-22.2543190362897, -21.3469394652069, 64.25114671, 64.45802068]  # Hvalfjörður zoom\nextent_iceland = [-24.5, -13.5, 63.3, 66.6]  # Iceland\n\n# Create figure with GridSpec: 2 rows, 2 columns\nfig = plt.figure(figsize=(14, 10))\ngs = fig.add_gridspec(2, 2, width_ratios=[1, 1], height_ratios=[1, 1], wspace=0.25, hspace=0.25)\n\n# --- Top left: Iceland map with box ---\nax_map = fig.add_subplot(gs[0, 0], projection=request.crs)\nax_map.set_extent(extent_iceland)\nax_map.add_image(request, 7)\nax_map.set_title(\"Hvalfjörður Location\")\n\n# Add rectangle showing Hvalfjörður extent\nrect = Rectangle(\n    (extent_hval[0], extent_hval[2]),  # bottom-left corner (lon, lat)\n    extent_hval[1] - extent_hval[0],   # width (lon range)\n    extent_hval[3] - extent_hval[2],   # height (lat range)\n    linewidth=2, edgecolor='red', facecolor='none', transform=ccrs.PlateCarree()\n)\nax_map.add_patch(rect)\nax_map.text(\n    extent_hval[0], extent_hval[3] + 0.05,\n    \"Hvalfjörður\",\n    transform=ccrs.PlateCarree(),\n    fontsize=10, color='red', ha='left', va='bottom'\n)\n\n# --- Top right: Hvalfjörður Bathymetry ---\nax_bat = fig.add_subplot(gs[0, 1], projection=request.crs)\nax_bat.set_extent(extent_hval)\nax_bat.add_image(request, 10)\nax_bat.set_title(\"Hvalfjörður Bathymetry\")\n\n# Bathymetry contourf\ncf = ax_bat.contourf(\n    h_regrid.lon,\n    h_regrid.lat,\n    h_regrid.where(mask_regrid != 0),\n    transform=ccrs.PlateCarree(),\n    cmap=\"PuRd\"\n)\n\n# Format ticks\nax_bat.set_xticks([-22.2, -22.0, -21.8, -21.6, -21.4], crs=ccrs.PlateCarree())\nax_bat.set_yticks([64.24, 64.28, 64.32, 64.36, 64.40], crs=ccrs.PlateCarree())\nlon_formatter = cticker.LongitudeFormatter()\nlat_formatter = cticker.LatitudeFormatter()\nax_bat.xaxis.set_major_formatter(lon_formatter)\nax_bat.yaxis.set_major_formatter(lat_formatter)\n\n# Colorbar\ncbar = fig.colorbar(cf, ax=ax_bat, orientation=\"vertical\", shrink=0.7, pad=0.05)\ncbar.set_label(\"Depth (m)\")\n\n# --- Bottom left: Sea level anomalies ---\npalette = plt.get_cmap('tab20')\nax_sea = fig.add_subplot(gs[1, 0])\nax_sea.set_title(\"Surface water anomalies (m) for July 2024\")\nax_sea.plot(time, grundartangi[' Flodatafla (m)'], color=palette(1))\nax_sea.set_ylabel(\"m\")\nplt.setp(ax_sea.get_xticklabels(), rotation=45, ha=\"right\")\n\n# --- Bottom right: Wind rose ---\nax_wind = WindroseAxes(fig, gs[1, 1])\nfig.add_axes(ax_wind)\nax_wind.bar(\n    grundartangi['Vindatt (deg)'],\n    grundartangi['Vindur (m/s)'],\n    normed=True, opening=0.8, edgecolor=\"white\"\n)\nax_wind.set_legend()\nax_wind.set_title(\"Wind rose for July 2024\")\n\nplt.show()\n\n\n\n\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.io.img_tiles as cimgt\nimport cartopy.mpl.ticker as cticker\nfrom matplotlib.patches import Rectangle\nfrom windrose import WindroseAxes\n\n# Define the basemap\nrequest = cimgt.OSM()\n\n# Extents\nextent_hval = [-22.2543190362897, -21.3469394652069, 64.25114671, 64.45802068]  # Hvalfjörður zoom\nextent_iceland = [-24.5, -13.5, 63.3, 66.6]  # Iceland\n\n# Create figure with GridSpec: 2 rows, 2 columns\nfig = plt.figure(figsize=(14, 10))\ngs = fig.add_gridspec(2, 2, width_ratios=[1, 1], height_ratios=[1, 1], wspace=0.25, hspace=0.25)\n\n# --- Top left: Iceland map with box ---\nax_map = fig.add_subplot(gs[0, 0], projection=request.crs)\nax_map.set_extent(extent_iceland)\nax_map.add_image(request, 7)\nax_map.set_title(\"Hvalfjörður Location\")\n\n# Add rectangle showing Hvalfjörður extent\nrect = Rectangle(\n    (extent_hval[0], extent_hval[2]),  # bottom-left corner (lon, lat)\n    extent_hval[1] - extent_hval[0],   # width (lon range)\n    extent_hval[3] - extent_hval[2],   # height (lat range)\n    linewidth=2, edgecolor='red', facecolor='none', transform=ccrs.PlateCarree()\n)\nax_map.add_patch(rect)\nax_map.text(\n    extent_hval[0], extent_hval[3] + 0.05,\n    \"Hvalfjörður\",\n    transform=ccrs.PlateCarree(),\n    fontsize=10, color='red', ha='left', va='bottom'\n)\n\n# Panel label\nax_map.text(0.02, 0.95, \"(a)\", transform=ax_map.transAxes,\n            fontsize=12, fontweight=\"bold\", va=\"top\", ha=\"left\")\n\n# --- Top right: Hvalfjörður Bathymetry ---\nax_bat = fig.add_subplot(gs[0, 1], projection=request.crs)\nax_bat.set_extent(extent_hval)\nax_bat.add_image(request, 10)\nax_bat.set_title(\"Hvalfjörður Bathymetry\")\n\n# Bathymetry contourf\ncf = ax_bat.contourf(\n    h_regrid.lon,\n    h_regrid.lat,\n    h_regrid.where(mask_regrid != 0),\n    transform=ccrs.PlateCarree(),\n    cmap=\"PuRd\"\n)\n\n# Mark Grundartangi\nax_bat.plot(-21.7825, 64.3572, marker=\"o\", color=\"red\", markersize=6,\n            transform=ccrs.PlateCarree())\nax_bat.text(-21.77, 64.36, \"Grundartangi\", color=\"red\", fontsize=9,\n            transform=ccrs.PlateCarree(), ha=\"left\", va=\"bottom\")\n\n# Format ticks\nax_bat.set_xticks([-22.2, -22.0, -21.8, -21.6, -21.4], crs=ccrs.PlateCarree())\nax_bat.set_yticks([64.26, 64.30, 64.34, 64.38, 64.42], crs=ccrs.PlateCarree())\nlon_formatter = cticker.LongitudeFormatter()\nlat_formatter = cticker.LatitudeFormatter()\nax_bat.xaxis.set_major_formatter(lon_formatter)\nax_bat.yaxis.set_major_formatter(lat_formatter)\n\n# Colorbar\ncbar = fig.colorbar(cf, ax=ax_bat, orientation=\"vertical\", shrink=0.7, pad=0.05)\ncbar.set_label(\"Depth (m)\")\n\n# Panel label\nax_bat.text(0.02, 0.95, \"(b)\", transform=ax_bat.transAxes,\n            fontsize=12, fontweight=\"bold\", va=\"top\", ha=\"left\")\n\n# --- Bottom left: Sea level anomalies ---\npalette = plt.get_cmap('tab20')\nax_sea = fig.add_subplot(gs[1, 0])\nax_sea.set_title(\"Surface water anomalies (m) for July 2024\")\nax_sea.plot(time, grundartangi[' Flodatafla (m)'], color=palette(1))\nax_sea.set_ylabel(\"m\")\nplt.setp(ax_sea.get_xticklabels(), rotation=45, ha=\"right\")\n\n# Panel label\nax_sea.text(0.02, 0.95, \"(c)\", transform=ax_sea.transAxes,\n            fontsize=12, fontweight=\"bold\", va=\"top\", ha=\"left\")\n\n# --- Bottom right: Wind rose ---\nax_wind = WindroseAxes(fig, gs[1, 1])\nfig.add_axes(ax_wind)\nax_wind.bar(\n    grundartangi['Vindatt (deg)'],\n    grundartangi['Vindur (m/s)'],\n    normed=True, opening=0.8, edgecolor=\"white\"\n)\nax_wind.set_legend()\nax_wind.set_title(\"Wind rose for July 2024\")\n\n# Panel label\nax_wind.text(0.02, 0.95, \"(d)\", transform=ax_wind.transAxes,\n             fontsize=12, fontweight=\"bold\", va=\"top\", ha=\"left\")\n\nplt.show()\n\n\n","type":"content","url":"/site-description","position":1},{"hierarchy":{"lvl1":"A comparison of model SSH and tidal gauge data"},"type":"lvl1","url":"/tidal-gauge-ssh-comparison","position":0},{"hierarchy":{"lvl1":"A comparison of model SSH and tidal gauge data"},"content":"import subprocess\nimport os\n\nimport netCDF4\nimport numpy as np\nimport glob\nimport time\nimport matplotlib.pyplot as plt\nimport copy\nimport xarray as xr\nfrom datetime import datetime, timedelta \nfrom roms_regrid import *\nfrom celluloid import Camera \nimport cartopy.crs as ccrs\nimport seawater as sw\nimport pandas as pd\n\n\n\nimport pandas as pd\nimport xarray as xr\n\n# Read file\nf='/home/x-uheede/R/HAFRO/Grundartangi_01012024-30122024.xlsx'\ngrundartangi = pd.read_excel(f, decimal=',')\n\n# Parse time\ntime = grundartangi['Timabil'].str.strip()\ntime = pd.to_datetime(time, format=\"%H:%M\\n%d.%m.%Y\", dayfirst=True)\n\n# Replace column\ngrundartangi['time'] = time\n\n# Set time as index (optional but recommended)\ngrundartangi = grundartangi.set_index('time')\n\n# Convert to xarray\nds = xr.Dataset.from_dataframe(grundartangi)\nds = ds.sortby(\"time\")\nds\n\n\n\n\ngrundartangi\n\n\n\nplt.plot(ds.time)\n\n\n\n\nmodel_grid_path=\"/home/x-uheede/S/Iceland2_MARBL_2024_60m/P_INPUT/Iceland2_grid_MAT1.nc\"\n# Grid parameters, only modify these if grid is made in MATLAB\nvert_levels=60\ntheta_s_model=5\ntheta_b_model=2\nhc_model=300\nmodel_data_path=\"/anvil/scratch/x-uheede/Iceland2_NOMARBL_2024_RHALF/Iceland2_MARBL_2024_his.20240?????????.nc\"\n\n\n\n\nfrom roms_tools import Grid, ROMSOutput\ngrid = Grid.from_file(\n    model_grid_path\n)\n\n\n\n\n#Only run this cell if grid is made in MATLAB\ngrid.update_vertical_coordinate(N=vert_levels, theta_s=theta_s_model, theta_b=theta_b_model, hc=hc_model, verbose=False)\n\n\n\nimport xarray as xr\nimport numpy as np\ntarget_depth_levels=[1,2,3,4,5,7,9,10,12,14,15,16,18,20,26,30,36,40,50,80] # Specify depth levels of interest\n# Load ROMS output using your pattern\nroms_output = ROMSOutput(\n    grid=grid,\n    path=[\n        model_data_path,\n    ],\n    use_dask=True,\n)\n\nds_model = roms_output.regrid(var_names=[\"zeta\"])\n\n\n\nds_model.load()\n\n\n\n# Identify duplicates in the time coordinate\nduplicates = ds_model['time'].to_index().duplicated()\n\n# Drop duplicate time steps\nds_model_unique = ds_model.sel(time=~duplicates)\n\n\n\n\nplt.figure(figsize=(14,5))\nplt.plot(ds[\"time\"].sel(time=slice('2024-06-01','2024-07-31')), ds[\"Flodtafla (m)\"].sel(time=slice('2024-06-01','2024-07-31')), color=\"steelblue\")\nplt.title(\"Sea Surface Height (Flodtafla) — Timeseries\")\nplt.xlabel(\"Time\")\nplt.ylabel(\"Sea Surface Height (m)\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\n\n\nimport matplotlib.pyplot as plt\n\n#64.358799°N 21.769334°W\n\n# Convert lon_W to 0–360 range\nlon_target = 360 - 21.769334   # = 338.2242\nlat_target = 64.358799\n\n# Select nearest model grid point for zeta\nzeta_point = ds_model_unique[\"zeta\"].sel(\n    lon=lon_target, \n    lat=lat_target, \n    method=\"nearest\"\n)\n\n# Select same time window\nt0, t1 = \"2024-04-01\", \"2024-08-15\"\n\nssh_obs = ds[\"Flodtafla (m)\"].sel(time=slice(t0, t1))\nssh_time = ds[\"time\"].sel(time=slice(t0, t1))\n\nzeta_mod = zeta_point.sel(time=slice(t0, t1))\n\n\n# -------------------------------\n# 2-panel figure\n# -------------------------------\nfig, (ax1, ax2) = plt.subplots(\n    2, 1, figsize=(15, 8), sharex=True,\n    gridspec_kw={\"height_ratios\": [1, 1]}\n)\n\n# -------------------------------------\n# Panel 1 — Observed Flodtafla\n# -------------------------------------\nax1.plot(ssh_time, ssh_obs, color=\"steelblue\")\nax1.set_title(\"Observed Sea-surface Height (tidal gauge)\")\nax1.set_ylabel(\"SSH (m)\")\nax1.grid(True)\n\n# -------------------------------------\n# Panel 2 — Modeled zeta\n# -------------------------------------\nax2.plot(zeta_mod[\"time\"], zeta_mod, color=\"darkorange\")\nax2.set_title(\n    f\"Modeled Sea-surface Height (zeta)\\n(lat={lat_target:.4f}°, lon={lon_target:.4f}°)\"\n)\nax2.set_ylabel(\"SSH (m)\")\nax2.set_xlabel(\"Time\")\nax2.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nimport matplotlib.pyplot as plt\n\n# 64.358799°N 21.769334°W\n\n# Convert lon_W to 0–360 range\nlon_target = 360 - 21.769334   # = 338.230666\nlat_target = 64.358799\n\n# Select nearest model grid point for zeta\nzeta_point = ds_model_unique[\"zeta\"].sel(\n    lon=lon_target, \n    lat=lat_target, \n    method=\"nearest\"\n)\n\n# Select same time window\nt0, t1 = \"2024-04-01\", \"2024-08-15\"\n\nssh_obs = ds[\"Flodtafla (m)\"].sel(time=slice(t0, t1))\nssh_time = ds[\"time\"].sel(time=slice(t0, t1))\n\nzeta_mod = zeta_point.sel(time=slice(t0, t1))\n\n\n# --------------------------------------------------------\n# Compute mean SSH for observations and model\n# --------------------------------------------------------\nmean_obs = float(ssh_obs.mean())\nmean_mod = float(zeta_mod.mean())\n\n# Compute offset so means match\noffset = mean_obs - mean_mod\n\nprint(\"Mean observed SSH  :\", mean_obs)\nprint(\"Mean modeled SSH   :\", mean_mod)\nprint(\"Vertical offset Δ  :\", offset)\n\n# Apply correction\nzeta_mod_corrected = zeta_mod + offset\n\n\n# --------------------------------------------------------\n# Plot 2-panel figure\n# --------------------------------------------------------\nfig, (ax1, ax2) = plt.subplots(\n    2, 1, figsize=(15, 8), sharex=True,\n    gridspec_kw={\"height_ratios\": [1, 1]}\n)\n\n# -------------------------------------\n# Panel 1 — Observed Flodtafla\n# -------------------------------------\nax1.plot(ssh_time, ssh_obs, color=\"steelblue\")\nax1.set_title(\"Observed Sea-surface Height (tidal gauge)\")\nax1.set_ylabel(\"SSH (m)\")\nax1.grid(True)\n\n# -------------------------------------\n# Panel 2 — Modeled zeta (mean-corrected)\n# -------------------------------------\nax2.plot(zeta_mod_corrected[\"time\"], zeta_mod_corrected, color=\"darkorange\")\nax2.set_title(\n    f\"Modeled Sea-surface Height (zeta) — Mean Adjusted\\n\"\n    f\"(lat={lat_target:.4f}°, lon={lon_target:.4f}°)\"\n)\nax2.set_ylabel(\"SSH (m)\")\nax2.set_xlabel(\"Time\")\nax2.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n","type":"content","url":"/tidal-gauge-ssh-comparison","position":1},{"hierarchy":{"lvl1":"Grid overview"},"type":"lvl1","url":"/grid-overview","position":0},{"hierarchy":{"lvl1":"Grid overview"},"content":"an overview of the nested grids used to establish the Hvalfjordur domain\n\nimport xarray as xr\n\n\n\ngrid0=xr.open_dataset('/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_s2r_phys+bgc/1.Make_grid/Iceland0_grid_MAT.nc')\ngrid1=xr.open_dataset('/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_r2r_phys+bgc/1.Make_grid/Iceland1_grid_MAT1.nc')\ngrid2=xr.open_dataset('/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_r2r_phys+bgc/1.Make_grid/Iceland2_grid_MAT1.nc')\ngrid3=xr.open_dataset('/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_r2r_phys+bgc/1.Make_grid/Iceland3_grid_MAT.nc')\n\n\n\n\ngrid0.load()\ngrid1.load()\ngrid2.load()\ngrid3.load()\n\n\n\nimport xarray as xr\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport numpy as np\n\n# === USER SETTINGS ===\n# Replace with your actual grid file paths\ngrid_files = [\n    \"/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_s2r_phys+bgc/1.Make_grid/Iceland0_grid_MAT.nc\",\n    \"/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_r2r_phys+bgc/1.Make_grid/Iceland1_grid_MAT1.nc\",\n    \"/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_r2r_phys+bgc/1.Make_grid/Iceland2_grid_MAT1.nc\",\n    \"/anvil/projects/x-ees250129/x-uheede/MATLAB/setup_r2r_phys+bgc/1.Make_grid/Iceland3_grid_MAT.nc\",\n]\n\n# === HELPER FUNCTION ===\ndef get_grid_outline(ds):\n    \"\"\"Extracts the outer boundary of a ROMS grid from lon/lat.\"\"\"\n    lon = ds.lon_rho.values\n    lat = ds.lat_rho.values\n\n    # Corners of the grid\n    left   = np.column_stack((lon[:, 0], lat[:, 0]))\n    right  = np.column_stack((lon[:, -1], lat[:, -1]))\n    bottom = np.column_stack((lon[0, :], lat[0, :]))\n    top    = np.column_stack((lon[-1, :], lat[-1, :]))\n\n    # Combine into a closed loop\n    boundary = np.vstack((bottom, right, top[::-1], left[::-1]))\n    return boundary\n\n# === PLOTTING ===\nfig = plt.figure(figsize=(10, 8))\nproj = ccrs.PlateCarree()\nax = plt.axes(projection=proj)\n\n# Add coastlines and features\n#ax.add_feature(cfeature.COASTLINE, linewidth=0.7)\n#ax.add_feature(cfeature.LAND, facecolor=\"lightgray\", zorder=0)\n#ax.gridlines(draw_labels=True, linewidth=0.3, color=\"gray\", alpha=0.5)\n\n# Define colors for each grid outline\ncolors = ['red', 'orange', 'green', 'blue']\n\n# Loop through grid files\n\nds = xr.open_dataset(grid_files[0])\nboundary = get_grid_outline(ds)\nax.plot(boundary[:, 0], boundary[:, 1], color=colors[i],\nlinewidth=2, label=f\"Grid {i+1}: {f}\")\n\n# Set extent automatically to fit all grids\n#all_lons = []\n#all_lats = []\n#for f in grid_files:\n#    ds = xr.open_dataset(f)\n#    all_lons.append(ds.lon_rho.values)\n#    all_lats.append(ds.lat_rho.values)\n\n#lon_min = np.min([np.min(lon) for lon in all_lons])\n#lon_max = np.max([np.max(lon) for lon in all_lons])\n#lat_min = np.min([np.min(lat) for lat in all_lats])\n#lat_max = np.max([np.max(lat) for lat in all_lats])\n#ax.set_extent([lon_min - 1, lon_max + 1, lat_min - 1, lat_max + 1])\n\n# Add legend\nax.legend(loc='lower left', fontsize=8)\n\nplt.title(\"Nested ROMS Grid Outlines\", fontsize=12)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\nds0 = xr.open_dataset(grid_files[0])\nboundary0 = get_grid_outline(ds0)\n\nds1 = xr.open_dataset(grid_files[1])\nboundary1 = get_grid_outline(ds1)\n\nds2 = xr.open_dataset(grid_files[2])\nboundary2 = get_grid_outline(ds2)\n\nds3 = xr.open_dataset(grid_files[3])\nboundary3 = get_grid_outline(ds3)\n\n\n\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\n\n# Example: boundary is an Nx2 array (lon, lat)\n# boundary = np.array([[lon1, lat1], [lon2, lat2], ...])\n\n# Create a Cartopy map with a PlateCarree projection (suitable for lon/lat)\nfig = plt.figure(figsize=(8, 6))\nax = plt.axes(projection=ccrs.Mercator())\n\n# Add coastlines and features for context\nax.coastlines()\nax.add_feature(cfeature.BORDERS, linestyle=':')\nax.add_feature(cfeature.LAND, facecolor='lightgray')\n\n# Plot the boundary line\nax.plot(boundary0[:, 0], boundary0[:, 1], '-y', transform=ccrs.PlateCarree(), label='Iceland0, 2.5 km resolution')\nax.plot(boundary1[:, 0], boundary1[:, 1], '-g', transform=ccrs.PlateCarree(), label='Iceland1, 750 m resolution')\nax.plot(boundary2[:, 0], boundary2[:, 1], '-b', transform=ccrs.PlateCarree(), label='Iceland2, 200 m resolution')\nax.plot(boundary3[:, 0], boundary3[:, 1], '-r', transform=ccrs.PlateCarree(), label='Iceland3, 50 m resolution')\n\n# Optionally set map extent to fit your data\nax.set_extent([boundary0[:,0].min()-1, boundary0[:,0].max()+1,\n               boundary0[:,1].min()-1, boundary0[:,1].max()+1],\n              crs=ccrs.PlateCarree())\n\nax.legend(loc='lower right')\nplt.title(\"Nested grids overview\")\nplt.show()\n\n\n","type":"content","url":"/grid-overview","position":1},{"hierarchy":{"lvl1":"Introduction"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Introduction"},"content":"This is a collection of notebooks that sets up a domain in Hvalfjordur, Iceland using ROMS-TOOLS and conducts a model-observation comparison.A figure of a photograph of some mountains, followed by a caption\n\n\n\nFigure 1:A photograph of Hvalfjordur, Iceland. July 2024","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/pipe-movie-withmap","position":0},{"hierarchy":{"lvl1":""},"content":"import subprocess\nimport os\n\nimport netCDF4\nimport numpy as np\nimport glob\nimport time\nimport matplotlib.pyplot as plt\nimport copy\nimport xarray as xr\nfrom datetime import datetime, timedelta \nfrom roms_regrid import *\nfrom celluloid import Camera \nimport cartopy.crs as ccrs\nimport seawater as sw\n\n\n\ngrid=xr.open_dataset('/global/cfs/cdirs/m4632/uheede/work/Iceland4_BGC/INPUT/Iceland4_grd.nc')\ngrid_pr=grid\nh=grid['h'].values\nmask_rho=grid['mask_rho'].values\npm=grid['pm'].values\npn=grid['pn'].values\n\n\n\ngrid['h']\n\n\n\nx1=xr.open_mfdataset('/pscratch/sd/u/uheede/Iceland4_noBGC_pip_pt_FLOW/Iceland4_noBGC_FLOW_rnd.201206[2-3][1-9]??0000.nc', combine='nested', concat_dim=[\"time\"])\n#x2=xr.open_mfdataset('/pscratch/sd/u/uheede/Iceland4_noBGC_pip_pt_ens1/Iceland4_noBGC_ens1_rnd.201206*.nc', combine='nested', concat_dim=[\"time\"])\n#x3=xr.open_mfdataset('/pscratch/sd/u/uheede/Iceland4_noBGC_pip_pt_ens2/Iceland4_noBGC_ens2_rnd.2012062[1-6]*.nc', combine='nested', concat_dim=[\"time\"])\n\n\n\n\n\nmask_regrid=roms_regrid(grid,grid['mask_rho'])\n\n\n\n\n## calculating depth of each cell\nmask_rho=grid['mask_rho'].values\nh=grid['h'].values\n# Sigma coordinate parameters\nN = 100\ntheta_s = 5\ntheta_b = 2\nhc = 300\n\nk_w = np.linspace(0,N,N+1)\nk_r = np.linspace(1,N,N)\n\nsigma_w = (k_w - N) / N\nsigma_r = (k_r - N - 0.5) / N\n\n# Assuming that theta_s and theta_b are both > 0\n# https://www.myroms.org/wiki/Vertical_S-coordinate\n\ndef Cs(sigma, theta_s, theta_b):\n    C = ( 1 - np.cosh(theta_s * sigma) ) / (np.cosh(theta_s) - 1)\n    C = (np.exp(theta_b * C) - 1) / (1 - np.exp(-theta_b))\n    return C\n\nCs_w = Cs(sigma_w, theta_s, theta_b)\nCs_r = Cs(sigma_r, theta_s, theta_b)\n\nS_w = np.zeros((N+1, h.shape[0], h.shape[1]))\nS_r = np.zeros((N, h.shape[0], h.shape[1]))\nfor i in range(h.shape[0]):\n    for j in range(h.shape[1]):\n        if mask_rho[i,j]:\n            S_w[:,i,j] = (hc * sigma_w + h[i,j]*Cs_w) / (hc + h[i,j])\n            S_r[:,i,j] = (hc * sigma_r + h[i,j]*Cs_r) / (hc + h[i,j])\n\n# zeta is the sea surface height at any given time, here I am using an arbitrary zeta\n\nzeta1=x1['zeta'].isel(time=95).load().values\n\nz_w1 = np.zeros((N+1, h.shape[0], h.shape[1]))\nz_r1 = np.zeros((N, h.shape[0], h.shape[1]))\n\n#zeta2=x2['zeta'].isel(time=48).load().values\n\n#z_w2 = np.zeros((N+1, h.shape[0], h.shape[1]))\n#z_r2 = np.zeros((N, h.shape[0], h.shape[1]))\n\n#zeta3=x3['zeta'].isel(time=48).load().values\n\n#z_w3 = np.zeros((N+1, h.shape[0], h.shape[1]))\n#z_r3 = np.zeros((N, h.shape[0], h.shape[1]))\n\nfor i in range(h.shape[0]):\n    for j in range(h.shape[1]):\n        if mask_rho[i,j]:\n            z_w1[:,i,j] = zeta1[i,j] + (zeta1[i,j] + h[i,j])*S_w[:,i,j]\n            z_r1[:,i,j] = zeta1[i,j] + (zeta1[i,j] + h[i,j])*S_r[:,i,j]\n            #z_w2[:,i,j] = zeta2[i,j] + (zeta2[i,j] + h[i,j])*S_w[:,i,j]\n            #z_r2[:,i,j] = zeta2[i,j] + (zeta2[i,j] + h[i,j])*S_r[:,i,j]\n            #z_w3[:,i,j] = zeta3[i,j] + (zeta3[i,j] + h[i,j])*S_w[:,i,j]\n            #z_r3[:,i,j] = zeta3[i,j] + (zeta3[i,j] + h[i,j])*S_r[:,i,j]\ncell_depths1 = np.zeros((N, h.shape[0], h.shape[1]))\n#cell_depths2 = np.zeros((N, h.shape[0], h.shape[1]))\n#cell_depths3 = np.zeros((N, h.shape[0], h.shape[1]))\n\n\nfor k in np.arange(1,101):\n    cell_depths1[k-1,:,:]=z_w1[k,:,:]-z_w1[k-1,:,:]\n    #cell_depths2[k-1,:,:]=z_w2[k,:,:]-z_w2[k-1,:,:]\n    #cell_depths3[k-1,:,:]=z_w3[k,:,:]-z_w3[k-1,:,:]\n    \n\n\n\ndye1_3d=x1['dye'].isel(time=95).load()\n\n\nmass1=dye1_3d*1/pn*1/pm*cell_depths1\n#mass2=dye2_3d*1/pn*1/pm*cell_depths2\n#mass3=dye3_3d*1/pn*1/pm*cell_depths3\n\ntotal1=np.sum(mass1.load()) #m3\n#total2=np.sum(mass2.load()) #m3\n#total3=np.sum(mass3.load()) #m3\n\nNaOH_test1=9.975*10**3*1000*20 #(mol/L)*1000 (mmol/mol)*1000(L/IBC)*20(IBC)=mmol\nNaOH_test2=9.975*10**3*1000*10\nNaOH_test3=9.975*10**3*1000*5\nNaOH_test4=9.975*10**3*1000*30\n\nalk1_scalar1=NaOH_test1*(1/total1) #mmol/m3\nalk1_scalar2=NaOH_test2*(1/total1)\nalk1_scalar3=NaOH_test3*(1/total1)\nalk1_scalar4=NaOH_test4*(1/total1)\n\n#alk2_scalar1=NaOH_test1*(1/total2) #mmol/m3\n#alk2_scalar2=NaOH_test2*(1/total2)\n#alk2_scalar3=NaOH_test3*(1/total2)\n#alk2_scalar4=NaOH_test4*(1/total2)\n\n#alk3_scalar1=NaOH_test1*(1/total3) #mmol/m3\n#alk3_scalar2=NaOH_test2*(1/total3)\n#alk3_scalar3=NaOH_test3*(1/total3)\n#alk3_scalar4=NaOH_test4*(1/total3)\n\n\n\ndye1_alk1=x1['dye']*alk1_scalar1\ndye1_alk2=x1['dye']*alk1_scalar2\ndye1_alk3=x1['dye']*alk1_scalar3\ndye1_alk4=x1['dye']*alk1_scalar4\n\n\n\n\ndye_alk_surf=dye1_alk4.isel(s_rho=99)\ndye1_alk4_rg=roms_regrid(grid,dye_alk_surf)\n\n\n\ndye1_alk4_rg.load()\n\n\n\nimport cartopy.io.img_tiles as cimgt\n\nrequest = cimgt.OSM()\nextent = [-21.6, -21.35, 64.325, 64.42]\n\nfrom matplotlib import pyplot as plt\nfrom celluloid import Camera\nfrom IPython.display import HTML\n\nfig, ax = plt.subplots(figsize=(7,7),subplot_kw={'projection': ccrs.Mercator()},layout='tight')\ncamera = Camera(fig)\nax = plt.axes(projection=request.crs)\nax.set_extent(extent)\n\nax.add_image(request, 12)\nk1=1\nk2=580\nk3=5\nlevels=np.arange(k1, k2, k3)\n   \n\nlevels2=np.arange(0, 10, 1)\n\nfor i in range(167):\n    \n    ax.text(0.8, 0.999, 't='+str(i+1)+' hours', transform=ax.transAxes)\n\n    cf2=plt.contourf(dye1_alk4_rg.lon,dye1_alk4_rg.lat,mask_regrid.where(mask_regrid!=0),levels2, cmap='Greys', transform=ccrs.PlateCarree())\n    \n    cf1=plt.contourf(dye1_alk4_rg.lon,dye1_alk4_rg.lat,dye1_alk4_rg[i,:,:],levels, vmin=1, vmax=70,transform=ccrs.PlateCarree())\n\n    \n    camera.snap()\n\n    plt.title('fixed point source 96 hr release')\n    \nax.scatter(-21.465, 64.396, color=\"black\", marker=\"v\", transform=ccrs.PlateCarree(),label= \"release point\")\ngls=ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True,\n                    color='darkgray', alpha=0.5, linestyle='--')\ngls.top_labels=False   # suppress top labels\ngls.right_labels=False # suppress right labels\n\nax.set_extent([-21.6, -21.35, 64.325, 64.42], ccrs.PlateCarree())\nax.legend()\ncb1 = plt.colorbar(cf1,shrink=0.3)\ncb1.set_label('mmol/m$^3$ surf. alk', fontsize=10)\n\nanimation = camera.animate()\nHTML(animation.to_html5_video())\n\n\n\n\n\nanimation.save(\"96_hr_30IBC_withmap.mp4\")\n\n\n\ndye1_alk4_rg.shape\n\n","type":"content","url":"/pipe-movie-withmap","position":1},{"hierarchy":{"lvl1":"Velocity model-obs(ADCP) comparison"},"type":"lvl1","url":"/velocity-analysis-200m-copy1","position":0},{"hierarchy":{"lvl1":"Velocity model-obs(ADCP) comparison"},"content":"\n\n","type":"content","url":"/velocity-analysis-200m-copy1","position":1},{"hierarchy":{"lvl1":"Velocity model-obs(ADCP) comparison"},"type":"lvl1","url":"/velocity-analysis-200m-copy1#velocity-model-obs-adcp-comparison","position":2},{"hierarchy":{"lvl1":"Velocity model-obs(ADCP) comparison"},"content":"\n\nimport subprocess\nimport os\nimport pandas as pd\nimport netCDF4\nimport numpy as np\nimport glob\nimport time\nimport matplotlib.pyplot as plt\nimport copy\nimport xarray as xr\nfrom datetime import datetime, timedelta \nimport dask\nfrom scipy.interpolate import griddata\n#from ocean_c_lab_tools import *\n#from celluloid import Camera \n#import PyCO2SYS as csys\nimport seawater as sw\nfrom roms_regrid import *\n\n\n\nHAFRO_path='/home/x-uheede/R/HAFRO/Hafro_cruises.xls'\nmodel_grid_path=\"/home/x-uheede/S/Iceland2_MARBL_2024_60m/P_INPUT/Iceland2_grid_MAT1.nc\"\n# Grid parameters, only modify these if grid is made in MATLAB\nvert_levels=60\ntheta_s_model=5\ntheta_b_model=2\nhc_model=300\nmodel_data_path=\"/home/x-uheede/S/Iceland2_NOMARBL_2024_NewV/Iceland2_MARBL_2024_his.20240[4]????????.nc\"\nmonths_analysis=[4] # enter the months you want to analyze for the model\n# enter the dates you want to analyze for the observations\ntarget_depth_levels=[10] # Specify depth levels of interest\nthinner=1 # specify the temporal frequency of data being read (i.e. no need to read in hourly data)\n\n\n\n\nfrom roms_tools import Grid, ROMSOutput\ngrid = Grid.from_file(\n    model_grid_path\n)\n\n\n\n\n#Only run this cell if grid is made in MATLAB\ngrid.update_vertical_coordinate(N=vert_levels, theta_s=theta_s_model, theta_b=theta_b_model, hc=hc_model, verbose=False)\n\n\n\n\n\n# Define file paths and station names\nstations = [\"HVIN_1\", \"HVNA_1\", \"HVNV_1\", \"HVSA_1\", \"HVSV_1\"]\nfile_paths = {name: f\"/home/x-uheede/R/HAFRO/{name}new.nc\" for name in stations}\n\n# Dictionary to store datasets\ndatasets = {}\n\nfor name, path in file_paths.items():\n    ds = xr.open_dataset(path)\n\n    # Select valid depth bins\n    good_bins = ds['iigood'].where(ds['iigood'] < 20).to_numpy()\n    good_bins_nn = good_bins[~np.isnan(good_bins)].astype(int)\n    \n    ds = ds.isel(depth_dim=slice(np.min(good_bins_nn), np.max(good_bins_nn)))\n\n    # Store dataset with adjusted longitude\n    datasets[name] = ds.assign_coords(lon=ds['lon'].load() + 360)\n\n\n\n\n\n\n\nsubtract = 739674 - 9189  # Computed constant\nreference_date = pd.to_datetime(\"2000-01-01\")  # Reference date\n\n# Apply transformation to all datasets\nfor name, ds in datasets.items():\n    datetime_series = reference_date + pd.to_timedelta((ds['time'].values - subtract), unit='D')\n    datasets[name] = ds.assign_coords(time_dim=datetime_series)  # Update the time coordinate\n\n\n\n\nfrom roms_tools import Grid, ROMSOutput\n\n\n\nimport xarray as xr\nimport numpy as np\n\n# Load ROMS output using your pattern\nroms_output = ROMSOutput(\n    grid=grid,\n    path=[\n        model_data_path,\n    ],\n    use_dask=True,\n)\n\nds = roms_output.regrid(var_names=[\"u\", \"v\"],depth_levels=target_depth_levels)\n\n\n\nu_rg=ds['u'].load()\nv_rg=ds['v'].load()\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport xarray as xr\nfrom windrose import WindroseAxes\n\n# Define the number of stations\nnum_stations = 5\n\n# Define the observation subset time range (2024)\nobs_time_range = slice('2024-05-01', '2024-05-31')\n\n# Define the model subset time range (2023)\nmodel_time_range = slice('2024-02-01', '2024-02-28')\n\n# Create figure for timeseries plots\nfig, axs = plt.subplots(\n    nrows=num_stations, ncols=2, figsize=(12, 3 * num_stations), sharex=False\n)\nfig.suptitle(\"Timeseries Comparison: Observations vs Model\", fontsize=14)\n\nfor i in range(num_stations):\n\n    # Subset observation data for 2024\n    obs = list(datasets.values())[i]\n    obs_subset = obs.sel(time_dim=obs_time_range)\n    depth_index = (np.abs(obs_subset['depth_dim'].values - 10)).argmin()\n    u_obs = obs_subset['u'].isel(depth_dim=depth_index)[::6]\n    obs_lon = obs.lon\n    obs_lat = obs.lat\n\n    # Extract model data\n    u_sel = u_rg.sel(lon=obs_lon.values, method='nearest').sel(lat=obs_lat.values, method='nearest')\n    u_mod = u_sel.squeeze()\n\n    # ----------------------------\n    # Compute shared y-limits\n    # ----------------------------\n    ymin = min(u_obs.min().item(), u_mod.min().item())\n    ymax = max(u_obs.max().item(), u_mod.max().item())\n\n    # Add small padding\n    yrange = ymax - ymin\n    ymin -= 0.05 * yrange\n    ymax += 0.05 * yrange\n\n    # Plot observations (2024)\n    axs[i, 0].plot(obs_subset.time_dim[::6], u_obs, label=\"Observed U (2024)\", color=\"blue\")\n    axs[i, 0].set_title(f\"Station {i+1} - Observations (2024)\")\n    axs[i, 0].tick_params(axis='x', rotation=45)\n    axs[i, 0].set_ylim([ymin, ymax])\n    axs[i, 0].legend()\n\n    # Plot model (2023)\n    axs[i, 1].plot(u_rg['time'], u_mod, label=\"Model U (2024)\", color=\"green\")\n    axs[i, 1].set_title(f\"Station {i+1} - Model (2023)\")\n    axs[i, 1].tick_params(axis='x', rotation=45)\n    axs[i, 1].set_ylim([ymin, ymax])\n    axs[i, 1].legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nobs.lat\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom windrose import WindroseAxes\n\n# Define number of stations\nnum_stations = 5\n\n# Create a figure with 2 columns (Obs & Model) and num_stations rows\nfig = plt.figure(figsize=(14, 7 * num_stations),layout='tight')\n\nfig.suptitle(\"Wind Roses: Observations (2024) vs Model (2024)\", fontsize=16)\n\nfor i in range(num_stations):\n\n    # Compute observed wind speed and direction\n    obs=list(datasets.values())[i]\n    obs_subset = obs.sel(time_dim=obs_time_range)\n    depth_index = (np.abs(obs_subset['depth_dim'].values - 10)).argmin()\n    u_obs = obs_subset['u'].sel(depth_dim=depth_index)[::6]\n    v_obs = obs_subset['v'].sel(depth_dim=depth_index)[::6]\n    obs_lon=obs.lon\n    obs_lat=obs.lat\n    direction_obs = (np.arctan2(-u_obs.squeeze().values, -v_obs.squeeze().values) * (180 / np.pi) + 360) % 360\n    speed_obs = np.sqrt(u_obs.squeeze().values**2 + v_obs.squeeze().values**2)\n\n    # Compute model wind speed and direction\n    u_sel = u_rg.sel(lon=obs_lon.values, method='nearest').sel(lat=obs_lat.values, method='nearest')\n    v_sel = v_rg.sel(lon=obs_lon.values, method='nearest').sel(lat=obs_lat.values, method='nearest')\n    \n    direction_model = (np.arctan2(-u_sel.squeeze().values, -v_sel.squeeze().values) * (180 / np.pi) + 360) % 360\n    speed_model = np.sqrt(u_sel.squeeze().values**2 + v_sel.squeeze().values**2)\n\n    # Define subplot positions using bbox (left, bottom, width, height)\n    ax_obs = WindroseAxes(fig, [0.05, 0.75 - (i * 0.2), 0.4, 0.18])  # Left column\n    fig.add_axes(ax_obs)\n    ax_obs.bar(direction_obs, speed_obs, normed=True, opening=0.8, edgecolor='white', bins=np.linspace(0, 0.6, 7))\n    ax_obs.set_title(f\"Station {i+1} - Obs (2024)\", fontsize=12)\n    ax_obs.set_legend()\n    ax_obs.set_rticks([5, 10, 15, 20, 25, 30])\n    ax_obs.set_yticklabels(['5%', '10%', '15%', '20%', '25%', '30%'])\n    \n    ax_model = WindroseAxes(fig, [0.55, 0.75 - (i * 0.2), 0.4, 0.18])  # Right column\n    fig.add_axes(ax_model)\n    ax_model.bar(direction_model, speed_model, normed=True, opening=0.8, edgecolor='white', bins=np.linspace(0, 0.6, 7))\n    ax_model.set_title(f\"Station {i+1} - Model (2024)\", fontsize=12)\n    ax_model.set_legend()\n    ax_model.set_rticks([5, 10, 15, 20, 25, 30])\n    ax_model.set_yticklabels(['5%', '10%', '15%', '20%', '25%', '30%'])\n\nplt.show()\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\n\ndef compute_spectrum(time, signal):\n    \"\"\"Compute the FFT and identify spectral peaks.\"\"\"\n    \n    # Compute FFT\n    n = len(signal)\n    dt = np.mean(np.diff(time))  # Time step (assuming uniform spacing)\n    freq = np.fft.rfftfreq(n, d=dt)  # Compute frequency axis\n    spectrum = np.fft.rfft(signal)   # Compute FFT\n    power = np.abs(spectrum)**2      # Compute Power Spectral Density (PSD)\n    \n    # Find peaks in the power spectrum\n    peaks, _ = find_peaks(power, height=np.max(power) * 0.1)  # Peaks with at least 10% of max power\n    \n    return freq, power, peaks\nreference_time = np.datetime64('2000-01-01T00:00:00', 's')\n\n# Example time series (Replace these with your observed and modeled data)\nobs_time = (obs_subset.time_dim[::6].load() - reference_time).astype('timedelta64[h]').astype(int).load().values\n# Define reference time (2000-01-01T00:00:00)\n\n\n\nmodel_time = (u_rg['time'].load() - reference_time).astype('timedelta64[h]').astype(int).load().values# Example time axis (modify as needed)\nobs_time=(obs_time-obs_time[0])*10**(-0)*1/3600\nmodel_time=(model_time-model_time[0])*10**(-0)*1/3600\n\nobserved_signal = u_obs.squeeze().values  # Example signal\nmodeled_signal = u_sel.squeeze().values # Example signal\n\n# Compute spectra\nfreq_obs, power_obs, peaks_obs = compute_spectrum(obs_time, observed_signal)\nfreq_mod, power_mod, peaks_mod = compute_spectrum(model_time, modeled_signal)\n\n# Plot results\nplt.figure(figsize=(10, 5))\n\n# Observed Spectrum\nplt.plot(freq_obs, power_obs, label=\"Observed Spectrum\", color='b')\nplt.scatter(freq_obs[peaks_obs], power_obs[peaks_obs], color='r', label=\"Observed Peaks\", zorder=3)\n\n# Modeled Spectrum\nplt.plot(freq_mod, power_mod, label=\"Modeled Spectrum\", color='g', linestyle='dashed')\nplt.scatter(freq_mod[peaks_mod], power_mod[peaks_mod], color='orange', label=\"Modeled Peaks\", zorder=3)\n\nplt.xlabel(\"Frequency (hr$^{-1}$)\")\nplt.ylabel(\"Power\")\nplt.legend()\nplt.title(\"Spectral Peaks in Observed and Modeled Data\")\nplt.grid()\nplt.show()\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\n\n# Convert frequency to period (avoid division by zero)\nperiod_obs = 1 / freq_obs[1:]  # Ignore first value to avoid division by zero\nperiod_mod = 1 / freq_mod[1:]\n\n# Plot results\nplt.figure(figsize=(10, 5))\n\n# Observed Spectrum\nplt.plot(period_obs, power_obs[1:], label=\"Observed Spectrum\", color='b')\n#plt.scatter(period_obs[peaks_obs - 1], power_obs[peaks_obs][1:], color='r', label=\"Observed Peaks\", zorder=3)\n\n# Modeled Spectrum\nplt.plot(period_mod, power_mod[1:], label=\"Modeled Spectrum\", color='g', linestyle='dashed')\n#plt.scatter(period_mod[peaks_mod - 1], power_mod[peaks_mod][1:], color='orange', label=\"Modeled Peaks\", zorder=3)\n\n#plt.xscale(\"log\")  # Log scale to better show long periods\nplt.xlabel(\"Period (hours)\")\nplt.ylabel(\"Power\")\nplt.legend()\nplt.title(\"Spectral Peaks in Observed and Modeled Data\")\nplt.grid(which=\"both\", linestyle=\"--\", linewidth=0.5)\nplt.gca().invert_xaxis()  # Invert x-axis so long periods are on the right\nplt.xlim(1,50)\nplt.show()\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef bandpass_filter(time, signal, min_period=10, max_period=15):\n    \"\"\"Filter the signal to retain only frequencies corresponding to periods between min_period and max_period hours.\"\"\"\n    \n    # Compute FFT\n    n = len(signal)\n    dt = np.mean(np.diff(time))  # Time step in hours\n    freq = np.fft.rfftfreq(n, d=dt)  # Frequency axis (in Hz or cycles per hour)\n    spectrum = np.fft.rfft(signal)   # Compute FFT\n\n    # Convert periods to frequencies\n    min_freq = 1 / max_period  # Lower cutoff frequency\n    max_freq = 1 / min_period  # Upper cutoff frequency\n\n    # Zero out frequencies outside the band\n    spectrum[(freq < min_freq) | (freq > max_freq)] = 0\n\n    # Inverse FFT to reconstruct filtered signal\n    filtered_signal = np.fft.irfft(spectrum, n=n)\n\n    return filtered_signal\n\n# Convert time to hours since reference time\nreference_time = np.datetime64('2000-01-01T00:00:00', 's')\nobs_time = (obs_subset.time_dim[::6].load() - reference_time).astype('timedelta64[h]').astype(int).values\nmodel_time = (u_rg['time'] - reference_time).astype('timedelta64[h]').astype(int).load().values\nobs_time=(obs_time-obs_time[0])*10**(-0)*1/3600\nmodel_time=(model_time-model_time[0])*10**(-0)*1/3600\n\n# Apply band-pass filter\nu_obs_filtered = bandpass_filter(obs_time, u_obs.squeeze().values, min_period=10, max_period=15)\nu_model_filtered = bandpass_filter(model_time, u_sel.squeeze().values, min_period=10, max_period=15)\n\n# Create figure and subplots\nfig, axs = plt.subplots(nrows=2, ncols=1, figsize=(12, 8), sharex=True)\n\n# Plot filtered observed signal\naxs[0].plot(obs_time, u_obs_filtered, label=\"Filtered Observed (10-15h)\", color='b')\naxs[0].set_ylabel(\"Velocity (m/s)\")\naxs[0].set_ylim(-.41,.41)\naxs[0].set_title(\"Filtered Observed u_obs (10-15h Period)\")\naxs[0].legend()\naxs[0].grid()\n\n# Plot filtered modeled signal\naxs[1].plot(model_time, u_model_filtered, label=\"Filtered Modeled (10-15h)\", color='g')\naxs[1].set_xlabel(\"Time (hours)\")\naxs[1].set_ylabel(\"Velocity (m/s)\")\naxs[1].set_ylim(-.41,.41)\naxs[1].set_title(\"Filtered Modeled u_model (10-15h Period)\")\naxs[1].legend()\naxs[1].grid()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef highpass_filter(time, signal, cutoff_period=10):\n    \"\"\"Remove frequencies with periods longer than `cutoff_period` hours (high-pass filter).\"\"\"\n\n    # Compute FFT\n    n = len(signal)\n    dt = np.mean(np.diff(time))  # Time step in hours\n    freq = np.fft.rfftfreq(n, d=dt)  # Frequency axis (in Hz or cycles per hour)\n    spectrum = np.fft.rfft(signal)   # Compute FFT\n\n    # Define cutoff frequency\n    cutoff_freq = 1 / cutoff_period  # Frequency corresponding to the longest period to keep\n\n    # Zero out frequencies below the cutoff (i.e., remove long periods)\n    spectrum[freq < cutoff_freq] = 0\n\n    # Inverse FFT to reconstruct the high-pass filtered signal\n    filtered_signal = np.fft.irfft(spectrum, n=n)\n\n    return filtered_signal\n\n# Apply high-pass filter (removing periods ≥ 10 hours)\nu_obs_highpass = highpass_filter(obs_time, u_obs.squeeze().values, cutoff_period=10)\nu_model_highpass = highpass_filter(model_time, u_sel.squeeze().values, cutoff_period=10)\n\n# Create figure and subplots\nfig, axs = plt.subplots(nrows=2, ncols=1, figsize=(12, 8), sharex=True)\n\n# Plot high-pass filtered observed signal\naxs[0].plot(obs_time, u_obs_highpass, label=\"Observed (Periods < 10h)\", color='b')\naxs[0].set_ylabel(\"Velocity (m/s)\")\naxs[0].set_title(\"High-Pass Filtered Observed u_obs (Periods < 10h)\")\naxs[0].set_ylim(-.31,.31)\naxs[0].legend()\naxs[0].grid()\naxs[0].set_xlabel(\"Time (hours)\")\n\n# Plot high-pass filtered modeled signal\naxs[1].plot(model_time, u_model_highpass, label=\"Modeled (Periods < 10h)\", color='g')\naxs[1].set_xlabel(\"Time (hours)\")\naxs[1].set_ylabel(\"Velocity (m/s)\")\naxs[1].set_ylim(-.31,.31)\naxs[1].set_title(\"High-Pass Filtered Modeled u_model (Periods < 10h)\")\naxs[1].legend()\naxs[1].grid()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef lowpass_filter(time, signal, cutoff_period=15):\n    \"\"\"Remove frequencies with periods longer than `cutoff_period` hours (high-pass filter).\"\"\"\n\n    # Compute FFT\n    n = len(signal)\n    dt = np.mean(np.diff(time))  # Time step in hours\n    freq = np.fft.rfftfreq(n, d=dt)  # Frequency axis (in Hz or cycles per hour)\n    spectrum = np.fft.rfft(signal)   # Compute FFT\n\n    # Define cutoff frequency\n    cutoff_freq = 1 / cutoff_period  # Frequency corresponding to the longest period to keep\n\n    # Zero out frequencies below the cutoff (i.e., remove long periods)\n    spectrum[freq > cutoff_freq] = 0\n\n    # Inverse FFT to reconstruct the high-pass filtered signal\n    filtered_signal = np.fft.irfft(spectrum, n=n)\n\n    return filtered_signal\n\n# Apply high-pass filter (removing periods ≥ 10 hours)\nu_obs_lowpass = lowpass_filter(obs_time, u_obs.squeeze().values, cutoff_period=15)\nu_model_lowpass = lowpass_filter(model_time, u_sel.squeeze().values, cutoff_period=15)\n\n# Create figure and subplots\nfig, axs = plt.subplots(nrows=2, ncols=1, figsize=(12, 8), sharex=True)\n\n# Plot high-pass filtered observed signal\naxs[0].plot(obs_time, u_obs_lowpass, label=\"Observed (Periods > 15h)\", color='b')\naxs[0].set_ylabel(\"Velocity (m/s)\")\naxs[0].set_title(\"Low-Pass Filtered Observed u_obs (Periods > 15h)\")\naxs[0].legend()\naxs[0].set_ylim(-.31,.31)\naxs[0].grid()\naxs[0].set_xlabel(\"Time (hours)\")\n\n# Plot high-pass filtered modeled signal\naxs[1].plot(model_time, u_model_lowpass, label=\"Modeled (Periods > 15h)\", color='g')\naxs[1].set_xlabel(\"Time (hours)\")\naxs[1].set_ylabel(\"Velocity (m/s)\")\naxs[1].set_ylim(-.31,.31)\naxs[1].set_title(\"Low-Pass Filtered Modeled u_model (Periods > 15h)\")\naxs[1].legend()\naxs[1].grid()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef bandpass_filter(time, signal, low_cutoff=10, high_cutoff=15):\n    \"\"\"Apply a bandpass filter to retain frequencies between `low_cutoff` and `high_cutoff` hours.\"\"\"\n    n = len(signal)\n    dt = np.mean(np.diff(time))\n    freq = np.fft.rfftfreq(n, d=dt)\n    spectrum = np.fft.rfft(signal)\n\n    # Define cutoff frequencies\n    low_freq = 1 / high_cutoff\n    high_freq = 1 / low_cutoff–\n\n    # Zero out frequencies outside the band\n    spectrum[(freq < low_freq) | (freq > high_freq)] = 0\n\n    return np.fft.irfft(spectrum, n=n)\n\ndef highpass_filter(time, signal, cutoff_period=10):\n    \"\"\"Remove frequencies with periods longer than `cutoff_period` hours (retain high frequencies).\"\"\"\n    n = len(signal)\n    dt = np.mean(np.diff(time))\n    freq = np.fft.rfftfreq(n, d=dt)\n    spectrum = np.fft.rfft(signal)\n\n    # Define cutoff frequency\n    cutoff_freq = 1 / cutoff_period  \n\n    # Zero out frequencies below the cutoff (remove long periods)\n    spectrum[freq < cutoff_freq] = 0\n\n    return np.fft.irfft(spectrum, n=n)\n\ndef lowpass_filter(time, signal, cutoff_period=15):\n    \"\"\"Remove frequencies with periods shorter than `cutoff_period` hours (retain low frequencies).\"\"\"\n    n = len(signal)\n    dt = np.mean(np.diff(time))\n    freq = np.fft.rfftfreq(n, d=dt)\n    spectrum = np.fft.rfft(signal)\n\n    # Define cutoff frequency\n    cutoff_freq = 1 / cutoff_period  \n\n    # Zero out frequencies above the cutoff (remove short periods)\n    spectrum[freq > cutoff_freq] = 0\n\n    return np.fft.irfft(spectrum, n=n)\n\n# Apply filters to observed and modeled data\nu_obs_bandpass = bandpass_filter(obs_time, u_obs.squeeze().values, low_cutoff=10, high_cutoff=15)\nu_model_bandpass = bandpass_filter(model_time, u_sel.squeeze().values, low_cutoff=10, high_cutoff=15)\n\nu_obs_highpass = highpass_filter(obs_time, u_obs.squeeze().values, cutoff_period=10)\nu_model_highpass = highpass_filter(model_time, u_sel.squeeze().values, cutoff_period=10)\n\nu_obs_lowpass = lowpass_filter(obs_time, u_obs.squeeze().values, cutoff_period=15)\nu_model_lowpass = lowpass_filter(model_time, u_sel.squeeze().values, cutoff_period=15)\n\n# Prepare data for boxplot\ndata = [\n    u_obs_bandpass, u_model_bandpass,\n    u_obs_highpass, u_model_highpass,\n    u_obs_lowpass, u_model_lowpass\n]\n\nlabels = [\n    \"Obs Bandpass (10-15h)\", \"Model Bandpass (10-15h)\",\n    \"Obs High-pass (<10h)\", \"Model High-pass (<10h)\",\n    \"Obs Low-pass (>15h)\", \"Model Low-pass (>15h)\"\n]\n\n# Define colors (Obs = Light Green, Model = Light Blue)\ncolors = ['lightgreen', 'lightblue', 'lightgreen', 'lightblue', 'lightgreen', 'lightblue']\n\n# Create boxplot\nfig, ax = plt.subplots(figsize=(10, 6))\nboxplot = ax.boxplot(data, labels=labels, patch_artist=True, medianprops=dict(color=\"red\"))\n\n# Apply colors to boxes\nfor patch, color in zip(boxplot['boxes'], colors):\n    patch.set_facecolor(color)\n    patch.set_alpha(0.6)  # Transparency for better readability\n\nax.set_ylabel(\"Velocity (m/s)\")\nax.set_title(\"Boxplot of Filtered Velocity Components\")\n\nplt.xticks(rotation=20)  # Rotate labels for better readability\nplt.grid(axis='y', linestyle='--', alpha=0.6)\n\nplt.show()\n\n\n\n\n\n\n\n\nimport xarray as xr\nimport numpy as np\ntarget_depth_levels=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,25,30,35,40,45,50]\n# Load ROMS output using your pattern\nroms_output = ROMSOutput(\n    grid=grid,\n    path=[\n        model_data_path,\n    ],\n    use_dask=True,\n)\n\nds = roms_output.regrid(var_names=[\"u\", \"v\"],depth_levels=target_depth_levels)\n\nu_mean=ds['u'].thin({'time': 48}).mean('time').load()\nv_mean=ds['v'].thin({'time': 48}).mean('time').load()\n\n\n\nimport matplotlib.pyplot as plt\n\n# Create figure and subplots\nfig, axes = plt.subplots(nrows=1, ncols=5, figsize=(20, 5), sharey=True)\n\n# Loop through each dataset and create a subplot\nfor i, (key, obs) in enumerate(datasets.items()):\n    ax = axes[i]  # Select subplot\n    obs=list(datasets.values())[i]\n    obs_lon=obs.lon\n    obs_lat=obs.lat\n    # Plot observed profile\n    ax.plot(obs['u'].mean('time_dim').squeeze(), obs.depth, label=\"Observed\", color='b')\n\n    # Extract nearest model data\n    u_sel = u_mean.sel(lon=obs_lon.values, method='nearest').sel(lat=obs_lat.values, method='nearest')\n\n    # Plot modeled profile\n    ax.plot(u_sel.squeeze(), u_mean.depth, label=\"Modeled\", color='r')\n\n    # Reverse y-axis\n    ax.invert_yaxis()\n\n    # Titles and labels\n    ax.set_title(f\"Station {i+1}\")\n    if i == 0:\n        ax.set_ylabel(\"Depth (m)\")\n    ax.set_xlabel(\"Velocity (m/s)\")\n    ax.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n","type":"content","url":"/velocity-analysis-200m-copy1#velocity-model-obs-adcp-comparison","position":3}]}