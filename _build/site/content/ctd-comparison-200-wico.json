{"version":3,"kind":"Notebook","sha256":"5279a2f288e5962cb3cae06169c5b098b2ac6814c8fe14814c2b20aa93db2442","slug":"ctd-comparison-200-wico","location":"/CTD_comparison_200_WiCO.ipynb","dependencies":[],"frontmatter":{"title":"Comparison of the HAFRO CTD data with ROMS model output","content_includes_title":false,"kernelspec":{"name":"roms-tools","display_name":"Python (My roms-tools Kernel)","language":"python"},"exports":[{"format":"ipynb","filename":"CTD_comparison_200_WiCO.ipynb","url":"/CTD_comparison_200_W-d31a9f1589c4ece0efaf805f00f9b807.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"This notebook loads the observed CTD data and model data. It converts observed data to xarray format, and regrids model data onto lat,lon,z coordinates. There are some options available to reduce the model data loaded in for the sake of available memory. It then makes various plots of stratification and seasonal evolution of salinity and temperature. We use the roms-tools regridder.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"PYkaKyHuOs"}],"key":"S90WduHnNm"}],"key":"IfYDADzTAg"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Loading in modules\n\nimport subprocess\nimport os\nimport pandas as pd\nimport netCDF4\nimport numpy as np\nimport glob\nimport time\nimport matplotlib.pyplot as plt\nimport copy\n\nimport xarray as xr\nfrom datetime import datetime, timedelta \nimport dask\nfrom scipy.interpolate import griddata\n#from ocean_c_lab_tools import *\n#from celluloid import Camera \n#import PyCO2SYS as csys\n#import seawater as sw\nfrom roms_regrid import *","key":"euQEnoji14"},{"type":"outputs","id":"UaH8fmHWfjIfgCwjkaOs3","children":[],"key":"LWD5cyIecj"}],"key":"AuUD8oDLmx"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Setting parameters and paths","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"yYJq19RZKo"}],"identifier":"setting-parameters-and-paths","label":"Setting parameters and paths","html_id":"setting-parameters-and-paths","implicit":true,"key":"h2M5m6UHzX"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Here, all the parameters for model regridding, the paths for data storage, and the chosen length of model comparison are set, so that the remainder of the notebook needs minimal adjustment","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"oHNYfxztOh"}],"key":"erg5obUQX4"}],"key":"Slw5Kh8hXi"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"HAFRO_path='/home/x-uheede/R/HAFRO/Hafro_cruises.xls'\nmodel_grid_path=\"/home/x-uheede/S/Iceland2_MARBL_2024_60m/P_INPUT/Iceland2_grid_MAT1.nc\"\n# Grid parameters, only modify these if grid is made in MATLAB\nvert_levels=60\ntheta_s_model=5\ntheta_b_model=2\nhc_model=300\nmodel_data_path=\"/home/x-uheede/S/Iceland2_NOMARBL_2024_NewV/Iceland2_MARBL_2024_his.20240[4-8]????????.nc\"\nmonths_analysis=[4,5,6,7,8] # enter the months you want to analyze for the model\n# enter the dates you want to analyze for the observations\nmonths_string_begin='01-04-2024'\nmonths_string_end='31-08-2024'\ntarget_depth_levels=[1,2,3,4,5,7,9,10,12,14,15,16,18,20,26,30,36,40,50,80] # Specify depth levels of interest\nthinner=24*7 # specify the temporal frequency of data being read (i.e. no need to read in hourly data)\n","key":"Uys1FP5pcD"},{"type":"outputs","id":"7pb0y5K3So6yqFRyLZmiC","children":[],"key":"J9GbqiljYe"}],"key":"IHjVybBZV9"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Read in observed data\nxls = pd.ExcelFile(HAFRO_path)\n\ncombo = pd.read_excel(xls, 'combo',decimal='.')\n\nobs=xr.Dataset.from_dataframe(combo)\n\n# reformat into xarray dataset, HV is our station number indicator\nobs=obs.set_index(index=['HV','Depth','mon/day/yr'])\nobs=obs.drop_duplicates('index')\nobs=obs.unstack('index')\n# renaming variables that have strange formatting in the excelsheet\nobs=obs.rename(name_dict={'mon/day/yr':'time','Depth':'depth','Latitude(¬∞N)':'lat','Longitude(¬∞E)':'lon'})\n","key":"QlnzGfoF83"},{"type":"outputs","id":"bkblRTq130NzkFhDC0ISw","children":[],"key":"FTgGhj58Jy"}],"key":"qHz68avrTV"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# define location which calculations the average location of each station\ndef get_location(obs, hv_values):\n    locations = []\n    for hv in hv_values:\n        lat = obs['lat'].sel(HV=hv).isel(depth=0).mean('time').squeeze().values\n        lon = obs['lon'].sel(HV=hv).isel(depth=0).mean('time').squeeze().values + 360\n        locations.append([lat, lon])\n    return locations\n\n# List of HV values\nhv_values = range(1, 13)\n\n# Get the locations\nlocations = get_location(obs, hv_values)","key":"BqU3572g0s"},{"type":"outputs","id":"NURyQ01yXVN6rRyIW7sCi","children":[],"key":"jVaODb8yce"}],"key":"NfRfjIMPU7"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"from roms_tools import Grid, ROMSOutput","key":"AcI9UlMj1f"},{"type":"outputs","id":"yj278llYBgfNRLkwDUGdD","children":[],"key":"fzWqSHEJDX"}],"key":"p2NLTMxczO"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"grid = Grid.from_file(\n    model_grid_path\n)","key":"FiNNdzhMCC"},{"type":"outputs","id":"RYG_uCPxf4VyAysTHT6UU","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"2025-12-08 13:09:31 - WARNING - Vertical coordinates (Cs_r, Cs_w) not found in grid file.\n2025-12-08 13:09:31 - INFO - === Preparing the vertical coordinate system using N = 100, theta_s = 5.0, theta_b = 2.0, hc = 300.0 ===\n2025-12-08 13:09:31 - INFO - Total time: 0.003 seconds\n2025-12-08 13:09:31 - INFO - ========================================================================================================\n"},"children":[],"key":"rwDqAGwscC"}],"key":"S6BfRyC2D6"}],"key":"gg05ilvBCi"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"#Only run this cell if grid is made in MATLAB\ngrid.update_vertical_coordinate(N=vert_levels, theta_s=theta_s_model, theta_b=theta_b_model, hc=hc_model, verbose=False)","key":"Ie9TS1ElXf"},{"type":"outputs","id":"93VVWQpakMQXWnqEOPnA0","children":[],"key":"aQHOppZreR"}],"key":"E36J3qpCnt"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import xarray as xr\nimport numpy as np\n\n# Load ROMS output using your pattern\nroms_output = ROMSOutput(\n    grid=grid,\n    path=[\n        model_data_path,\n    ],\n    use_dask=True,\n)\n\nds = roms_output.regrid(var_names=[\"temp\", \"salt\"],depth_levels=target_depth_levels)\n\n# Extract month for each time entry\nmonths = ds.time.dt.month\n\n# Dimensions we want\nmonth_vals = months_analysis\ntypes = [\"mean\", \"std\"]\n\n# Create empty datasets for salt & temp\nsalt_data = []\ntemp_data = []\n\nfor m in month_vals:\n    ds_m = ds.sel(time=months == m)\n\n    # Calculate and append mean & std\n    salt_mean = ds_m[\"salt\"].thin({'time': thinner}).mean(\"time\").load()\n    salt_std  = ds_m[\"salt\"].thin({'time': thinner}).std(\"time\").load()\n    temp_mean = ds_m[\"temp\"].thin({'time': thinner}).mean(\"time\").load()\n    temp_std  = ds_m[\"temp\"].thin({'time': thinner}).std(\"time\").load()\n\n    salt_data.append(xr.concat([salt_mean, salt_std], dim=\"type\"))\n    temp_data.append(xr.concat([temp_mean, temp_std], dim=\"type\"))\n\n# Concatenate over month dimension\nsalt_all = xr.concat(salt_data, dim=\"month\")\ntemp_all = xr.concat(temp_data, dim=\"month\")\n\n# Assign coordinates\nsalt_all = salt_all.assign_coords(type=types, month=month_vals)\ntemp_all = temp_all.assign_coords(type=types, month=month_vals)\n\n# Build final dataset\nds_monthly = xr.Dataset(\n    {\n        \"salt\": salt_all,\n        \"temp\": temp_all,\n    }\n)\n\nprint(ds_monthly)\n\n","key":"QQ8HnBaIdG"},{"type":"outputs","id":"LxCbRzhH2pGFgmmdVE3by","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"<xarray.Dataset> Size: 555MB\nDimensions:  (lat: 481, lon: 721, depth: 20, type: 2, month: 5)\nCoordinates:\n  * lat      (lat) float32 2kB 63.0 63.0 63.01 63.01 ... 64.99 64.99 65.0 65.0\n  * lon      (lon) float32 3kB 336.0 336.0 336.0 336.0 ... 339.0 339.0 339.0\n  * depth    (depth) float32 80B 1.0 2.0 3.0 4.0 5.0 ... 36.0 40.0 50.0 80.0\n  * type     (type) <U4 32B 'mean' 'std'\n  * month    (month) int64 40B 4 5 6 7 8\nData variables:\n    salt     (month, type, lat, lon, depth) float32 277MB nan nan ... nan nan\n    temp     (month, type, lat, lon, depth) float32 277MB nan nan ... nan nan\n"},"children":[],"key":"JYslfBOLfk"}],"key":"vuzRothSjd"}],"key":"s0KdrHML4W"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"[months_analysis]","key":"SIStB9IVrP"},{"type":"outputs","id":"6p0RS0VnDmLGpeBSPZpZW","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":52,"metadata":{},"data":{"text/plain":{"content":"[[4, 5, 6, 7, 8]]","content_type":"text/plain"}}},"children":[],"key":"v1rWfg9mp4"}],"key":"ZlHGyDqqiV"}],"key":"yp2E70WemX"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"t=ds_monthly['temp']\ns=ds_monthly['salt']","key":"q10WhXaAYp"},{"type":"outputs","id":"ZwqFlhxejryZGcWV-Opzf","children":[],"key":"toekLXPrdo"}],"key":"aYTDX5TE0B"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Assuming locations is a list of lat/lon pairs\nt_values = []\ns_values = []\n# Loop over the first 10 locations and store each selection in t_values\nfor i in range(12):\n    lat, lon = locations[i]\n    \n    # Select the 't' values at the nearest lat/lon\n    t_selected = t.sel(lat=lat, method='nearest').sel(lon=lon, method='nearest')\n    s_selected = s.sel(lat=lat, method='nearest').sel(lon=lon, method='nearest')\n    \n    # Store the result in the listx\n    t_values.append(t_selected)\n    s_values.append(s_selected)\n\n# Combine the selections into an xarray Dataset or DataArray\nt_values_combined = xr.concat(t_values, dim='location')\ns_values_combined = xr.concat(s_values, dim='location')\n\n# Assign a location coordinate for clarity (optional)\nt_values_combined = t_values_combined.assign_coords(location=('location', range(1, 13)))\ns_values_combined = s_values_combined.assign_coords(location=('location', range(1, 13)))\nt_values_combined['depth']=t_values_combined.depth*(-1)\ns_values_combined['depth']=s_values_combined.depth*(-1)\n# Now you have t_values as an xarray object (Dataset or DataArray)\n#print(t_values_combined)\n","key":"xvMBJvsMNf"},{"type":"outputs","id":"eCHrAFcKEPA7cKM9LKv4X","children":[],"key":"N5hlnUtHQP"}],"key":"IxsBKfjwUE"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import matplotlib.pyplot as plt\n\n# Set up the subplots\nfig, axarr = plt.subplots(nrows=3, ncols=4, figsize=(12, 6*1.2), constrained_layout=True)\nax = axarr.flatten()  # Flatten to make indexing easier\npalette = plt.get_cmap('tab20')\n\n# Loop through 12 locations\nfor i in range(12):\n    loc = i + 1  # location index starts at 1\n\n    # Extract model data\n    model_mean = s_values_combined.isel(type=0).mean('month').sel(location=loc)\n    model_std = s_values_combined.isel(type=1).mean('month').sel(location=loc)\n\n    # Plot model average\n    ax[i].plot(model_mean, s_values_combined.depth*(-1), label='Model Avg', color='black')\n\n    # Plot shaded region for model standard deviation\n    ax[i].fill_betweenx(s_values_combined.depth*(-1), model_mean - model_std, model_mean + model_std, \n                         color='grey', alpha=0.4, label='Model Std Dev')\n\n    # Extract observed data\n    ax[i].plot(obs['Salinity'].sel(HV=loc).dropna(dim='depth', how='all').sel(time=slice(months_string_begin, months_string_end)).mean('time'),\n            obs.sel(HV=loc).dropna(dim='depth', how='all').depth, label='Obs', color=palette(2))\n\n    obs_std = obs['Salinity'].sel(HV=loc).dropna(dim='depth', how='all').sel(time=slice(months_string_begin, months_string_end)).std('time')\n\n\n    # Plot shaded region for observed standard deviation\n    ax[i].fill_betweenx(obs.depth, (obs['Salinity'].sel(HV=loc).sel(time=slice(months_string_begin, months_string_end)).mean('time')-obs['Salinity'].sel(HV=loc).sel(time=slice(months_string_begin, months_string_end)).std('time')),(obs['Salinity'].sel(HV=loc).sel(time=slice(months_string_begin, months_string_end)).mean('time')+obs['Salinity'].sel(HV=loc).sel(time=slice(months_string_begin, months_string_end)).std('time')), color=palette(2), alpha=0.4)\n\n    # Set depth limits for specific subplots\n    ax[0].set_ylim(0,35)\n    ax[2].set_ylim(0,25)\n    ax[3].set_ylim(0,30)\n    ax[4].set_ylim(0,70)\n    ax[5].set_ylim(0,28)\n    ax[6].set_ylim(0,25)\n    ax[7].set_ylim(0,25)\n    ax[8].set_ylim(0,20)\n    ax[9].set_ylim(0,60)\n    ax[11].set_ylim(0,6)\n\n    # Set title, labels\n    ax[i].set_title(f'Salinity CTD Station: {obs.HV[loc - 1].values}')\n    ax[i].set_xlabel('psu')\n    ax[i].set_ylabel('Depth')\n\n    # Show legend only for the first subplot\n    if i == 1:\n        ax[i].legend()\n\nfor i in range(12):\n    ax[i].invert_yaxis()\n    \n# Display the plot\nplt.show()\n","key":"Vc7WcbI06R"},{"type":"outputs","id":"uAPKwZ1L7hggjwLRJMsD7","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"e7b254639b658e83154e10c8bba98be5","path":"/e7b254639b658e83154e10c8bba98be5.png"},"text/plain":{"content":"<Figure size 1200x720 with 12 Axes>","content_type":"text/plain"}}},"children":[],"key":"UYPVF8CuiS"}],"key":"bknejTOTxP"}],"key":"RVQpd50lIl"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"loc = np.array(locations)\nlevels_psu=np.arange(31,35,0.1)\nlevels_t=np.arange(2.5,10,0.2)\ndata_psu1=obs['Salinity'].sel(time=slice(months_string_begin, months_string_end)).sel(HV=[1,3,5,7,9,10,12]).mean('time')\ndata_psu2=obs['Salinity'].sel(time=slice(months_string_begin, months_string_end)).sel(HV=[2,3,4]).mean('time')\ndata_t=obs['Temperature'].sel(time=slice(months_string_begin, months_string_end)).sel(HV=[1,3,5,7,9,10,12]).mean('time')\n\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(6*2, 3), constrained_layout=True)\nax = axarr.flatten()\nc0=ax[0].contourf(loc[[1-1,3-1,5-1,7-1,9-1,10-1,12-1],1]-360,data_psu1.depth, data_psu1.transpose(),levels_psu)\n\n#ax[1].contourf(loc[[1-1,3-1,5-1,7-1,9-1,10-1,12-1],1]-360,data.depth, data_t.transpose(),levels_t)\n#ax[1].invert_yaxis()\nc1=ax[1].contourf(loc[[2-1,3-1,4-1],0],data_psu2.depth, data_psu2.transpose(),levels_psu)\n\nax[0].set_title('along fjord mean salinity profile (Observed)')\nax[0].set_xlabel('longitude')\nax[0].set_ylabel('depth')\nax[0].set_ylim(0,40)\nplt.colorbar(c0,ax=ax[0], orientation='vertical', label='psu',shrink=0.5)\nax[0].invert_yaxis()\n\nax[1].set_title('across fjord mean salinity profile (Observed)')\nax[1].set_xlabel('latitude')\nax[1].set_ylabel('depth')\nax[1].set_ylim(0,40)\nplt.colorbar(c1, ax=ax[1], orientation='vertical', label='psu',shrink=0.5)\nax[1].invert_yaxis()","key":"D0XTwwxN6P"},{"type":"outputs","id":"0lJc57SY7npyUiq1JpGIr","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"85137b3361f67f0a6769fbeb9c6e9fe1","path":"/85137b3361f67f0a6769fbeb9c6e9fe1.png"},"text/plain":{"content":"<Figure size 1200x300 with 4 Axes>","content_type":"text/plain"}}},"children":[],"key":"sZz4UGBYA6"}],"key":"nw8VSeGnsb"}],"key":"vnZE7uuQFg"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"loc = np.array(locations)\nlevels_psu=np.arange(31,35,0.1)\nlevels_t=np.arange(2.5,10,0.2)\ndata_psu1=s_values_combined.isel(type=0).mean('month').sel(location=[1,3,5,7,9,10,12])\ndata_psu2=s_values_combined.isel(type=0).mean('month').sel(location=[2,3,4])\n\n\n#data_t=obs['Temperature'].sel(HV=[1,3,5,7,9,10,12]).mean('time')\n\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(6*2, 3), constrained_layout=True)\nax = axarr.flatten()\nc0=ax[0].contourf(loc[[1-1,3-1,5-1,7-1,9-1,10-1,12-1],1]-360,data_psu1.depth*(-1), data_psu1.transpose(),levels_psu)\n\n#ax[1].contourf(loc[[1-1,3-1,5-1,7-1,9-1,10-1,12-1],1]-360,data.depth, data_t.transpose(),levels_t)\n#ax[1].invert_yaxis()\nc1=ax[1].contourf(loc[[2-1,3-1,4-1],0],data_psu2.depth*(-1), data_psu2.transpose(),levels_psu)\n\nax[0].set_title('along fjord mean salinity profile (model)')\nax[0].set_xlabel('longitude')\nax[0].set_ylabel('depth')\nax[0].set_ylim(0,40)\nplt.colorbar(c0,ax=ax[0], orientation='vertical', label='psu',shrink=0.5)\nax[0].invert_yaxis()\n\nax[1].set_title('across fjord mean salinity profile (model)')\nax[1].set_xlabel('latitude')\nax[1].set_ylabel('depth')\nax[1].set_ylim(0,40)\nplt.colorbar(c1, ax=ax[1], orientation='vertical', label='psu',shrink=0.5)\nax[1].invert_yaxis()","key":"ppk4DE19h7"},{"type":"outputs","id":"xN1f6i7PYzIB3Hxx_4OtA","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"118062845750dcc789a239355717e465","path":"/118062845750dcc789a239355717e465.png"},"text/plain":{"content":"<Figure size 1200x300 with 4 Axes>","content_type":"text/plain"}}},"children":[],"key":"m4nDD4V1W6"}],"key":"pxT7S9URxH"}],"key":"vWzxZchbz9"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import matplotlib.pyplot as plt\nimport numpy as np\n\n# --- CONFIG ---\nmonth_names = [\"May\", \"June\", \"July\", \"August\", \"September\"]\nn_months = 4   # May–Sep\npalette = plt.get_cmap(\"tab20\")\n\n# --- TAKE MEAN OVER ALL 12 STATIONS ---\nmodel_mean = s_values_combined.isel(type=0).mean(dim=\"location\")\nmodel_std  = s_values_combined.isel(type=1).mean(dim=\"location\")\n\n# --- OBSERVATIONS: MEAN + STD ACROSS STATIONS ---\nobs_monthly_mean = []\nobs_monthly_std = []\n\nfor m in range(n_months):\n    month_str = f\"2024-{m+5:02d}\"   # 05–09\n    obs_sel = obs[\"Salinity\"].sel(\n        time=slice('2024-0'+str(m+4)+'-01','2024-0'+str(m+4)+'-30')\n    )\n\n    # mean over stations, then mean over time\n    obs_mean_m = obs_sel.mean(dim=\"time\").mean(dim=\"HV\")\n    obs_std_m  = obs_sel.std(dim=\"time\").mean(dim=\"HV\")\n\n    obs_monthly_mean.append(obs_mean_m)\n    obs_monthly_std.append(obs_std_m)\n\n# --- SET UP FIGURE ---\nfig, axarr = plt.subplots(\n    nrows=3, ncols=2, figsize=(5, 7), constrained_layout=True\n)\nax = axarr.flatten()\n\nfor m in range(n_months):\n\n    # MODEL DATA FOR MONTH m\n    model_mean_m = model_mean.isel(month=m+1)\n    model_std_m  = model_std.isel(month=m+1)\n\n    # OBS DATA FOR MONTH m\n    obs_mean_m = obs_monthly_mean[m]\n    obs_std_m  = obs_monthly_std[m]\n\n    # --- PLOTTING ---\n    ax[m].plot(model_mean_m, s_values_combined.depth*(-1), color='black', label=\"Model Mean\")\n    ax[m].fill_betweenx(\n        s_values_combined.depth*(-1),\n        model_mean_m - model_std_m,\n        model_mean_m + model_std_m,\n        color=\"grey\", alpha=0.4, label=\"Model Std\"\n    )\n\n    ax[m].plot(obs_mean_m, obs.sel(HV=1).depth, color=palette(3), label=\"Obs Mean\")\n    ax[m].fill_betweenx(\n        obs.sel(HV=1).depth,\n        obs_mean_m - obs_std_m,\n        obs_mean_m + obs_std_m,\n        color=palette(3), alpha=0.3, label=\"Obs Std\"\n    )\n\n    # TITLE + LABELS\n    ax[m].set_title(f\"Average Salinity Profile – {month_names[m]}\")\n    ax[m].set_xlabel(\"psu\")\n    ax[m].set_ylabel(\"Depth (m)\")\n    ax[m].set_ylim(0,40)\n    # invert depth\n    ax[m].invert_yaxis()\n\n    # legend on first panel\n    if m == 0:\n        ax[m].legend()\n\n# Remove empty subplot (6th)\nfig.delaxes(ax[5])\n\nplt.show()\n","key":"cqWEojsX82"},{"type":"outputs","id":"CgYuWZF_dBzUBXp6lpBlb","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"3500a3bffabf672ad9bf02f496dc1383","path":"/3500a3bffabf672ad9bf02f496dc1383.png"},"text/plain":{"content":"<Figure size 500x700 with 5 Axes>","content_type":"text/plain"}}},"children":[],"key":"A6Ou682OqM"}],"key":"dqZjlRUHid"}],"key":"qtmfssmy3Z"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import matplotlib.pyplot as plt\nimport numpy as np\n\n# --- CONFIG ---\nmonth_names = [\"May\", \"June\", \"July\", \"August\", \"September\"]\nn_months = 4# May–Sep\npalette = plt.get_cmap(\"tab20\")\n\n# --- TAKE MEAN OVER ALL 12 STATIONS ---\nmodel_mean = t_values_combined.isel(type=0).mean(dim=\"location\")\nmodel_std  = t_values_combined.isel(type=1).mean(dim=\"location\")\n\n# --- OBSERVATIONS: MEAN + STD ACROSS STATIONS ---\nobs_monthly_mean = []\nobs_monthly_std = []\n\nfor m in range(n_months):\n    month_str = f\"2024-{m+4:02d}\"   # 05–09\n    obs_sel = obs[\"Temperature\"].sel(\n        time=slice('2024-0'+str(m+5)+'-01','2024-0'+str(m+5)+'-30')\n    )\n\n    # mean over stations, then mean over time\n    obs_mean_m = obs_sel.mean(dim=\"time\").mean(dim=\"HV\")\n    obs_std_m  = obs_sel.std(dim=\"time\").mean(dim=\"HV\")\n\n    obs_monthly_mean.append(obs_mean_m)\n    obs_monthly_std.append(obs_std_m)\n\n# --- SET UP FIGURE ---\nfig, axarr = plt.subplots(\n    nrows=3, ncols=2, figsize=(5, 7), constrained_layout=True\n)\nax = axarr.flatten()\n\nfor m in range(n_months):\n\n    # MODEL DATA FOR MONTH m\n    model_mean_m = model_mean.isel(month=m+1)\n    model_std_m  = model_std.isel(month=m+1)\n\n    # OBS DATA FOR MONTH m\n    obs_mean_m = obs_monthly_mean[m]\n    obs_std_m  = obs_monthly_std[m]\n\n    # --- PLOTTING ---\n    ax[m].plot(model_mean_m, s_values_combined.depth*(-1), color='black', label=\"Model Mean\")\n    ax[m].fill_betweenx(\n        s_values_combined.depth*(-1),\n        model_mean_m - model_std_m,\n        model_mean_m + model_std_m,\n        color=\"grey\", alpha=0.4, label=\"Model Std\"\n    )\n\n    ax[m].plot(obs_mean_m, obs.sel(HV=1).depth, color=palette(3), label=\"Obs Mean\")\n    ax[m].fill_betweenx(\n        obs.sel(HV=1).depth,\n        obs_mean_m - obs_std_m,\n        obs_mean_m + obs_std_m,\n        color=palette(3), alpha=0.3, label=\"Obs Std\"\n    )\n\n    # TITLE + LABELS\n    ax[m].set_title(f\"Average Temperature Profile – {month_names[m]}\")\n    ax[m].set_xlabel(\"degrees C\")\n    ax[m].set_ylabel(\"Depth (m)\")\n    ax[m].set_ylim(0,40)\n    # invert depth\n    ax[m].invert_yaxis()\n\n    # legend on first panel\n    if m == 0:\n        ax[m].legend()\n\n# Remove empty subplot (6th)\nfig.delaxes(ax[5])\n\nplt.show()\n","key":"idXt8mWOlh"},{"type":"outputs","id":"kmbia_iEHvgMEELhKU0f6","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"a851bb944abe2da6287de9c0ae1ea75e","path":"/a851bb944abe2da6287de9c0ae1ea75e.png"},"text/plain":{"content":"<Figure size 500x700 with 5 Axes>","content_type":"text/plain"}}},"children":[],"key":"koSgztivRF"}],"key":"DeERHHdQqy"}],"key":"gHLHZnYPMi"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import xarray as xr\nimport numpy as np\n\n# Load ROMS output using your pattern\nroms_output = ROMSOutput(\n    grid=grid,\n    path=[\n        model_data_path,\n    ],\n    use_dask=True,\n)\n\nds = roms_output.regrid(var_names=[\"temp\", \"salt\"],depth_levels=[5])\n","key":"KIMGnMFTcJ"},{"type":"outputs","id":"dDq4aiJbHNRTRXDsCu2ip","children":[],"key":"eg060WRmNO"}],"key":"lXaUzUPbIA"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"t=ds['temp'].thin({'time': 24}).load()\ns=ds['salt'].thin({'time': 24}).load()","key":"fFdtX5NkwK"},{"type":"outputs","id":"R8PvgwEsRPyCTy0osgiLf","children":[],"key":"W2Zi3UNLWV"}],"key":"SM4ZYGKJbC"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Define file paths and station names\nstations = [\"HVIN_1\", \"HVNA_1\", \"HVNV_1\", \"HVSA_1\", \"HVSV_1\"]\nfile_paths = {name: f\"/global/cfs/cdirs/m4632/uheede/Hafro_obsdata/{name}new.nc\" for name in stations}\n# Define file paths and station names\nstations = [\"HVIN_1\", \"HVNA_1\", \"HVNV_1\", \"HVSA_1\", \"HVSV_1\"]\nfile_paths = {name: f\"/home/x-uheede/R/HAFRO/{name}_TS.nc\" for name in stations}\n\n# Dictionary to store datasets\ndatasets = {}\n\nfor name, path in file_paths.items():\n    ds = xr.open_dataset(path)\n    \n    # Store dataset with adjusted longitude\n    datasets[name] = ds.assign_coords(lon=ds['lon'].load() + 360)\n\nsubtract = 739674 - 9189  # Computed constant\nreference_date = pd.to_datetime(\"2000-01-01\")  # Reference date\n\n# Apply transformation to all datasets\nfor name, ds in datasets.items():\n    datetime_series = reference_date + pd.to_timedelta((ds['time'].values - subtract), unit='D')\n    datasets[name] = ds.assign_coords(time_dim=datetime_series)  # Update the time coordinate\n\nds_list = []\n\nfor name, ds in datasets.items():\n    # Add station as a new dimension\n    ds_expanded = ds.expand_dims(station=[name])\n    ds_list.append(ds_expanded)\n    \ncombined = xr.concat(ds_list, dim=\"station\")\nmean_ts = combined.mean(dim=\"station\", skipna=True)","key":"TQKU53UrpU"},{"type":"outputs","id":"gD27goZRoq2Pp2r_gUZd0","children":[],"key":"tPHpq1capo"}],"key":"AnBTm588rF"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"plt.plot(mean_ts['temperature'])","key":"beEx7AxR4R"},{"type":"outputs","id":"IYSKSSMomeocpI2-saY4M","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"636e22ffc8e490fd2dbeba7e3e690e78","path":"/636e22ffc8e490fd2dbeba7e3e690e78.png"},"text/plain":{"content":"<Figure size 640x480 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"Ssj7pFp1F2"}],"key":"UgJzN0vodM"}],"key":"LBjEJs4EO7"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Assuming locations is a list of lat/lon pairs\nt_values = []\ns_values = []\n# Loop over the first 10 locations and store each selection in t_values\nfor i in range(12):\n    lat, lon = locations[i]\n    \n    # Select the 't' values at the nearest lat/lon\n    t_selected = t.sel(lat=lat, method='nearest').sel(lon=lon, method='nearest')\n    s_selected = s.sel(lat=lat, method='nearest').sel(lon=lon, method='nearest')\n    \n    # Store the result in the listx\n    t_values.append(t_selected)\n    s_values.append(s_selected)\n\n# Combine the selections into an xarray Dataset or DataArray\nt_values_combined = xr.concat(t_values, dim='location')\ns_values_combined = xr.concat(s_values, dim='location')\n\n# Assign a location coordinate for clarity (optional)\nt_values_combined = t_values_combined.assign_coords(location=('location', range(1, 13)))\ns_values_combined = s_values_combined.assign_coords(location=('location', range(1, 13)))\n#t_values_combined['depth']=t_values_combined.depth*(-1)\n#s_values_combined['depth']=s_values_combined.depth*(-1)\n# Now you have t_values as an xarray object (Dataset or DataArray)\n#print(t_values_combined)\n","key":"cl1h4nifl2"},{"type":"outputs","id":"nKejoa2XhrX_zgHZz3AIs","children":[],"key":"gjpJetP71K"}],"key":"P147jWnb2Y"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import matplotlib.pyplot as plt\n\n# Set up the subplots\nfig, axarr = plt.subplots(nrows=2, ncols=4, figsize=(12, 4*1.2), constrained_layout=True)\nax = axarr.flatten()  # Flatten to make indexing easier\npalette = plt.get_cmap('tab20')\n\n# Plot observed salinity for May 2024\nax[1].plot(mean_ts['salinity'].time_dim.sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           mean_ts['salinity'].sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           label='May', color=palette(2))\n\nax[0].plot(s_values_combined.time, s_values_combined.sel(location=[1,3,4,5,6,7,8,9,10,12]).mean('location'),\n           label='May', color=palette(1))\n\n# Plot observed salinity for May 2024\nax[3].plot(mean_ts['temperature'].time_dim.sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           mean_ts['temperature'].sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           label='May', color=palette(2))\nax[3].set_ylim(2,12.5)\n\nax[2].plot(s_values_combined.time, t_values_combined.sel(location=[1,3,4,5,6,7,8,9,10,12]).mean('location'),\n           label='May', color=palette(1))\nax[2].set_ylim(2,12.5)\nax[5].plot(datasets['HVSV_1'].time_dim.sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           datasets['HVSV_1']['salinity'].sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           label='May', color=palette(2))\n\nax[4].plot(s_values_combined.time, s_values_combined.sel(location=[1]).mean('location'),\n           label='May', color=palette(1))\n\n# Plot observed salinity for May 2024\nax[7].plot(datasets['HVSV_1'].time_dim.sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           datasets['HVSV_1']['temperature'].sel(time_dim=slice('04-01-2024', '09-01-2024')),\n           label='May', color=palette(2))\nax[7].set_ylim(2,12.5)\nax[6].plot(s_values_combined.time, t_values_combined.sel(location=[1]).mean('location'),\n           label='May', color=palette(1))\nax[6].set_ylim(2,12.5)\n# Rotate x-axis labels for all subplots\nfor a in ax:\n    a.tick_params(axis='x', rotation=45)  # Adjust rotation angle as needed\n    \n    \nax[0].set_title('salinity for all stations,\\n 5 m depth MODEL')\nax[1].set_title('salinity for all stations,\\n 5 m depth OBS')\nax[2].set_title('temperature for all stations,\\n 5 m depth MODEL')\nax[3].set_title('temperate for all stations,\\n 5 m depth OBS')\nax[4].set_title('salinity for station 1,\\n 5 m depth MODEL')\nax[5].set_title('salinity for station 1,\\n 5 m depth OBS')\nax[6].set_title('temperature for station 1,\\n 5 m depth MODEL')\nax[7].set_title('temperate for station 1,\\n 5 m depth OBS')\nplt.show()\n\n","key":"BUMSFUIdvR"},{"type":"outputs","id":"zCugG3MfMGRq7LzxTfDqO","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"7343fe01d364bcb9ed033daa4804acf5","path":"/7343fe01d364bcb9ed033daa4804acf5.png"},"text/plain":{"content":"<Figure size 1200x480 with 8 Axes>","content_type":"text/plain"}}},"children":[],"key":"UzClRWr9av"}],"key":"ndBTTEnOTA"}],"key":"pjapj34Lr8"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import matplotlib.pyplot as plt\n\n# Set up the subplots\nfig, axarr = plt.subplots(nrows=2, ncols=4, figsize=(12, 4*1.2), constrained_layout=True)\nax = axarr.flatten()  # Flatten to make indexing easier\npalette = plt.get_cmap('tab20')\n\n# Plot observed salinity for May 2024\nax[1].plot(obs.time.sel(time=slice('04-01-2024', '09-01-2024')),\n           obs['Salinity'].sel(depth=slice(2,5)).mean('depth').sel(HV=[1,3,4,5,6,7,8,9,10,12]).sel(time=slice('04-01-2024', '09-01-2024')).mean('HV'),\n           label='May', color=palette(2))\n\nax[0].plot(s_values_combined.time, s_values_combined.sel(location=[1,3,4,5,6,7,8,9,10,12]).mean('location'),\n           label='May', color=palette(1))\n\n# Plot observed salinity for May 2024\nax[3].plot(obs.time.sel(time=slice('04-01-2024', '09-01-2024')),\n           obs['Temperature'].sel(depth=slice(2,5)).mean('depth').sel(HV=[1,3,4,5,6,7,8,9,10,12]).sel(time=slice('04-01-2024', '09-01-2024')).mean('HV'),\n           label='May', color=palette(2))\nax[3].set_ylim(4.5,12.5)\n\nax[2].plot(s_values_combined.time, t_values_combined.sel(location=[1,3,4,5,6,7,8,9,10,12]).mean('location'),\n           label='May', color=palette(1))\nax[2].set_ylim(4.5,12.5)\nax[5].plot(obs.time.sel(time=slice('04-01-2024', '09-01-2024')),\n           obs['Salinity'].sel(depth=slice(2,5)).mean('depth').sel(HV=[1]).sel(time=slice('04-01-2024', '09-01-2024')).mean('HV'),\n           label='May', color=palette(2))\n\nax[4].plot(s_values_combined.time, s_values_combined.sel(location=[1]).mean('location'),\n           label='May', color=palette(1))\n\n# Plot observed salinity for May 2024\nax[7].plot(obs.time.sel(time=slice('04-01-2024', '09-01-2024')),\n           obs['Temperature'].sel(depth=slice(2,5)).mean('depth').sel(HV=[1]).sel(time=slice('04-01-2024', '09-01-2024')).mean('HV'),\n           label='May', color=palette(2))\nax[7].set_ylim(4.5,12.5)\nax[6].plot(s_values_combined.time, t_values_combined.sel(location=[1]).mean('location'),\n           label='May', color=palette(1))\nax[6].set_ylim(4.5,12.5)\n# Rotate x-axis labels for all subplots\nfor a in ax:\n    a.tick_params(axis='x', rotation=45)  # Adjust rotation angle as needed\n    \n    \nax[0].set_title('salinity for all stations,\\n 5 m depth MODEL')\nax[1].set_title('salinity for all stations,\\n 5 m depth OBS')\nax[2].set_title('temperature for all stations,\\n 5 m depth MODEL')\nax[3].set_title('temperate for all stations,\\n 5 m depth OBS')\nax[4].set_title('salinity for station 1,\\n 5 m depth MODEL')\nax[5].set_title('salinity for station 1,\\n 5 m depth OBS')\nax[6].set_title('temperature for station 1,\\n 5 m depth MODEL')\nax[7].set_title('temperate for station 1,\\n 5 m depth OBS')\nplt.show()\n\n","key":"AAWS4aNLBO"},{"type":"outputs","id":"9E7DXrS9ENmD9WRaMc6G3","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"309245fd0b552952189d71f5a605f5ab","path":"/309245fd0b552952189d71f5a605f5ab.png"},"text/plain":{"content":"<Figure size 1200x480 with 8 Axes>","content_type":"text/plain"}}},"children":[],"key":"B9a97hiyHE"}],"key":"W9UNO3wr64"}],"key":"BIJovlEfnD"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"s_values_combined","key":"iQXfdmQZ0T"},{"type":"outputs","id":"tCwagA-FREbfBF76Ek65x","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":67,"metadata":{},"data":{"text/html":{"content_type":"text/html","hash":"1299beaf7bc87f6bf90466aa7e0e2410","path":"/1299beaf7bc87f6bf90466aa7e0e2410.html"},"text/plain":{"content":"<xarray.DataArray 'salt' (location: 12, time: 144, depth: 1)> Size: 14kB\narray([[[34.57928269],\n        [34.66392677],\n        [34.71920039],\n        ...,\n        [34.6196415 ],\n        [34.68104413],\n        [34.62649604]],\n\n       [[34.20010971],\n        [34.29992175],\n        [34.56100149],\n        ...,\n        [34.59542182],\n        [34.55340279],\n        [34.59314847]],\n\n       [[34.4841973 ],\n        [34.66466217],\n        [34.41018199],\n        ...,\n...\n        ...,\n        [33.69644646],\n        [34.41936063],\n        [34.3297629 ]],\n\n       [[33.91874539],\n        [33.7434176 ],\n        [33.64993956],\n        ...,\n        [34.01743941],\n        [34.2246865 ],\n        [34.12559398]],\n\n       [[32.95074822],\n        [33.7193593 ],\n        [33.96114602],\n        ...,\n        [33.76883865],\n        [34.03096983],\n        [33.45588682]]], shape=(12, 144, 1))\nCoordinates:\n  * time      (time) datetime64[ns] 1kB 2024-04-01T12:00:00 ... 2024-08-21T19...\n    lat       (location) float32 48B 64.27 64.29 64.3 ... 64.38 64.39 64.36\n    lon       (location) float32 48B 338.0 338.1 338.1 ... 338.5 338.5 338.6\n  * depth     (depth) float32 4B 5.0\n  * location  (location) int64 96B 1 2 3 4 5 6 7 8 9 10 11 12\nAttributes:\n    long_name:  salinity\n    units:      PSU","content_type":"text/plain"}}},"children":[],"key":"ErBq0zL7Ov"}],"key":"y17FzwAWUx"}],"key":"bwSb9yU5Ak"}],"key":"ehFfnozcb4"},"references":{"cite":{"order":[],"data":{}}}}