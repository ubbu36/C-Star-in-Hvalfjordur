{"version":3,"kind":"Notebook","sha256":"f442d92044e62edc9a6fe548e7ad23ade1c287dba1017ead5529f84732967a6a","slug":"velocity-analysis-copy2","location":"/velocity_analysis-Copy2.ipynb","dependencies":[],"frontmatter":{"kernelspec":{"name":"xesmf_env","display_name":"xesmf_env","language":"python"},"exports":[{"format":"ipynb","filename":"velocity_analysis-Copy2.ipynb","url":"/velocity_analysis-Co-2c677435677944b7090f5f7f92dd5212.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import subprocess\nimport os\nimport pandas as pd\nimport netCDF4\nimport numpy as np\nimport glob\nimport time\nimport matplotlib.pyplot as plt\nimport copy\nimport xarray as xr\nfrom datetime import datetime, timedelta \nimport dask\nfrom scipy.interpolate import griddata\n#from ocean_c_lab_tools import *\n#from celluloid import Camera \n#import PyCO2SYS as csys\nimport seawater as sw\nfrom roms_regrid import *","key":"HxAZBcRPiV"},{"type":"outputs","id":"eRl6s7U4e0sPC2chZ0hfq","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"/tmp/ipykernel_731590/3005166470.py:17: UserWarning: The seawater library is deprecated! Please use gsw instead.\n  import seawater as sw\n"},"children":[],"key":"v0R0yMfcIh"}],"key":"BsiihmLY4H"}],"key":"LMYEi6nep4"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"\n\n# Define file paths and station names\nstations = [\"HVIN_1\", \"HVNA_1\", \"HVNV_1\", \"HVSA_1\", \"HVSV_1\"]\nfile_paths = {name: f\"/global/cfs/cdirs/m4632/uheede/Hafro_obsdata/{name}new.nc\" for name in stations}\n\n# Dictionary to store datasets\ndatasets = {}\n\nfor name, path in file_paths.items():\n    ds = xr.open_dataset(path)\n\n    # Select valid depth bins\n    good_bins = ds['iigood'].where(ds['iigood'] < 20).to_numpy()\n    good_bins_nn = good_bins[~np.isnan(good_bins)].astype(int)\n    \n    ds = ds.isel(depth_dim=slice(np.min(good_bins_nn), np.max(good_bins_nn)))\n\n    # Store dataset with adjusted longitude\n    datasets[name] = ds.assign_coords(lon=ds['lon'].load() + 360)\n\n","key":"Y9OOtV1j88"},{"type":"outputs","id":"mF2YfdFCSxo-lQyl6u7GA","children":[],"key":"YSWAeqn4y8"}],"key":"zMUa3Kc9LB"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"\n\nsubtract = 739674 - 9189  # Computed constant\nreference_date = pd.to_datetime(\"2000-01-01\")  # Reference date\n\n# Apply transformation to all datasets\nfor name, ds in datasets.items():\n    datetime_series = reference_date + pd.to_timedelta((ds['time'].values - subtract), unit='D')\n    datasets[name] = ds.assign_coords(time_dim=datetime_series)  # Update the time coordinate\n","key":"WTGCHjfcgA"},{"type":"outputs","id":"r-YG0Mw3-t5EDmzCkRNeK","children":[],"key":"eEECYaTKDi"}],"key":"oefSy9ap2l"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"#model=xr.open_mfdataset('/pscratch/sd/u/uheede/Iceland3_phys_hour/z_Iceland3_MARBL_his.202305????????.nc', combine='nested', concat_dim=[\"time\"])\n#model=xr.open_mfdataset('/global/cfs/cdirs/m4746/Users/ulla/Iceland4_multidye_np4/z_Iceland4_linedye_rnd.201206*.nc', combine='nested', concat_dim=[\"time\"])\nmodel=xr.open_mfdataset('/pscratch/sd/u/uheede/Iceland3_riv/z_Iceland3_MARBL_rnd.20230[5-6]????????.nc', combine='nested', concat_dim=[\"time\"])","key":"M5lVUNUMjA"},{"type":"outputs","id":"Eoc1oP0fPUZhBRTJaDlHO","children":[],"key":"PtlFfHsfju"}],"key":"ngMOjueLPN"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"grid=xr.open_mfdataset('/global/cfs/cdirs/m4632/uheede/work/Iceland3_MARBL/INPUT/Iceland3_grd.nc')\n#grid=xr.open_dataset('/global/cfs/cdirs/m4632/uheede/work/Iceland4_BGC/INPUT/Iceland4_grd.nc')","key":"GSSLs8LrWl"},{"type":"outputs","id":"nnSLAXFOZxUHzI0NDizE1","children":[],"key":"PFs4YztQ9z"}],"key":"nL8vOMrICU"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"u_sub=model['u'].sel(depth=-10)\nv_sub=model['v'].sel(depth=-10)","key":"A22MA2xCTW"},{"type":"outputs","id":"BL7Dhv8NDisbG8Y9cLkef","children":[],"key":"UZ472EFYjv"}],"key":"vt0rR2YN2x"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"u_rg=roms_regrid_u(grid,u_sub)\nv_rg=roms_regrid_v(grid,v_sub)","key":"Mk64taCSyM"},{"type":"outputs","id":"b6FJcP3dZvEvuntnrqypG","children":[],"key":"zcgsVRfY2m"}],"key":"zUGiE3eWrC"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"u_rg.load()\nv_rg.load()","key":"CG3a2pUfhk"},{"type":"outputs","id":"BIzE-YEfC_KJ-NxfCeW4B","children":[],"key":"kGjmHPTfwz"}],"key":"jf8XyGYIH0"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"\nreference_date = np.datetime64('2000-01-01T00:00:00')\n\n# Convert seconds to datetime\ndatetime_array = reference_date + (model['ocean_time']).astype('timedelta64[s]')\n","key":"OqRJzDDmGo"},{"type":"outputs","id":"8mIVif9w85-pQ8tjaYt3P","children":[],"key":"HIrk5UZqHz"}],"key":"JfbXOu72nl"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"model['ocean_time']=datetime_array","key":"vQddZNNXMe"},{"type":"outputs","id":"J0QBAxyjLTM2hVoHc8eoA","children":[],"key":"rEP4it5rpr"}],"key":"Px6A0fW1mp"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"datasets","key":"lwsTsEPd95"},{"type":"outputs","id":"ElS7nm-TkcEFrLEvyl656","children":[],"key":"qn8cPzs3Fz"}],"key":"GtYP98X4Yq"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import numpy as np\nimport matplotlib.pyplot as plt\nimport xarray as xr\nfrom windrose import WindroseAxes\n\n# Define the number of stations\nnum_stations = 5\n\n# Define the observation subset time range (2024)\nobs_time_range = slice('2024-05-05', '2024-07-05')\n\n# Define the model subset time range (2023)\nmodel_time_range = slice('2023-05-05', '2023-07-05')\n\n# Create figure for timeseries plots\nfig, axs = plt.subplots(nrows=num_stations, ncols=2, figsize=(12, 3 * num_stations), sharex=False)\nfig.suptitle(\"Timeseries Comparison: Observations (2024) vs Model (2023)\", fontsize=14)\n\nfor i in range(num_stations):\n\n    # Subset observation data for 2024\n    obs=list(datasets.values())[i]\n    obs_subset = obs.sel(time_dim=obs_time_range)\n    depth_index = (np.abs(obs_subset['depth_dim'].values - 10)).argmin()\n    u_obs = obs_subset['u'].isel(depth_dim=depth_index)[::6]  # Every 6th entry\n    obs_lon=obs.lon\n    obs_lat=obs.lat\n    \n    # Extract model data at station location and for the correct time range\n    u_sel = u_rg.sel(lon=obs_lon.values, method='nearest').sel(lat=obs_lat.values, method='nearest')\n    #u_sel = u_sel.sel(time_dim=model_time_range)  # Select only 2023 data\n\n    # Plot observations (2024)\n    axs[i, 0].plot(obs_subset.time_dim[::6], u_obs, label=\"Observed U (2024)\", color=\"blue\")\n    axs[i, 0].set_title(f\"Station {i+1} - Observations (2024)\")\n    axs[i, 0].tick_params(axis='x', rotation=45)\n    axs[i, 0].legend()\n    \n    # Plot model (2023)\n    axs[i, 1].plot(model['ocean_time'], u_sel.squeeze(), label=\"Model U (2023)\", color=\"green\")\n    axs[i, 1].set_title(f\"Station {i+1} - Model (2023)\")\n    axs[i, 1].tick_params(axis='x', rotation=45)\n    axs[i, 1].legend()\n\nplt.tight_layout()\nplt.show()\n\n\n","key":"v3AKlP14qP"},{"type":"outputs","id":"IGU_qDJSVuU5mqcRuOehK","children":[],"key":"GcbIJr8eSH"}],"key":"J3AtuTBeXj"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"obs.lat","key":"qwqlzZlsYI"},{"type":"outputs","id":"whumH1t5n6EQ6qGMM-qY7","children":[],"key":"SRoaI4XtNu"}],"key":"s6ZShrR9DI"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom windrose import WindroseAxes\n\n# Define number of stations\nnum_stations = 1\n\n# Create a figure with 2 columns (Obs & Model) and num_stations rows\nfig = plt.figure(figsize=(14, 7 * num_stations),layout='tight')\n\nfig.suptitle(\"Wind Roses: Observations (2024) vs Model (2023)\", fontsize=16)\n\nfor i in range(1):\n\n    # Compute observed wind speed and direction\n    obs=list(datasets.values())[i]\n    obs_subset = obs.sel(time_dim=obs_time_range)\n    depth_index = (np.abs(obs_subset['depth_dim'].values - 10)).argmin()\n    u_obs = obs_subset['u'].sel(depth_dim=depth_index)[::6]\n    v_obs = obs_subset['v'].sel(depth_dim=depth_index)[::6]\n    obs_lon=obs.lon\n    obs_lat=obs.lat\n    direction_obs = (np.arctan2(-u_obs.squeeze().values, -v_obs.squeeze().values) * (180 / np.pi) + 360) % 360\n    speed_obs = np.sqrt(u_obs.squeeze().values**2 + v_obs.squeeze().values**2)\n\n    # Compute model wind speed and direction\n    u_sel = u_rg.sel(lon=obs_lon.values, method='nearest').sel(lat=obs_lat.values, method='nearest')\n    v_sel = v_rg.sel(lon=obs_lon.values, method='nearest').sel(lat=obs_lat.values, method='nearest')\n    \n    direction_model = (np.arctan2(-u_sel.squeeze().values, -v_sel.squeeze().values) * (180 / np.pi) + 360) % 360\n    speed_model = np.sqrt(u_sel.squeeze().values**2 + v_sel.squeeze().values**2)\n\n    # Define subplot positions using bbox (left, bottom, width, height)\n    ax_obs = WindroseAxes(fig, [0.05, 0.75 - (i * 0.2), 0.4, 0.18])  # Left column\n    fig.add_axes(ax_obs)\n    ax_obs.bar(direction_obs, speed_obs, normed=True, opening=0.8, edgecolor='white', bins=np.linspace(0, 0.6, 7))\n    ax_obs.set_title(str(stations[i])+' - Obs (2024)')\n    ax_obs.set_legend()\n    ax_obs.set_rticks([5, 10, 15, 20, 25, 30])\n    ax_obs.set_yticklabels(['5%', '10%', '15%', '20%', '25%', '30%'])\n    \n    ax_model = WindroseAxes(fig, [0.55, 0.75 - (i * 0.2), 0.4, 0.18])  # Right column\n    fig.add_axes(ax_model)\n    ax_model.bar(direction_model, speed_model, normed=True, opening=0.8, edgecolor='white', bins=np.linspace(0, 0.6, 7))\n    ax_model.set_title(str(stations[i])+' - Model (2023)')\n    ax_model.set_legend()\n    ax_model.set_rticks([5, 10, 15, 20, 25, 30])\n    ax_model.set_yticklabels(['5%', '10%', '15%', '20%', '25%', '30%'])\n\nplt.show()\n","key":"Dq2N83S5bZ"},{"type":"outputs","id":"UcC70cWF_4xc2qR92MAAZ","children":[],"key":"c5pagZJx3J"}],"key":"pVRkPNSZQt"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\n\ndef compute_spectrum(time, signal):\n    \"\"\"Compute the FFT and identify spectral peaks.\"\"\"\n    \n    # Compute FFT\n    n = len(signal)\n    dt = np.mean(np.diff(time))  # Time step (assuming uniform spacing)\n    freq = np.fft.rfftfreq(n, d=dt)  # Compute frequency axis\n    spectrum = np.fft.rfft(signal)   # Compute FFT\n    power = np.abs(spectrum)**2      # Compute Power Spectral Density (PSD)\n    \n    # Find peaks in the power spectrum\n    peaks, _ = find_peaks(power, height=np.max(power) * 0.1)  # Peaks with at least 10% of max power\n    \n    return freq, power, peaks\nreference_time = np.datetime64('2000-01-01T00:00:00', 's')\n\n# Example time series (Replace these with your observed and modeled data)\nobs_time = (obs_subset.time_dim[::6].load() - reference_time).astype('timedelta64[h]').astype(int).values\n# Define reference time (2000-01-01T00:00:00)\n\n\n\nmodel_time = (model['ocean_time'].load() - reference_time).astype('timedelta64[h]').astype(int).load().values# Example time axis (modify as needed)\nobs_time=(obs_time-obs_time[0])*10**(-9)*1/3600\nmodel_time=(model_time-model_time[0])*10**(-9)*1/3600\n\nobserved_signal = u_obs.squeeze().values  # Example signal\nmodeled_signal = u_sel.squeeze().values # Example signal\n\n# Compute spectra\nfreq_obs, power_obs, peaks_obs = compute_spectrum(obs_time, observed_signal)\nfreq_mod, power_mod, peaks_mod = compute_spectrum(model_time, modeled_signal)\n\n# Plot results\nplt.figure(figsize=(10, 5))\n\n# Observed Spectrum\nplt.plot(freq_obs, power_obs, label=\"Observed Spectrum\", color='b')\nplt.scatter(freq_obs[peaks_obs], power_obs[peaks_obs], color='r', label=\"Observed Peaks\", zorder=3)\n\n# Modeled Spectrum\nplt.plot(freq_mod, power_mod, label=\"Modeled Spectrum\", color='g', linestyle='dashed')\nplt.scatter(freq_mod[peaks_mod], power_mod[peaks_mod], color='orange', label=\"Modeled Peaks\", zorder=3)\n\nplt.xlabel(\"Frequency (Hz)\")\nplt.ylabel(\"Power\")\nplt.legend()\nplt.title(\"Spectral Peaks in Observed and Modeled Data\")\nplt.grid()\nplt.show()\n\n","key":"ncOAy8apG0"},{"type":"outputs","id":"aOfGVC2wjDvA8XviMypIX","children":[],"key":"OFaQyvsZkx"}],"key":"ShAkVP5XX5"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\n\ndef compute_spectrum(time, signal):\n    \"\"\"Compute the FFT and identify spectral peaks.\"\"\"\n    \n    # Compute FFT\n    n = len(signal)\n    dt = np.mean(np.diff(time))  # Time step (assuming uniform spacing)\n    freq = np.fft.rfftfreq(n, d=dt)  # Compute frequency axis\n    spectrum = np.fft.rfft(signal)   # Compute FFT\n    power = np.abs(spectrum)**2      # Compute Power Spectral Density (PSD)\n    \n    # Find peaks in the power spectrum\n    peaks, _ = find_peaks(power, height=np.max(power) * 0.1)  # Peaks with at least 10% of max power\n    \n    return freq, power, peaks\n\n# Reference time\nreference_time = np.datetime64('2000-01-01T00:00:00', 's')\n\n# Convert time to hours\nobs_time = (obs_subset.time_dim[::6].load() - reference_time).astype('timedelta64[h]').astype(int).values\nmodel_time = (model['ocean_time'] - reference_time).astype('timedelta64[h]').astype(int).load().values\nobs_time=(obs_time-obs_time[0])*10**(-9)*1/3600\nmodel_time=(model_time-model_time[0])*10**(-9)*1/3600\n\n# Example signals\nobserved_signal = u_obs.squeeze().values  \nmodeled_signal = u_sel.squeeze().values  \n\n# Compute spectra\nfreq_obs, power_obs, peaks_obs = compute_spectrum(obs_time, observed_signal)\nfreq_mod, power_mod, peaks_mod = compute_spectrum(model_time, modeled_signal)\n\n# Convert frequency to period (avoid division by zero)\nperiod_obs = 1 / freq_obs[1:]  # Ignore first value to avoid division by zero\nperiod_mod = 1 / freq_mod[1:]\n\n# Plot results\nplt.figure(figsize=(10, 5))\n\n# Observed Spectrum\nplt.plot(period_obs, power_obs[1:], label=\"Observed Spectrum\", color='b')\n#plt.scatter(period_obs[peaks_obs - 1], power_obs[peaks_obs][1:], color='r', label=\"Observed Peaks\", zorder=3)\n\n# Modeled Spectrum\nplt.plot(period_mod, power_mod[1:], label=\"Modeled Spectrum\", color='g', linestyle='dashed')\n#plt.scatter(period_mod[peaks_mod - 1], power_mod[peaks_mod][1:], color='orange', label=\"Modeled Peaks\", zorder=3)\n\n#plt.xscale(\"log\")  # Log scale to better show long periods\nplt.xlabel(\"Period (hours)\")\nplt.ylabel(\"Power\")\nplt.legend()\nplt.title(\"Spectral Peaks in Observed and Modeled Data\")\nplt.grid(which=\"both\", linestyle=\"--\", linewidth=0.5)\nplt.gca().invert_xaxis()  # Invert x-axis so long periods are on the right\nplt.xlim(1,24*20)\nplt.show()\n","key":"yEDMMfz0qW"},{"type":"outputs","id":"SIxuVFg8IsX4JMck6YBpF","children":[],"key":"WAYxP8K8CD"}],"key":"pUIZ0rmcOK"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import numpy as np\nimport matplotlib.pyplot as plt\n\ndef bandpass_filter(time, signal, min_period=10, max_period=15):\n    \"\"\"Filter the signal to retain only frequencies corresponding to periods between min_period and max_period hours.\"\"\"\n    \n    # Compute FFT\n    n = len(signal)\n    dt = np.mean(np.diff(time))  # Time step in hours\n    freq = np.fft.rfftfreq(n, d=dt)  # Frequency axis (in Hz or cycles per hour)\n    spectrum = np.fft.rfft(signal)   # Compute FFT\n\n    # Convert periods to frequencies\n    min_freq = 1 / max_period  # Lower cutoff frequency\n    max_freq = 1 / min_period  # Upper cutoff frequency\n\n    # Zero out frequencies outside the band\n    spectrum[(freq < min_freq) | (freq > max_freq)] = 0\n\n    # Inverse FFT to reconstruct filtered signal\n    filtered_signal = np.fft.irfft(spectrum, n=n)\n\n    return filtered_signal\n\n# Convert time to hours since reference time\nreference_time = np.datetime64('2000-01-01T00:00:00', 's')\nobs_time = (obs_subset.time_dim[::6].load() - reference_time).astype('timedelta64[h]').astype(int).values\nmodel_time = (model['ocean_time'] - reference_time).astype('timedelta64[h]').astype(int).load().values\nobs_time=(obs_time-obs_time[0])*10**(-9)*1/3600\nmodel_time=(model_time-model_time[0])*10**(-9)*1/3600\n\n# Apply band-pass filter\nu_obs_filtered = bandpass_filter(obs_time, u_obs.squeeze().values, min_period=10, max_period=15)\nu_model_filtered = bandpass_filter(model_time, u_sel.squeeze().values, min_period=10, max_period=15)\n\n# Create figure and subplots\nfig, axs = plt.subplots(nrows=2, ncols=1, figsize=(12, 8), sharex=True)\n\n# Plot filtered observed signal\naxs[0].plot(obs_time, u_obs_filtered, label=\"Filtered Observed (10-15h)\", color='b')\naxs[0].set_ylabel(\"Velocity (m/s)\")\naxs[0].set_title(\"Filtered Observed u_obs (10-15h Period)\")\naxs[0].legend()\naxs[0].grid()\n\n# Plot filtered modeled signal\naxs[1].plot(model_time, u_model_filtered, label=\"Filtered Modeled (10-15h)\", color='g')\naxs[1].set_xlabel(\"Time (hours)\")\naxs[1].set_ylabel(\"Velocity (m/s)\")\naxs[1].set_title(\"Filtered Modeled u_model (10-15h Period)\")\naxs[1].legend()\naxs[1].grid()\n\nplt.tight_layout()\nplt.show()\n","key":"gmmvyl5qbi"},{"type":"outputs","id":"xSp5naAB3OL7wbAnLzx5I","children":[],"key":"weR6UwFBd2"}],"key":"PIx1wRHcmp"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import numpy as np\nimport matplotlib.pyplot as plt\n\ndef highpass_filter(time, signal, cutoff_period=10):\n    \"\"\"Remove frequencies with periods longer than `cutoff_period` hours (high-pass filter).\"\"\"\n\n    # Compute FFT\n    n = len(signal)\n    dt = np.mean(np.diff(time))  # Time step in hours\n    freq = np.fft.rfftfreq(n, d=dt)  # Frequency axis (in Hz or cycles per hour)\n    spectrum = np.fft.rfft(signal)   # Compute FFT\n\n    # Define cutoff frequency\n    cutoff_freq = 1 / cutoff_period  # Frequency corresponding to the longest period to keep\n\n    # Zero out frequencies below the cutoff (i.e., remove long periods)\n    spectrum[freq < cutoff_freq] = 0\n\n    # Inverse FFT to reconstruct the high-pass filtered signal\n    filtered_signal = np.fft.irfft(spectrum, n=n)\n\n    return filtered_signal\n\n# Apply high-pass filter (removing periods ≥ 10 hours)\nu_obs_highpass = highpass_filter(obs_time, u_obs.squeeze().values, cutoff_period=10)\nu_model_highpass = highpass_filter(model_time, u_sel.squeeze().values, cutoff_period=10)\n\n# Create figure and subplots\nfig, axs = plt.subplots(nrows=2, ncols=1, figsize=(12, 8), sharex=True)\n\n# Plot high-pass filtered observed signal\naxs[0].plot(obs_time, u_obs_highpass, label=\"Observed (Periods < 10h)\", color='b')\naxs[0].set_ylabel(\"Velocity (m/s)\")\naxs[0].set_title(\"High-Pass Filtered Observed u_obs (Periods < 10h)\")\naxs[0].legend()\naxs[0].grid()\n\n# Plot high-pass filtered modeled signal\naxs[1].plot(model_time, u_model_highpass, label=\"Modeled (Periods < 10h)\", color='g')\naxs[1].set_xlabel(\"Time (hours)\")\naxs[1].set_ylabel(\"Velocity (m/s)\")\naxs[1].set_title(\"High-Pass Filtered Modeled u_model (Periods < 10h)\")\naxs[1].legend()\naxs[1].grid()\n\nplt.tight_layout()\nplt.show()\n","key":"fkgu45IH1n"},{"type":"outputs","id":"PbU2UsD_006X4XFx4eaLn","children":[],"key":"czcLzfRKjL"}],"key":"Vcv5TU8uUM"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import numpy as np\nimport matplotlib.pyplot as plt\n\ndef lowpass_filter(time, signal, cutoff_period=15):\n    \"\"\"Remove frequencies with periods longer than `cutoff_period` hours (high-pass filter).\"\"\"\n\n    # Compute FFT\n    n = len(signal)\n    dt = np.mean(np.diff(time))  # Time step in hours\n    freq = np.fft.rfftfreq(n, d=dt)  # Frequency axis (in Hz or cycles per hour)\n    spectrum = np.fft.rfft(signal)   # Compute FFT\n\n    # Define cutoff frequency\n    cutoff_freq = 1 / cutoff_period  # Frequency corresponding to the longest period to keep\n\n    # Zero out frequencies below the cutoff (i.e., remove long periods)\n    spectrum[freq > cutoff_freq] = 0\n\n    # Inverse FFT to reconstruct the high-pass filtered signal\n    filtered_signal = np.fft.irfft(spectrum, n=n)\n\n    return filtered_signal\n\n# Apply high-pass filter (removing periods ≥ 10 hours)\nu_obs_lowpass = lowpass_filter(obs_time, u_obs.squeeze().values, cutoff_period=15)\nu_model_lowpass = lowpass_filter(model_time, u_sel.squeeze().values, cutoff_period=15)\n\n# Create figure and subplots\nfig, axs = plt.subplots(nrows=2, ncols=1, figsize=(12, 8), sharex=True)\n\n# Plot high-pass filtered observed signal\naxs[0].plot(obs_time, u_obs_lowpass, label=\"Observed (Periods > 15h)\", color='b')\naxs[0].set_ylabel(\"Velocity (m/s)\")\naxs[0].set_title(\"Low-Pass Filtered Observed u_obs (Periods > 15h)\")\naxs[0].legend()\naxs[0].grid()\n\n# Plot high-pass filtered modeled signal\naxs[1].plot(model_time, u_model_lowpass, label=\"Modeled (Periods > 15h)\", color='g')\naxs[1].set_xlabel(\"Time (hours)\")\naxs[1].set_ylabel(\"Velocity (m/s)\")\naxs[1].set_title(\"Low-Pass Filtered Modeled u_model (Periods > 15h)\")\naxs[1].legend()\naxs[1].grid()\n\nplt.tight_layout()\nplt.show()\n","key":"LUS1ZJXJaz"},{"type":"outputs","id":"MAFVMdi9AG918Etu3vixR","children":[],"key":"c8qfYXPMLn"}],"key":"srFacNeY0b"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import numpy as np\nimport matplotlib.pyplot as plt\n\ndef bandpass_filter(time, signal, low_cutoff=10, high_cutoff=15):\n    \"\"\"Apply a bandpass filter to retain frequencies between `low_cutoff` and `high_cutoff` hours.\"\"\"\n    n = len(signal)\n    dt = np.mean(np.diff(time))\n    freq = np.fft.rfftfreq(n, d=dt)\n    spectrum = np.fft.rfft(signal)\n\n    # Define cutoff frequencies\n    low_freq = 1 / high_cutoff\n    high_freq = 1 / low_cutoff\n\n    # Zero out frequencies outside the band\n    spectrum[(freq < low_freq) | (freq > high_freq)] = 0\n\n    return np.fft.irfft(spectrum, n=n)\n\ndef highpass_filter(time, signal, cutoff_period=10):\n    \"\"\"Remove frequencies with periods longer than `cutoff_period` hours (retain high frequencies).\"\"\"\n    n = len(signal)\n    dt = np.mean(np.diff(time))\n    freq = np.fft.rfftfreq(n, d=dt)\n    spectrum = np.fft.rfft(signal)\n\n    # Define cutoff frequency\n    cutoff_freq = 1 / cutoff_period  \n\n    # Zero out frequencies below the cutoff (remove long periods)\n    spectrum[freq < cutoff_freq] = 0\n\n    return np.fft.irfft(spectrum, n=n)\n\ndef lowpass_filter(time, signal, cutoff_period=15):\n    \"\"\"Remove frequencies with periods shorter than `cutoff_period` hours (retain low frequencies).\"\"\"\n    n = len(signal)\n    dt = np.mean(np.diff(time))\n    freq = np.fft.rfftfreq(n, d=dt)\n    spectrum = np.fft.rfft(signal)\n\n    # Define cutoff frequency\n    cutoff_freq = 1 / cutoff_period  \n\n    # Zero out frequencies above the cutoff (remove short periods)\n    spectrum[freq > cutoff_freq] = 0\n\n    return np.fft.irfft(spectrum, n=n)\n\n# Apply filters to observed and modeled data\nu_obs_bandpass = bandpass_filter(obs_time, u_obs.squeeze().values, low_cutoff=10, high_cutoff=15)\nu_model_bandpass = bandpass_filter(model_time, u_sel.squeeze().values, low_cutoff=10, high_cutoff=15)\n\nu_obs_highpass = highpass_filter(obs_time, u_obs.squeeze().values, cutoff_period=10)\nu_model_highpass = highpass_filter(model_time, u_sel.squeeze().values, cutoff_period=10)\n\nu_obs_lowpass = lowpass_filter(obs_time, u_obs.squeeze().values, cutoff_period=15)\nu_model_lowpass = lowpass_filter(model_time, u_sel.squeeze().values, cutoff_period=15)\n\n# Prepare data for boxplot\ndata = [\n    u_obs_bandpass, u_model_bandpass,\n    u_obs_highpass, u_model_highpass,\n    u_obs_lowpass, u_model_lowpass\n]\n\nlabels = [\n    \"Obs Bandpass (10-15h)\", \"Model Bandpass (10-15h)\",\n    \"Obs High-pass (<10h)\", \"Model High-pass (<10h)\",\n    \"Obs Low-pass (>15h)\", \"Model Low-pass (>15h)\"\n]\n\n# Define colors (Obs = Light Green, Model = Light Blue)\ncolors = ['lightgreen', 'lightblue', 'lightgreen', 'lightblue', 'lightgreen', 'lightblue']\n\n# Create boxplot\nfig, ax = plt.subplots(figsize=(10, 6))\nboxplot = ax.boxplot(data, labels=labels, patch_artist=True, medianprops=dict(color=\"red\"))\n\n# Apply colors to boxes\nfor patch, color in zip(boxplot['boxes'], colors):\n    patch.set_facecolor(color)\n    patch.set_alpha(0.6)  # Transparency for better readability\n\nax.set_ylabel(\"Velocity (m/s)\")\nax.set_title(\"Boxplot of Filtered Velocity Components\")\n\nplt.xticks(rotation=20)  # Rotate labels for better readability\nplt.grid(axis='y', linestyle='--', alpha=0.6)\n\nplt.show()\n","key":"HhJYjchXy1"},{"type":"outputs","id":"3TZ06caWdHHeQA3zSCMMt","children":[],"key":"JTUSShbI7k"}],"key":"Zje4N2mY1P"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"#model=xr.open_mfdataset('/pscratch/sd/u/uheede/Iceland3_riv/z_Iceland3_MARBL_rnd.20230[5-6]????????.nc', combine='nested', concat_dim=[\"time\"])\n\n","key":"FrpaKRyUmO"},{"type":"outputs","id":"1kUvTJwptXZqJXG-YBNgZ","children":[],"key":"JzLWKCBfms"}],"key":"Br8pI44VIB"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"#u=model['u'].sel(depth=[-0,-1,-2,-3,-4,-5,-7,-9,-10,-12,-14,-15,-16,-18,-20,-26,-30,-36,-40,-50,-80]).mean('time')\n#v=model['v'].sel(depth=[-0,-1,-2,-3,-4,-5,-7,-9,-10,-12,-14,-15,-16,-18,-20,-26,-30,-36,-40,-50,-80]).mean('time')\n\n#u=roms_regrid_u(grid,u)\n#v=roms_regrid_v(grid,v)\n#mask=roms_regrid(grid,grid['mask_rho'])\n\n\n","key":"WUtOVl9bFb"},{"type":"outputs","id":"0L8QmjztDsnhNET1jdEpj","children":[],"key":"oOc47lXCfX"}],"key":"juJZzaONEU"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"#u.load()\n#t.to_netcdf('/global/cfs/cdirs/m4746/Users/ulla/run/Iceland3_MARBL/t_06.nc')\n;","key":"lnNeZPvulE"},{"type":"outputs","id":"qPM3hnVs9bslUd1n9mdPZ","children":[],"key":"S4Y2wHSwBx"}],"key":"XLP8NzfCXd"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"#v.load()","key":"ik7HhvQNo0"},{"type":"outputs","id":"21ERasBTQqXVzbNeMYAF8","children":[],"key":"X3jU2DCvKN"}],"key":"NzsHzADsmV"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"datasets","key":"nQSZBgrnfV"},{"type":"outputs","id":"8atcqB3t0JcIYPQJpLq-m","children":[],"key":"A8kMN7Myhu"}],"key":"NyTCX5MT2X"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"","key":"fCuH5h0E8u"},{"type":"outputs","id":"teks9k0iI3DwP435LtAPq","children":[],"key":"KKK9345plC"}],"key":"PruBUVkcki"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"#obs=list(datasets.values())[1]\n\n#plt.plot(obs['u'].mean('time_dim').squeeze(),obs.depth)\n#plt.gca().invert_yaxis()\n\n#u_sel = u.sel(lon=obs_lon.values, method='nearest').sel(lat=obs_lat.values, method='nearest')\n#plt.plot(u_sel.squeeze(),u.depth*(-1))","key":"oWxW3EVlar"},{"type":"outputs","id":"ZkenkaAymzUEVkWhUCwBo","children":[],"key":"cR6dMLgQYe"}],"key":"QXYtvlty8h"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import matplotlib.pyplot as plt\n\n# Create figure and subplots\nfig, axes = plt.subplots(nrows=1, ncols=5, figsize=(20, 5), sharey=True)\n\n# Loop through each dataset and create a subplot\nfor i, (key, obs) in enumerate(datasets.items()):\n    ax = axes[i]  # Select subplot\n    obs=list(datasets.values())[i]\n    obs_lon=obs.lon\n    obs_lat=obs.lat\n    # Plot observed profile\n    ax.plot(obs['u'].mean('time_dim').squeeze(), obs.depth, label=\"Observed\", color='b')\n\n    # Extract nearest model data\n    u_sel = u.sel(lon=obs_lon.values, method='nearest').sel(lat=obs_lat.values, method='nearest')\n\n    # Plot modeled profile\n    ax.plot(u_sel.squeeze(), u.depth * (-1), label=\"Modeled\", color='r')\n\n    # Reverse y-axis\n    ax.invert_yaxis()\n\n    # Titles and labels\n    ax.set_title(f\"Station {i+1}\")\n    if i == 0:\n        ax.set_ylabel(\"Depth (m)\")\n    ax.set_xlabel(\"Velocity (m/s)\")\n    ax.legend()\n\nplt.tight_layout()\nplt.show()\n","key":"SIvkFPj6Bs"},{"type":"outputs","id":"OAEeqA3A9Nw1_IBn58wUI","children":[],"key":"v8Bxvy1zg2"}],"key":"AYRn7efQlk"}],"key":"d401Nhss7X"},"references":{"cite":{"order":[],"data":{}}}}