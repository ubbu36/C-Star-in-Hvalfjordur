{"version":3,"kind":"Notebook","sha256":"a586ef87d87e119433ed0b76992fd6c8a5771add15132fa0f3ac67274b825fa3","slug":"bgc-analysis-copy2","location":"/BGC_analysis-Copy2.ipynb","dependencies":[],"frontmatter":{"kernelspec":{"name":"xesmf_env","display_name":"xesmf_env","language":"python"},"exports":[{"format":"ipynb","filename":"BGC_analysis-Copy2.ipynb","url":"/BGC_analysis-Copy2-272bb57596d728c83769d51470ca5de0.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"import subprocess\nimport os\nimport pandas as pd\n#import netCDF4\nimport numpy as np\nimport glob\nimport time\nimport matplotlib.pyplot as plt\nimport copy\nimport xarray as xr\nfrom datetime import datetime, timedelta \nimport dask\nfrom scipy.interpolate import griddata\n#from ocean_c_lab_tools import *\n#from celluloid import Camera \n#import PyCO2SYS as csys\nimport seawater as sw\nfrom roms_regrid import *","visibility":"show","key":"wMmYLmH67F"},{"type":"outputs","id":"hGFvDPUwfQ5R3XvZL5FdF","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"/tmp/ipykernel_391752/3945946454.py:17: UserWarning: The seawater library is deprecated! Please use gsw instead.\n  import seawater as sw\n"},"children":[],"key":"bjvE7vLenT"}],"visibility":"show","key":"elDl5OpquK"}],"visibility":"show","key":"wDZM5F8V9X"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"xls = pd.ExcelFile('/global/cfs/cdirs/m4632/uheede/Hafro_obsdata/20241210_biogeochemistry_format.xlsx')\ncombo = pd.read_excel(xls, 'Sheet1',decimal='.')\n\n\nobs=xr.Dataset.from_dataframe(combo)\nobs=obs.set_index(index=['HV','depth_bin','date'])\nobs=obs.drop_duplicates('index')\nobs=obs.unstack('index')\nobs=obs.rename(name_dict={'Latitude(°N)':'lat','Longitude(°E)':'lon'})\n\n","visibility":"show","key":"N3MwYpCgH7"},{"type":"outputs","id":"4z_GOomKmjIXC-1tbVck8","children":[],"visibility":"show","key":"MQr5UiNTe1"}],"visibility":"show","key":"HNiSweiV9Z"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"obs","key":"vPAfMuY4dH"},{"type":"outputs","id":"EaU1XxlIMVQom07dAPynA","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":3,"metadata":{},"data":{"text/html":{"content_type":"text/html","hash":"fafa8e3d5051e9d771a5d02dd9b78d18","path":"/fafa8e3d5051e9d771a5d02dd9b78d18.html"},"text/plain":{"content":"<xarray.Dataset> Size: 242kB\nDimensions:       (HV: 10, depth_bin: 8, date: 14)\nCoordinates:\n  * HV            (HV) int64 80B 1 3 4 5 6 7 8 9 10 12\n  * depth_bin     (depth_bin) int64 64B 0 10 20 30 50 60 70 80\n  * date          (date) datetime64[ns] 112B 2024-04-04 ... 2024-11-21\nData variables: (12/27)\n    cruise        (HV, depth_bin, date) object 9kB '46BS0524' '46SF0224' ... nan\n    year          (HV, depth_bin, date) float64 9kB 2.024e+03 2.024e+03 ... nan\n    month         (HV, depth_bin, date) float64 9kB 4.0 4.0 4.0 ... nan nan nan\n    day           (HV, depth_bin, date) float64 9kB 4.0 16.0 26.0 ... nan nan\n    hour          (HV, depth_bin, date) float64 9kB 8.0 12.0 10.0 ... nan nan\n    minute        (HV, depth_bin, date) float64 9kB 56.0 24.0 38.0 ... nan nan\n    ...            ...\n    SiO2          (HV, depth_bin, date) float64 9kB 5.26 2.93 3.93 ... nan nan\n    flask3        (HV, depth_bin, date) object 9kB 301 1055 1073 ... nan nan nan\n    NH4           (HV, depth_bin, date) float64 9kB 0.2681 0.4046 ... nan nan\n    flask4        (HV, depth_bin, date) float64 9kB 3.0 28.0 46.0 ... nan nan\n    TpH           (HV, depth_bin, date) float64 9kB 25.05 25.05 ... nan nan\n    pH @TpH       (HV, depth_bin, date) float64 9kB 7.8 7.829 7.847 ... nan nan","content_type":"text/plain"}}},"children":[],"key":"CFA9mac0YP"}],"key":"eBPP9CQQRl"}],"key":"zymT95vhYG"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"density=sw.dens0(obs['S'],obs['T'])\nobs['Alk']=obs['TA'] * (1 / 1000) * density\nobs['DIC']=obs['DIC'] * (1 / 1000) * density","visibility":"show","key":"KaRW3r0Thj"},{"type":"outputs","id":"LtUVEKt-8vh0iDDM9NRpE","children":[],"visibility":"show","key":"vajNbkZNxr"}],"visibility":"show","key":"dnvWbYPJo5"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"TA0=274\nSref=34\nDIC0=315\nnTA=((obs['Alk']-TA0)/obs['S'])*Sref+TA0\n\nnDIC=((obs['DIC']-DIC0)/obs['S'])*Sref+DIC0","visibility":"show","key":"gFrii3hGQM"},{"type":"outputs","id":"nMhiYUBi5VCSKbLs-7Tlh","children":[],"visibility":"show","key":"cAQlT85QKP"}],"visibility":"show","key":"ulmM08EACU"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"model=xr.open_mfdataset('/pscratch/sd/u/uheede/Iceland3_MARBL_new/z_Iceland3_MARBL_bgc_avg.2023??????????.nc', combine='nested', concat_dim=[\"time\"])\nmodel1=xr.open_mfdataset('/pscratch/sd/u/uheede/Iceland3_MARBL_new/z_Iceland3_MARBL_rnd.2023??????????.nc', combine='nested', concat_dim=[\"time\"])\ns=model1['s'].thin({'depth': 5})\n\nbgc=model[['ALK','DIC','PO4','NO3','SiO3','NH4','O2']]\ngrid=xr.open_mfdataset('/global/cfs/cdirs/m4632/uheede/work/Iceland3_phys/INPUT_RIV/Iceland3_grd.nc')\nbgc=bgc.thin({'depth': 5})\n\nbgc=roms_regrid(grid,bgc.isel(time=slice(0,94)))\ns=roms_regrid(grid,s.isel(time=slice(0,94)))","key":"GEbB6M6TQj"},{"type":"outputs","id":"cMmrR3tJF6sA1Tsf6Bgcu","children":[],"key":"k50XrXZ7k1"}],"key":"xb1yT6mXBO"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"bgc","key":"jGmHjCpV7l"},{"type":"outputs","id":"ItmkSOvSJIYRz2Gabb-oa","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":7,"metadata":{},"data":{"text/html":{"content_type":"text/html","hash":"2c30345c696df070614a1725a09deef7","path":"/2c30345c696df070614a1725a09deef7.html"},"text/plain":{"content":"<xarray.Dataset> Size: 8GB\nDimensions:  (time: 48, depth: 11, lat: 722, lon: 722)\nCoordinates:\n  * depth    (depth) float32 44B -0.0 -2.5 -5.0 -10.0 ... -40.0 -70.0 -140.0\n  * lon      (lon) float64 6kB 337.2 337.2 337.2 337.2 ... 338.7 338.7 338.7\n  * lat      (lat) float64 6kB 63.92 63.92 63.93 63.93 ... 64.57 64.57 64.57\nDimensions without coordinates: time\nData variables:\n    ALK      (time, depth, lat, lon) float32 1GB dask.array<chunksize=(7, 11, 722, 722), meta=np.ndarray>\n    DIC      (time, depth, lat, lon) float32 1GB dask.array<chunksize=(7, 11, 722, 722), meta=np.ndarray>\n    PO4      (time, depth, lat, lon) float32 1GB dask.array<chunksize=(7, 11, 722, 722), meta=np.ndarray>\n    NO3      (time, depth, lat, lon) float32 1GB dask.array<chunksize=(7, 11, 722, 722), meta=np.ndarray>\n    SiO3     (time, depth, lat, lon) float32 1GB dask.array<chunksize=(7, 11, 722, 722), meta=np.ndarray>\n    NH4      (time, depth, lat, lon) float32 1GB dask.array<chunksize=(7, 11, 722, 722), meta=np.ndarray>\n    O2       (time, depth, lat, lon) float32 1GB dask.array<chunksize=(7, 11, 722, 722), meta=np.ndarray>\nAttributes:\n    regrid_method:  bilinear","content_type":"text/plain"}}},"children":[],"key":"p2iv0NXFCx"}],"key":"I057nLFptk"}],"key":"XQsnZB5E9e"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"nTA_model=((bgc['ALK']-TA0)/s)*Sref+TA0\n\nnDIC_model=((bgc['DIC']-DIC0)/s)*Sref+DIC0","key":"X0XmsMVpyl"},{"type":"outputs","id":"RQKzq7teDbo1MvLKah8TD","children":[],"key":"Q4E584rN3f"}],"key":"oXdSmDbhE4"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"bgc['nTA']=nTA_model\nbgc['nDIC']=nDIC_model","key":"kLeRiucqvc"},{"type":"outputs","id":"YqMXlZtVoXVEfZpbh2wUb","children":[],"key":"dBQTvuXg0B"}],"key":"ukhNoRK1ZZ"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"# define location which calculations the average location of each station\ndef get_location(obs, hv_values):\n    locations = []\n    for hv in hv_values:\n        lat = (obs['lat'].sel(HV=hv).isel(depth_bin=0).mean('date').squeeze()).values+0\n        lon = obs['lon'].sel(HV=hv).isel(depth_bin=0).mean('date').squeeze().values + 360\n        locations.append([lat, lon])\n    return locations\n\n# List of HV values\nhv_values = 1,3,5,7,9,10,12\n\n# Get the locations\nlocations = get_location(obs, hv_values)","visibility":"show","key":"yQZNuBG6ns"},{"type":"outputs","id":"uetitftwvFTL6kIQZVkm2","children":[],"visibility":"show","key":"xczugcz7qB"}],"visibility":"show","key":"UNcKdOY3Eg"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"# Assuming locations is a list of lat/lon pairs\nbgc_values = []\n\n# Loop over the first 10 locations and store each selection in t_values\nfor i in range(7):\n    lat, lon = locations[i]\n    \n    # Select the 't' values at the nearest lat/lon\n    bgc_selected = bgc.sel(lat=lat, method='nearest').sel(lon=lon, method='nearest')\n    \n    # Store the result in the list\n    bgc_values.append(bgc_selected)\n\n# Combine the selections into an xarray Dataset or DataArray\nbgc_values_combined = xr.concat(bgc_values, dim='location')\n\n# Assign a location coordinate for clarity (optional)\nbgc_values_combined = bgc_values_combined.assign_coords(location=('location', [1,3,5,7,9,10,12]))\nbgc_values_combined['depth']=bgc_values_combined.depth*(-1)\n","visibility":"show","key":"xBWZ8uLjcY"},{"type":"outputs","id":"qEZ_HxW4-9IZm-CHQKVdD","children":[],"visibility":"show","key":"XcvLWuOeJ0"}],"visibility":"show","key":"FvBOnsiLhQ"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"\n#x=xr.open_mfdataset('/pscratch/sd/u/uheede/from_expanse/Iceland3/*', combine='nested', concat_dim=[\"time\"])\n\n# open grid\ngrid=xr.open_mfdataset('/global/cfs/cdirs/m4632/uheede/roms_setups/Iceland3_MARBL/1.Make_grid/Iceland3_grd.nc')\n\n\n\n# regridding\nh=roms_regrid(grid,grid['h'])\n\nmask=roms_regrid(grid,grid['mask_rho'])\n\n;","visibility":"show","key":"llMGyfhB49"},{"type":"outputs","id":"ZbAsFP-BVog2giHULYYuB","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":12,"metadata":{},"data":{"text/plain":{"content":"''","content_type":"text/plain"}}},"children":[],"key":"X5OLOWAlZz"}],"visibility":"show","key":"rIhYJljY11"}],"visibility":"show","key":"xv9lctx86t"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"reference_date = np.datetime64('2000-01-01T00:00:00')\ndatetime_array = reference_date + (model['ocean_time']).astype('timedelta64[s]')\nmodel['ocean_time']=datetime_array","key":"s2adK2KoiT"},{"type":"outputs","id":"3Cdr9AgkYJrknaKaUwWNv","children":[],"key":"n97AhGwQKI"}],"key":"aeznGnzAOH"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"bgc_values_combined=bgc_values_combined.assign_coords(time=model['ocean_time'])","key":"c2awboJ9wF"},{"type":"outputs","id":"kS9UWuQp-wLHbhYo2Qz_6","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"/tmp/ipykernel_391752/659707699.py:1: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  bgc_values_combined=bgc_values_combined.assign_coords(time=model['ocean_time'])\n/tmp/ipykernel_391752/659707699.py:1: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  bgc_values_combined=bgc_values_combined.assign_coords(time=model['ocean_time'])\n"},"children":[],"key":"Aege3Y32hl"}],"key":"nW08BXQbM3"}],"key":"dqH3f8XJub"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"bgc_sub=bgc_values_combined.sel(time=(['2023-04-17T00:00:00.000000000', '2023-04-18T00:00:00.000000000',\n       '2023-04-26T00:00:00.000000000', '2023-05-13T00:00:00.000000000',\n       '2023-05-28T00:00:00.000000000', '2023-06-11T00:00:00.000000000',\n       '2023-06-26T00:00:00.000000000','2023-07-09T00:00:00.000000000','2023-07-25T00:00:00.000000000']), method='nearest')","key":"HxHoMvKAhr"},{"type":"outputs","id":"b82KhuknqobkBPUC8MRNx","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"/tmp/ipykernel_391752/1447354073.py:1: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  bgc_sub=bgc_values_combined.sel(time=(['2023-04-17T00:00:00.000000000', '2023-04-18T00:00:00.000000000',\n"},"children":[],"key":"EEej8PNQuo"}],"key":"CddhuTbXxB"}],"key":"eOAxlnSQuD"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"bgc_sub.load()","key":"xdBgV6h031"},{"type":"outputs","id":"_5T_bSzNndfj_2sw0Eb88","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"/global/homes/u/uheede/.conda/envs/xesmf_env/lib/python3.12/site-packages/dask/_task_spec.py:651: RuntimeWarning: divide by zero encountered in divide\n  return self.func(*new_argspec)\n/global/homes/u/uheede/.conda/envs/xesmf_env/lib/python3.12/site-packages/dask/_task_spec.py:651: RuntimeWarning: divide by zero encountered in divide\n  return self.func(*new_argspec)\n/global/homes/u/uheede/.conda/envs/xesmf_env/lib/python3.12/site-packages/dask/_task_spec.py:651: RuntimeWarning: divide by zero encountered in divide\n  return self.func(*new_argspec)\n/global/homes/u/uheede/.conda/envs/xesmf_env/lib/python3.12/site-packages/dask/_task_spec.py:651: RuntimeWarning: divide by zero encountered in divide\n  return self.func(*new_argspec)\n/global/homes/u/uheede/.conda/envs/xesmf_env/lib/python3.12/site-packages/dask/_task_spec.py:651: RuntimeWarning: divide by zero encountered in divide\n  return self.func(*new_argspec)\n/global/homes/u/uheede/.conda/envs/xesmf_env/lib/python3.12/site-packages/dask/_task_spec.py:651: RuntimeWarning: divide by zero encountered in divide\n  return self.func(*new_argspec)\n/global/homes/u/uheede/.conda/envs/xesmf_env/lib/python3.12/site-packages/dask/_task_spec.py:651: RuntimeWarning: divide by zero encountered in divide\n  return self.func(*new_argspec)\n/global/homes/u/uheede/.conda/envs/xesmf_env/lib/python3.12/site-packages/dask/_task_spec.py:651: RuntimeWarning: divide by zero encountered in divide\n  return self.func(*new_argspec)\n"},"children":[],"key":"TTMWMflVuD"},{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":16,"metadata":{},"data":{"text/html":{"content_type":"text/html","hash":"62e259a505585e69020a94041e72e8c5","path":"/62e259a505585e69020a94041e72e8c5.html"},"text/plain":{"content":"<xarray.Dataset> Size: 25kB\nDimensions:   (location: 7, time: 9, depth: 11)\nCoordinates:\n  * depth     (depth) float32 44B 0.0 2.5 5.0 10.0 15.0 ... 30.0 40.0 70.0 140.0\n    lon       (location) float64 56B 338.0 338.1 338.2 338.3 338.4 338.5 338.5\n    lat       (location) float64 56B 64.26 64.3 64.34 64.36 64.39 64.38 64.36\n  * location  (location) int64 56B 1 3 5 7 9 10 12\n  * time      (time) datetime64[ns] 72B 2023-04-20T23:59:20 ... 2023-06-08\nData variables:\n    ALK       (location, time, depth) float32 3kB 2.288e+03 2.288e+03 ... nan\n    DIC       (location, time, depth) float32 3kB 2.101e+03 2.101e+03 ... nan\n    PO4       (location, time, depth) float32 3kB 0.4982 0.5009 ... nan nan\n    NO3       (location, time, depth) float32 3kB 18.18 18.14 18.1 ... nan nan\n    SiO3      (location, time, depth) float32 3kB 6.596 6.596 6.596 ... nan nan\n    NH4       (location, time, depth) float32 3kB 6.573 6.47 6.414 ... nan nan\n    O2        (location, time, depth) float32 3kB 328.8 328.9 329.0 ... nan nan\n    nTA       (location, time, depth) float32 3kB 2.26e+03 2.26e+03 ... nan nan\n    nDIC      (location, time, depth) float32 3kB 2.076e+03 2.076e+03 ... nan\nAttributes:\n    regrid_method:  bilinear","content_type":"text/plain"}}},"children":[],"key":"Lo69l3MuIE"}],"key":"wAsulUE47q"}],"key":"VWrPFuvm6j"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Define depth levels\nlevels = np.arange(0, 80)\n\n# Create figure and subplots (3 rows: 1 for the map, 2 for boxplots)\nfig = plt.figure(figsize=(12, 13))  # Wider figure for side-by-side plots\ngs = fig.add_gridspec(3, 2, height_ratios=[2, 1, 1], width_ratios=[1, 1])  \n\n# --- Shared Map (Top Row, Spanning Both Columns) ---\nax_map = fig.add_subplot(gs[0, :], projection=ccrs.PlateCarree())\n\n# Plot bathymetry\ncf1 = ax_map.contourf(h.lon, h.lat, h, levels, transform=ccrs.PlateCarree(), cmap='cividis')\nax_map.contourf(h.lon, h.lat, mask.where(mask != 1), cmap='Greys', transform=ccrs.PlateCarree())\n\n# Add station labels\nfor i, e in enumerate(locations):\n    ax_map.text(e[1], e[0], hv_values[i], color='red', size=10, ha='center', va='center', transform=ccrs.PlateCarree())\n\n# Gridlines\ngls = ax_map.gridlines(crs=ccrs.PlateCarree(), draw_labels=True, color='darkgray', alpha=0.5, linestyle='--')\ngls.top_labels = False\ngls.right_labels = False\n\n# Colorbar\ncb1 = plt.colorbar(cf1, shrink=0.5, ax=ax_map, orientation='horizontal', pad=0.05)\ncb1.set_label('Bottom Depth (m)', fontsize=10)\n\nax_map.set_extent([-22, -21.35, 64.25, 64.45], ccrs.PlateCarree())\nax_map.set_title('Station Overview')\n\n# --- Function for Extracting Data ---\ndef extract_cruise_data(var, depth=None, num_cruises=10):\n    \"\"\"Extracts non-NaN values for a given variable across cruises.\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(date=i) if depth is None else var.isel(date=i, depth_bin=depth))\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\ndef extract_model_data(var, depth=None, num_cruises=9):\n    \"\"\"Extracts non-NaN values from the model across time steps.\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(time=i) if depth is None else var.isel(time=i, depth=depth))\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\n# --- Boxplots for Observations (Left) and Model (Right) ---\nax_obs = fig.add_subplot(gs[1, 0])  # Observations\nax_model = fig.add_subplot(gs[1, 1])  # Model\n\nax_obs.boxplot(extract_cruise_data(nTA), patch_artist=True)\nax_obs.set_title('Salinity Normalized Alk Variation (Observed)')\nax_obs.set_ylabel('mmol/m$^3$')\nax_obs.set_xticklabels([])\nax_obs.set_ylim(2280,2370)\n\nax_model.boxplot(extract_model_data(bgc_sub['nTA']), patch_artist=True)\nax_model.set_title('Salinity Normalized Alk Variation (Model)')\nax_model.set_xticklabels([])\nax_model.set_ylim(2230,2320)\n\n# --- Surface-Only Boxplots for Observations (Left) and Model (Right) ---\nax_obs_surface = fig.add_subplot(gs[2, 0])  # Observations (Surface)\nax_model_surface = fig.add_subplot(gs[2, 1])  # Model (Surface)\n\nax_obs_surface.boxplot(extract_cruise_data(nTA, depth=0), patch_artist=True)\nax_obs_surface.set_title('Salinity Normalized Alk, Surface Only (Observed)')\nax_obs_surface.set_xlabel('Cruise')\nax_obs_surface.set_ylabel('mmol/m$^3$')\nax_obs_surface.set_xticklabels(pd.to_datetime(obs['date'].isel(date=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\nax_obs_surface.set_ylim(2310,2390)\n\nax_model_surface.boxplot(extract_model_data(bgc_sub['nTA'], depth=0), patch_artist=True)\nax_model_surface.set_title('Salinity Normalized Alk, Surface Only (Model)')\nax_model_surface.set_xlabel('Cruise')\nax_model_surface.set_ylabel('mmol/m$^3$')\nax_model_surface.set_xticklabels(pd.to_datetime(bgc_sub['time']).strftime('%d/%m/%Y'), rotation=45)\nax_model_surface.set_ylim(2230,2310)\n\nplt.tight_layout()\nplt.show()\n","key":"XUB0OH0eFP"},{"type":"outputs","id":"IZwbbcrE-HsMHkUY2R_tg","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"29fcf39f56982bf22d2260862009176a","path":"/29fcf39f56982bf22d2260862009176a.png"},"text/plain":{"content":"<Figure size 1200x1300 with 6 Axes>","content_type":"text/plain"}}},"children":[],"key":"fmNMKJruu0"}],"key":"NgMfiAMmb1"}],"key":"R0PgtIQzHU"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Define depth levels\nlevels = np.arange(0, 80)\n\n# Create figure and subplots (3 rows: 1 for the map, 2 for boxplots)\nfig = plt.figure(figsize=(12, 7))  # Wider figure for side-by-side plots\ngs = fig.add_gridspec(2, 2, height_ratios=[1, 1], width_ratios=[1, 1])  \n\n\n\n# --- Function for Extracting Data ---\ndef extract_cruise_data(var, depth=None, num_cruises=10):\n    \"\"\"Extracts non-NaN values for a given variable across cruises.\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(date=i) if depth is None else var.isel(date=i, depth_bin=depth))\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\ndef extract_model_data(var, depth=None, num_cruises=9):\n    \"\"\"Extracts non-NaN values from the model across time steps.\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(time=i) if depth is None else var.isel(time=i, depth=depth))\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\n# --- Boxplots for Observations (Left) and Model (Right) ---\nax_obs = fig.add_subplot(gs[0, 0])  # Observations\nax_model = fig.add_subplot(gs[0, 1])  # Model\n\nax_obs.boxplot(extract_cruise_data(nDIC), patch_artist=True)\nax_obs.set_title('Salinity Normalized DIC Variation (Observed)')\nax_obs.set_ylabel('mmol/m$^3$')\nax_obs.set_xticklabels([])\nax_obs.set_ylim(2070,2180)\n\nax_model.boxplot(extract_model_data(bgc_sub['nDIC']), patch_artist=True)\nax_model.set_title('Salinity Normalized DIC Variation (Model)')\nax_model.set_xticklabels([])\nax_model.set_ylim(2030,2140)\n\n# --- Surface-Only Boxplots for Observations (Left) and Model (Right) ---\nax_obs_surface = fig.add_subplot(gs[1, 0])  # Observations (Surface)\nax_model_surface = fig.add_subplot(gs[1, 1])  # Model (Surface)\n\nax_obs_surface.boxplot(extract_cruise_data(nDIC, depth=0), patch_artist=True)\nax_obs_surface.set_title('Salinity Normalized DIC, Surface Only (Observed)')\nax_obs_surface.set_xlabel('Cruise')\nax_obs_surface.set_ylabel('mmol/m$^3$')\nax_obs_surface.set_xticklabels(pd.to_datetime(obs['date'].isel(date=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\nax_obs_surface.set_ylim(2070,2180)\n\nax_model_surface.boxplot(extract_model_data(bgc_sub['nDIC'], depth=0), patch_artist=True)\nax_model_surface.set_title('Salinity Normalized DIC, Surface Only (Model)')\nax_model_surface.set_xlabel('Cruise')\nax_model_surface.set_ylabel('mmol/m$^3$')\nax_model_surface.set_xticklabels(pd.to_datetime(bgc_sub['time'].isel(time=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\nax_model_surface.set_ylim()\nax_model_surface.set_ylim(2030,2150)\n\nplt.tight_layout()\nplt.show()\n","key":"q6BW7X2O5H"},{"type":"outputs","id":"GtfEuBjO7cD1J1JH6EpVc","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"/tmp/ipykernel_391752/3186183734.py:62: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  ax_model_surface.set_xticklabels(pd.to_datetime(bgc_sub['time'].isel(time=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\n"},"children":[],"key":"cbDdNNhhJa"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"e9d35d1d7191c604f608a3d0e9eae47f","path":"/e9d35d1d7191c604f608a3d0e9eae47f.png"},"text/plain":{"content":"<Figure size 1200x700 with 4 Axes>","content_type":"text/plain"}}},"children":[],"key":"lnXra1y2Tk"}],"key":"AQdYums470"}],"key":"gDaDn0jbgt"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"loc = obs['lon'].sel(HV=[1,5,9,10]).isel(depth_bin=0).mean('date').values\ndepth=obs['depth_bin'].values\nlevels=np.arange(2290,2360,2)\n\nbins = np.arange(0, 90, 10) \n#depth_bins = xr.DataArray(pd.cut(depth, bins, labels=bins[:-1]), dims=\"depth\", name=\"binned_depth\")\n\ndata_alk1=nTA.sel(HV=[1,5,9,10]).isel(date=slice(0,9)).mean('date')\ndata_alk2=obs['Alk'].sel(HV=[1,5,9,10]).isel(date=slice(0,9)).mean('date')\n\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(6*2, 3), constrained_layout=True)\nax = axarr.flatten()\n\n#c0=ax[0].contourf(loc, data_alk.depth, data_alk.transpose())\nc0=ax[0].contourf(loc,data_alk1.depth_bin,data_alk1.transpose(),levels)\nplt.colorbar(c0,ax=ax[0], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[0].invert_yaxis()\nax[0].set_title('salinity normalized alkalinity along fjord (observed)')\nax[0].set_xlabel('longitude')\nax[0].set_ylabel('depth (m)')\n\nc0=ax[1].contourf(loc,data_alk2.depth_bin,data_alk2.transpose(),levels)\nplt.colorbar(c0,ax=ax[1], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[1].invert_yaxis()\nax[1].set_title('alkalinity along fjord (observed)')\nax[1].set_xlabel('longitude')\nax[1].set_ylabel('depth (m)')","key":"SaKjIDm0xV"},{"type":"outputs","id":"wP0jQqKWdStA5b1YCK1hg","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"3a539b056564161c41e502780f616a2b","path":"/3a539b056564161c41e502780f616a2b.png"},"text/plain":{"content":"<Figure size 1200x300 with 4 Axes>","content_type":"text/plain"}}},"children":[],"key":"LP5qbZOSXA"}],"key":"iA4eyuWuTh"}],"key":"Br5tNPrDY1"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"loc = obs['lon'].sel(HV=[1,5,9,10]).isel(depth_bin=0).mean('date').values\ndepth=obs['depth_bin'].values\nlevels=np.arange(2230,2300,2)\n\nbins = np.arange(0, 90, 10) \n#depth_bins = xr.DataArray(pd.cut(depth, bins, labels=bins[:-1]), dims=\"depth\", name=\"binned_depth\")\n\ndata_alk1=bgc_sub['nTA'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean('time')\ndata_alk2=bgc_sub['ALK'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean('time')\n\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(6*2, 3), constrained_layout=True)\nax = axarr.flatten()\n\n#c0=ax[0].contourf(loc, data_alk.depth, data_alk.transpose())\nc0=ax[0].contourf(loc,data_alk1.depth,data_alk1.transpose(),levels)\nplt.colorbar(c0,ax=ax[0], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[0].set_ylim(0,40)\nax[0].invert_yaxis()\nax[0].set_title('salinity normalized alkalinity along fjord (modeled)')\nax[0].set_xlabel('longitude')\nax[0].set_ylabel('depth (m)')\n\n\nc0=ax[1].contourf(loc,data_alk2.depth,data_alk2.transpose(),levels)\nplt.colorbar(c0,ax=ax[1], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[1].set_ylim(0,40)\nax[1].invert_yaxis()\nax[1].set_title('alkalinity along fjord (modeled)')\nax[1].set_xlabel('longitude')\nax[1].set_ylabel('depth (m)')","key":"Sp4uMVw1LV"},{"type":"outputs","id":"wP17wCS965-hk75hv4afs","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"/tmp/ipykernel_391752/2901242744.py:8: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  data_alk1=bgc_sub['nTA'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean('time')\n/tmp/ipykernel_391752/2901242744.py:9: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  data_alk2=bgc_sub['ALK'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean('time')\n"},"children":[],"key":"taOG7s2VpO"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"77e6c09ec978e924eabeef8b94e461ed","path":"/77e6c09ec978e924eabeef8b94e461ed.png"},"text/plain":{"content":"<Figure size 1200x300 with 4 Axes>","content_type":"text/plain"}}},"children":[],"key":"ZlKQwUxtJv"}],"key":"GE1zfOiH7a"}],"key":"hoXLgfC3TO"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import matplotlib.pyplot as plt\nimport numpy as np\n\n# Compute mean and standard deviation over time for observations\ndepth_obs = obs['depth_bin'].values\ndepth_model = bgc_sub['depth'].values\n\n# Observations (Mean and Std Dev)\nalk_mean_obs = obs['Alk'].sel(HV=[1,5,9,10]).isel(date=slice(0,9)).mean(dim=['date', 'HV'])\nalk_std_obs = obs['Alk'].sel(HV=[1,5,9,10]).isel(date=slice(0,9)).std(dim=['date', 'HV'])\n\nnalk_mean_obs = nTA.sel(HV=[1,5,9,10]).isel(date=slice(0,9)).mean(dim=['date', 'HV'])\nnalk_std_obs = nTA.sel(HV=[1,5,9,10]).isel(date=slice(0,9)).std(dim=['date', 'HV'])\n\n# Model (Mean and Std Dev)\nalk_mean_model = bgc_sub['ALK'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean(dim=['time', 'location'])\nalk_std_model = bgc_sub['ALK'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).std(dim=['time', 'location'])\n\nnalk_mean_model = bgc_sub['nTA'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean(dim=['time', 'location'])\nnalk_std_model = bgc_sub['nTA'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).std(dim=['time', 'location'])\n\n# Create figure with 2 columns (nTA on left, TA on right)\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(12, 6), constrained_layout=True)\nax = axarr.flatten()\n\n# --- Plot Salinity Normalized Alkalinity (nTA) ---\nax[0].plot(nalk_mean_obs, depth_obs, marker='o', linestyle='-', color='b', label='Observed nTA')\nax[0].fill_betweenx(depth_obs, nalk_mean_obs - nalk_std_obs, nalk_mean_obs + nalk_std_obs, color='gray', alpha=0.3)\n\nax[0].plot(nalk_mean_model, depth_model, marker='s', linestyle='--', color='r', label='Modeled nTA')\nax[0].fill_betweenx(depth_model, nalk_mean_model - nalk_std_model, nalk_mean_model + nalk_std_model, color='pink', alpha=0.3)\n\nax[0].set_ylim(0,30)\nax[0].invert_yaxis()\nax[0].set_xlabel('Salinity Normalized Alkalinity (mmol/m³)')\nax[0].set_ylabel('Depth (m)')\nax[0].set_title('Salinity Normalized Alkalinity Profile')\nax[0].legend()\nax[0].grid()\n\n# --- Plot Total Alkalinity (TA) ---\nax[1].plot(alk_mean_obs, depth_obs, marker='o', linestyle='-', color='b', label='Observed TA')\nax[1].fill_betweenx(depth_obs, alk_mean_obs - alk_std_obs, alk_mean_obs + alk_std_obs, color='gray', alpha=0.3)\n\nax[1].plot(alk_mean_model, depth_model, marker='s', linestyle='--', color='r', label='Modeled TA')\nax[1].fill_betweenx(depth_model, alk_mean_model - alk_std_model, alk_mean_model + alk_std_model, color='pink', alpha=0.3)\nax[1].set_ylim(0,30)\nax[1].invert_yaxis()\nax[1].set_xlabel('Total Alkalinity (mmol/m³)')\nax[1].set_title('Total Alkalinity Profile')\nax[1].legend()\nax[1].grid()\n\nplt.show()\n","key":"AcvNpqse4K"},{"type":"outputs","id":"3fhbjavjOUlkUmuitIzQk","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"/tmp/ipykernel_391752/2478640675.py:16: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  alk_mean_model = bgc_sub['ALK'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean(dim=['time', 'location'])\n/tmp/ipykernel_391752/2478640675.py:17: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  alk_std_model = bgc_sub['ALK'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).std(dim=['time', 'location'])\n/global/homes/u/uheede/.conda/envs/xesmf_env/lib/python3.12/site-packages/numpy/lib/_nanfunctions_impl.py:2035: RuntimeWarning: Degrees of freedom <= 0 for slice.\n  var = nanvar(a, axis=axis, dtype=dtype, out=out, ddof=ddof,\n/tmp/ipykernel_391752/2478640675.py:19: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  nalk_mean_model = bgc_sub['nTA'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean(dim=['time', 'location'])\n/tmp/ipykernel_391752/2478640675.py:20: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  nalk_std_model = bgc_sub['nTA'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).std(dim=['time', 'location'])\n/global/homes/u/uheede/.conda/envs/xesmf_env/lib/python3.12/site-packages/numpy/lib/_nanfunctions_impl.py:2035: RuntimeWarning: Degrees of freedom <= 0 for slice.\n  var = nanvar(a, axis=axis, dtype=dtype, out=out, ddof=ddof,\n"},"children":[],"key":"Sid3Ab8tlg"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"bba24d63ab58f26ad6eb522ba27027de","path":"/bba24d63ab58f26ad6eb522ba27027de.png"},"text/plain":{"content":"<Figure size 1200x600 with 2 Axes>","content_type":"text/plain"}}},"children":[],"key":"xbCxmfUkgZ"}],"key":"FM3JoyXrVv"}],"key":"nf9jeMtBYL"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import matplotlib.pyplot as plt\nimport numpy as np\n\n# Compute mean and standard deviation over time for observations\ndepth_obs = obs['depth_bin'].values\ndepth_model = bgc_sub['depth'].values\n\n# Observations (Mean and Std Dev)\nalk_mean_obs = obs['DIC'].sel(HV=[1,5,9,10]).isel(date=slice(0,9)).mean(dim=['date', 'HV'])\nalk_std_obs = obs['DIC'].sel(HV=[1,5,9,10]).isel(date=slice(0,9)).std(dim=['date', 'HV'])\n\nnalk_mean_obs = nDIC.sel(HV=[1,5,9,10]).isel(date=slice(0,9)).mean(dim=['date', 'HV'])\nnalk_std_obs = nDIC.sel(HV=[1,5,9,10]).isel(date=slice(0,9)).std(dim=['date', 'HV'])\n\n# Model (Mean and Std Dev)\nalk_mean_model = bgc_sub['DIC'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean(dim=['time', 'location'])\nalk_std_model = bgc_sub['DIC'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).std(dim=['time', 'location'])\n\nnalk_mean_model = bgc_sub['nDIC'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean(dim=['time', 'location'])\nnalk_std_model = bgc_sub['nDIC'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).std(dim=['time', 'location'])\n\n# Create figure with 2 columns (nTA on left, TA on right)\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(12, 6), constrained_layout=True)\nax = axarr.flatten()\n\n# --- Plot Salinity Normalized Alkalinity (nTA) ---\nax[0].plot(nalk_mean_obs, depth_obs, marker='o', linestyle='-', color='b', label='Observed nTA')\nax[0].fill_betweenx(depth_obs, nalk_mean_obs - nalk_std_obs, nalk_mean_obs + nalk_std_obs, color='gray', alpha=0.3)\n\nax[0].plot(nalk_mean_model, depth_model, marker='s', linestyle='--', color='r', label='Modeled nTA')\nax[0].fill_betweenx(depth_model, nalk_mean_model - nalk_std_model, nalk_mean_model + nalk_std_model, color='pink', alpha=0.3)\n\nax[0].set_ylim(0,30)\nax[0].invert_yaxis()\nax[0].set_xlabel('Salinity Normalized DIC (mmol/m³)')\nax[0].set_ylabel('Depth (m)')\nax[0].set_title('Salinity Normalized DIC Profile')\nax[0].legend()\nax[0].grid()\n\n# --- Plot Total Alkalinity (TA) ---\nax[1].plot(alk_mean_obs, depth_obs, marker='o', linestyle='-', color='b', label='Observed TA')\nax[1].fill_betweenx(depth_obs, alk_mean_obs - alk_std_obs, alk_mean_obs + alk_std_obs, color='gray', alpha=0.3)\n\nax[1].plot(alk_mean_model, depth_model, marker='s', linestyle='--', color='r', label='Modeled TA')\nax[1].fill_betweenx(depth_model, alk_mean_model - alk_std_model, alk_mean_model + alk_std_model, color='pink', alpha=0.3)\nax[1].set_ylim(0,30)\nax[1].invert_yaxis()\nax[1].set_xlabel('Total DIC (mmol/m³)')\nax[1].set_title('Total DIC Profile')\nax[1].legend()\nax[1].grid()\n\nplt.show()\n","key":"wNSAr3bUWs"},{"type":"outputs","id":"ndy94Cfca1GhSsluHuTc7","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"/tmp/ipykernel_391752/1191234110.py:16: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  alk_mean_model = bgc_sub['DIC'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean(dim=['time', 'location'])\n/tmp/ipykernel_391752/1191234110.py:17: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  alk_std_model = bgc_sub['DIC'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).std(dim=['time', 'location'])\n/global/homes/u/uheede/.conda/envs/xesmf_env/lib/python3.12/site-packages/numpy/lib/_nanfunctions_impl.py:2035: RuntimeWarning: Degrees of freedom <= 0 for slice.\n  var = nanvar(a, axis=axis, dtype=dtype, out=out, ddof=ddof,\n/tmp/ipykernel_391752/1191234110.py:19: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  nalk_mean_model = bgc_sub['nDIC'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).mean(dim=['time', 'location'])\n/tmp/ipykernel_391752/1191234110.py:20: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  nalk_std_model = bgc_sub['nDIC'].sel(location=[1,5,9,10]).isel(time=slice(2,7)).std(dim=['time', 'location'])\n/global/homes/u/uheede/.conda/envs/xesmf_env/lib/python3.12/site-packages/numpy/lib/_nanfunctions_impl.py:2035: RuntimeWarning: Degrees of freedom <= 0 for slice.\n  var = nanvar(a, axis=axis, dtype=dtype, out=out, ddof=ddof,\n"},"children":[],"key":"jZBrLsy1Vv"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"7d97e2669c9e50283e51c17fbc0da8ad","path":"/7d97e2669c9e50283e51c17fbc0da8ad.png"},"text/plain":{"content":"<Figure size 1200x600 with 2 Axes>","content_type":"text/plain"}}},"children":[],"key":"ekzzibBNkj"}],"key":"jgwyt4x36D"}],"key":"ekRC5lW2JT"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"loc = obs['lon'].sel(HV=[1,5,9,10]).isel(depth_bin=0).mean('date').values\ndepth=obs['depth_bin'].values\nlevels=np.arange(2070,2160,2)\n\nbins = np.arange(0, 90, 10) \n#depth_bins = xr.DataArray(pd.cut(depth, bins, labels=bins[:-1]), dims=\"depth\", name=\"binned_depth\")\n\ndata_alk1=nDIC.sel(HV=[1,5,9,10]).isel(date=slice(0,4)).mean('date')\ndata_alk2=nDIC.sel(HV=[1,5,9,10]).isel(date=slice(5,9)).mean('date')\n\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(6*2, 3), constrained_layout=True)\nax = axarr.flatten()\n\n#c0=ax[0].contourf(loc, data_alk.depth, data_alk.transpose())\nc0=ax[0].contourf(loc,data_alk1.depth_bin,data_alk1.transpose(),levels)\nplt.colorbar(c0,ax=ax[0], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[0].invert_yaxis()\nax[0].set_title('salinity normalized DIC along fjord April-May (observed)')\nax[0].set_xlabel('longitude')\nax[0].set_ylabel('depth (m)')\n\nc0=ax[1].contourf(loc,data_alk2.depth_bin,data_alk2.transpose(),levels)\nplt.colorbar(c0,ax=ax[1], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[1].invert_yaxis()\nax[1].set_title('salinity normalized DIC along fjord June-August (observed)')\nax[1].set_xlabel('longitude')\nax[1].set_ylabel('depth (m)')","key":"ve25YlW2le"},{"type":"outputs","id":"2BLy_V6294oSc-JbPRIpx","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"621a6938f12902547c570b7b274f0797","path":"/621a6938f12902547c570b7b274f0797.png"},"text/plain":{"content":"<Figure size 1200x300 with 4 Axes>","content_type":"text/plain"}}},"children":[],"key":"r4RCvNXc1N"}],"key":"rM5iLG3Yb6"}],"key":"e2JgVMb6jt"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"loc = obs['lon'].sel(HV=[1,5,9,10]).isel(depth_bin=0).mean('date').values\ndepth=obs['depth_bin'].values\nlevels=np.arange(2070,2160,2)\n\nbins = np.arange(0, 90, 10) \n#depth_bins = xr.DataArray(pd.cut(depth, bins, labels=bins[:-1]), dims=\"depth\", name=\"binned_depth\")\n\ndata_alk1=nDIC.sel(HV=[1,5,9,10]).isel(date=slice(0,4)).mean('date')\ndata_alk2=nDIC.sel(HV=[1,5,9,10]).isel(date=slice(5,9)).mean('date')\n\ndata_alk1=bgc_sub['nDIC'].sel(location=[1,5,9,10]).isel(time=slice(0,4)).mean('time')\ndata_alk2=bgc_sub['nDIC'].sel(location=[1,5,9,10]).isel(time=slice(5,9)).mean('time')\n\n\nfig, axarr = plt.subplots(nrows=1, ncols=2, figsize=(6*2, 3), constrained_layout=True)\nax = axarr.flatten()\n\n#c0=ax[0].contourf(loc, data_alk.depth, data_alk.transpose())\nc0=ax[0].contourf(loc,data_alk1.depth,data_alk1.transpose(),levels)\nplt.colorbar(c0,ax=ax[0], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[0].set_ylim(0,40)\nax[0].invert_yaxis()\nax[0].set_title('salinity normalized DIC along fjord April-May (modeled)')\nax[0].set_xlabel('longitude')\nax[0].set_ylabel('depth (m)')\n\nc0=ax[1].contourf(loc,data_alk2.depth,data_alk2.transpose(),levels)\nplt.colorbar(c0,ax=ax[1], orientation='vertical', label='mmol/m3',shrink=0.5)\nax[1].set_ylim(0,40)\nax[1].invert_yaxis()\nax[1].set_title('salinity normalized DIC along fjord June-August (modeled )')\nax[1].set_xlabel('longitude')\nax[1].set_ylabel('depth (m)')","key":"D1eOQ2P9pC"},{"type":"outputs","id":"hUtzAlM6IGLK4A-osn4Zs","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"/tmp/ipykernel_391752/3320587714.py:11: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  data_alk1=bgc_sub['nDIC'].sel(location=[1,5,9,10]).isel(time=slice(0,4)).mean('time')\n/tmp/ipykernel_391752/3320587714.py:12: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  data_alk2=bgc_sub['nDIC'].sel(location=[1,5,9,10]).isel(time=slice(5,9)).mean('time')\n"},"children":[],"key":"ManRrd9Wyk"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"57e70333ed0cad0672505cf717dd0953","path":"/57e70333ed0cad0672505cf717dd0953.png"},"text/plain":{"content":"<Figure size 1200x300 with 4 Axes>","content_type":"text/plain"}}},"children":[],"key":"V4Qkhp9jFx"}],"key":"OfRmujeE4Q"}],"key":"NqO0ouGcrw"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Create figure and subplots (1 row for salinity-normalized DIC, 2 columns for observations vs. model)\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(12, 5), sharex=False)\n\n# --- Data Extraction Functions ---\ndef extract_depth_avg(var, depth_range, time_dim='date'):\n    \"\"\"Extracts mean value across a given depth range for each time step.\"\"\"\n    return var.sel(depth_bin=slice(*depth_range)).mean(dim='depth_bin', skipna=True)\n\ndef extract_depth_avg_model(var, depth_range, time_dim='time'):\n    \"\"\"Extracts mean value across a given depth range for each time step.\"\"\"\n    return var.sel(depth=slice(*depth_range)).mean(dim='depth', skipna=True)\n\n# Define depth ranges\nupper_depth_range = (0, 5)   # Upper level (0-10 m)\nlower_depth_range = (20, 40)  # Lower level (20-40 m)\n\n# --- Observations ---\nax_obs = axes[0]\nobs_upper = extract_depth_avg(nDIC.mean('HV'), upper_depth_range)\nobs_lower = extract_depth_avg(nDIC.mean('HV'), lower_depth_range)\n\nax_obs.plot(obs['date'], obs_upper, label='0-10m', marker='o', linestyle='-')\nax_obs.plot(obs['date'], obs_lower, label='20-40m', marker='s', linestyle='--')\nax_obs.set_title('Salinity-Normalized DIC (Observed)')\nax_obs.set_ylabel('mmol/m$^3$')\nax_obs.legend()\nax_obs.tick_params(axis='x', rotation=45)  # Rotate x-axis labels\n\n# --- Model ---\nax_model = axes[1]\nmodel_upper = extract_depth_avg_model(bgc_sub['nDIC'].mean('location'), upper_depth_range, time_dim='time')\nmodel_lower = extract_depth_avg_model(bgc_sub['nDIC'].mean('location'), lower_depth_range, time_dim='time')\n\nax_model.plot(bgc_sub['time'], model_upper, label='0-10m', marker='o', linestyle='-')\nax_model.plot(bgc_sub['time'], model_lower, label='20-40m', marker='s', linestyle='--')\nax_model.set_title('Salinity-Normalized DIC (Model)')\nax_model.legend()\nax_model.tick_params(axis='x', rotation=45)  # Rotate x-axis labels\n\nplt.tight_layout()\nplt.show()\n","key":"pfiZYnqXND"},{"type":"outputs","id":"ebMoq9M-BkUFAVWJrJpKV","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"2dc18b9c98f35cf744e7736792d0625d","path":"/2dc18b9c98f35cf744e7736792d0625d.png"},"text/plain":{"content":"<Figure size 1200x500 with 2 Axes>","content_type":"text/plain"}}},"children":[],"key":"vD8DJE6TQ9"}],"key":"FBVG3DxvyO"}],"key":"JM5CRkRAIN"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Create figure and subplots (4 rows for nutrients, 2 columns for observations vs. model)\nfig = plt.figure(figsize=(12, 13))  # Wider figure for side-by-side comparison\ngs = fig.add_gridspec(4, 2, height_ratios=[1, 1, 1, 1], width_ratios=[1, 1])  \n\n# --- Data Extraction Functions ---\ndef extract_cruise_data(var, depth=0, num_cruises=10):\n    \"\"\"Extracts non-NaN values for a given variable across cruises (observations).\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(date=i) if depth is None else var.isel(date=i, depth_bin=depth))\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\ndef extract_model_data(var, depth=0, num_cruises=7):\n    \"\"\"Extracts non-NaN values from the model across time steps.\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(time=i) if depth is None else var.isel(time=i, depth=depth))\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\n# --- NO3 Boxplots ---\nax1_obs = fig.add_subplot(gs[0, 0])  # Observations\nax1_model = fig.add_subplot(gs[0, 1])  # Model\n\nax1_obs.boxplot(extract_cruise_data(obs['NO3']), patch_artist=True)\nax1_obs.set_title('NO₃ Surface Only (Observed)')\nax1_obs.set_ylabel('mmol/m$^3$')\nax1_obs.set_xticklabels([])\n\nax1_model.boxplot(extract_model_data(bgc_sub['NO3']), patch_artist=True)\nax1_model.set_title('NO₃ Surface Only (Model)')\nax1_model.set_xticklabels([])\n\n# --- PO4 Boxplots ---\nax2_obs = fig.add_subplot(gs[1, 0])  # Observations\nax2_model = fig.add_subplot(gs[1, 1])  # Model\n\nax2_obs.boxplot(extract_cruise_data(obs['PO4']), patch_artist=True)\nax2_obs.set_title('PO₄ Surface Only (Observed)')\nax2_obs.set_ylabel('mmol/m$^3$')\nax2_obs.set_xticklabels([])\n\nax2_model.boxplot(extract_model_data(bgc_sub['PO4']), patch_artist=True)\nax2_model.set_title('PO₄ Surface Only (Model)')\nax2_model.set_xticklabels([])\n\n# --- SiO2 Boxplots ---\nax3_obs = fig.add_subplot(gs[2, 0])  # Observations\nax3_model = fig.add_subplot(gs[2, 1])  # Model\n\nax3_obs.boxplot(extract_cruise_data(obs['SiO2']), patch_artist=True)\nax3_obs.set_title('SiO₂ Surface Only (Observed)')\nax3_obs.set_ylabel('mmol/m$^3$')\nax3_obs.set_xticklabels([])\n\nax3_model.boxplot(extract_model_data(bgc_sub['SiO3']), patch_artist=True)\nax3_model.set_title('SiO₂ Surface Only (Model)')\nax3_model.set_xticklabels([])\n\n# --- NH4 Boxplots ---\nax4_obs = fig.add_subplot(gs[3, 0])  # Observations\nax4_model = fig.add_subplot(gs[3, 1])  # Model\n\nax4_obs.boxplot(extract_cruise_data(obs['NH4']), patch_artist=True)\nax4_obs.set_title('NH₄ Surface Only (Observed)')\nax4_obs.set_xlabel('Cruise')\nax4_obs.set_ylabel('mmol/m$^3$')\nax4_obs.set_xticklabels(pd.to_datetime(obs['date'].isel(date=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\n\nax4_model.boxplot(extract_model_data(bgc_sub['NH4']), patch_artist=True)\nax4_model.set_title('NH₄ Surface Only (Model)')\nax4_model.set_xlabel('Cruise')\nax4_model.set_ylabel('mmol/m$^3$')\nax4_model.set_xticklabels(pd.to_datetime(bgc_sub['time'].isel(time=slice(0,7))).strftime('%d/%m/%Y'), rotation=45)\n\nplt.tight_layout()\nplt.show()\n","key":"M4S5uWodue"},{"type":"outputs","id":"k2AvgxMBw99Wojqy_z-Cy","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"/tmp/ipykernel_391752/3374535268.py:79: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  ax4_model.set_xticklabels(pd.to_datetime(bgc_sub['time'].isel(time=slice(0,7))).strftime('%d/%m/%Y'), rotation=45)\n"},"children":[],"key":"W6sliBZMDs"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"94ef713244171df3b9c83132afa85737","path":"/94ef713244171df3b9c83132afa85737.png"},"text/plain":{"content":"<Figure size 1200x1300 with 8 Axes>","content_type":"text/plain"}}},"children":[],"key":"hu8p9xRhZA"}],"key":"qAcz2k5AKo"}],"key":"bQlY3BJweB"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Create figure and subplots (4 rows for nutrients, 2 columns for observations vs. model)\nfig = plt.figure(figsize=(12, 13))  # Wider figure for side-by-side comparison\ngs = fig.add_gridspec(4, 2, height_ratios=[1, 1, 1, 1], width_ratios=[1, 1])  \n\n# --- Data Extraction Functions ---\ndef extract_cruise_data(var, num_cruises=10):\n    \"\"\"Extracts non-NaN values for a given variable across all depths and cruises (observations).\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(date=i))  # Include all depth levels\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\ndef extract_model_data(var, num_cruises=7):\n    \"\"\"Extracts non-NaN values for a given variable across all depths and time steps (model).\"\"\"\n    cruises = []\n    for i in range(num_cruises):\n        data = np.hstack(var.isel(time=i))  # Include all depth levels\n        cruises.append(data[~np.isnan(data)])\n    return cruises\n\n# --- NO3 Boxplots (All Depths) ---\nax1_obs = fig.add_subplot(gs[0, 0])  # Observations\nax1_model = fig.add_subplot(gs[0, 1])  # Model\n\nax1_obs.boxplot(extract_cruise_data(obs['NO3']), patch_artist=True)\nax1_obs.set_title('NO₃ (All Depths, Observed)')\nax1_obs.set_ylabel('mmol/m$^3$')\nax1_obs.set_xticklabels([])\n\nax1_model.boxplot(extract_model_data(bgc_sub['NO3']), patch_artist=True)\nax1_model.set_title('NO₃ (All Depths, Model)')\nax1_model.set_xticklabels([])\n\n# --- PO4 Boxplots (All Depths) ---\nax2_obs = fig.add_subplot(gs[1, 0])  # Observations\nax2_model = fig.add_subplot(gs[1, 1])  # Model\n\nax2_obs.boxplot(extract_cruise_data(obs['PO4']), patch_artist=True)\nax2_obs.set_title('PO₄ (All Depths, Observed)')\nax2_obs.set_ylabel('mmol/m$^3$')\nax2_obs.set_xticklabels([])\n\nax2_model.boxplot(extract_model_data(bgc_sub['PO4']), patch_artist=True)\nax2_model.set_title('PO₄ (All Depths, Model)')\nax2_model.set_xticklabels([])\n\n# --- SiO2 Boxplots (All Depths) ---\nax3_obs = fig.add_subplot(gs[2, 0])  # Observations\nax3_model = fig.add_subplot(gs[2, 1])  # Model\n\nax3_obs.boxplot(extract_cruise_data(obs['SiO2']), patch_artist=True)\nax3_obs.set_title('SiO₂ (All Depths, Observed)')\nax3_obs.set_ylabel('mmol/m$^3$')\nax3_obs.set_xticklabels([])\n\nax3_model.boxplot(extract_model_data(bgc_sub['SiO3']), patch_artist=True)\nax3_model.set_title('SiO₂ (All Depths, Model)')\nax3_model.set_xticklabels([])\n\n# --- NH4 Boxplots (All Depths) ---\nax4_obs = fig.add_subplot(gs[3, 0])  # Observations\nax4_model = fig.add_subplot(gs[3, 1])  # Model\n\nax4_obs.boxplot(extract_cruise_data(obs['NH4']), patch_artist=True)\nax4_obs.set_title('NH₄ (All Depths, Observed)')\nax4_obs.set_xlabel('Cruise')\nax4_obs.set_ylabel('mmol/m$^3$')\nax4_obs.set_xticklabels(pd.to_datetime(obs['date'].isel(date=slice(0,10))).strftime('%d/%m/%Y'), rotation=45)\n\nax4_model.boxplot(extract_model_data(bgc_sub['NH4']), patch_artist=True)\nax4_model.set_title('NH₄ (All Depths, Model)')\nax4_model.set_xlabel('Cruise')\nax4_model.set_ylabel('mmol/m$^3$')\nax4_model.set_xticklabels(pd.to_datetime(bgc_sub['time'].isel(time=slice(0,7))).strftime('%d/%m/%Y'), rotation=45)\n\nplt.tight_layout()\nplt.show()\n","key":"Fxf5Kr2h7s"},{"type":"outputs","id":"up_WSSu-ayboftuW82Miz","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"/tmp/ipykernel_391752/1455962995.py:79: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  ax4_model.set_xticklabels(pd.to_datetime(bgc_sub['time'].isel(time=slice(0,7))).strftime('%d/%m/%Y'), rotation=45)\n"},"children":[],"key":"adyiWeotzU"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"385b22eb76075a936e1893520c55b45c","path":"/385b22eb76075a936e1893520c55b45c.png"},"text/plain":{"content":"<Figure size 1200x1300 with 8 Axes>","content_type":"text/plain"}}},"children":[],"key":"HfrTMyol8J"}],"key":"rhGMc7PCOO"}],"key":"u1PdgopOsW"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Create figure and subplots (4 rows for nutrients, 2 columns for observations vs. model)\nfig, axes = plt.subplots(nrows=4, ncols=2, figsize=(12, 13), sharex=False)  \n\n# --- Data Extraction Functions ---\ndef extract_depth_avg(var, depth_range, time_dim='date'):\n    \"\"\"Extracts mean value across a given depth range for each time step.\"\"\"\n    return var.sel(depth_bin=slice(*depth_range)).mean(dim='depth_bin', skipna=True)\n\ndef extract_depth_avg_model(var, depth_range, time_dim='time'):\n    \"\"\"Extracts mean value across a given depth range for each time step.\"\"\"\n    return var.sel(depth=slice(*depth_range)).mean(dim='depth', skipna=True)\n\n# Define depth ranges\nupper_depth_range = (0,5)   # Upper level (0-10 m)\nlower_depth_range = (20, 40)  # Lower level (20-40 m)\n\n# Define nutrients and their respective labels\nnutrients = ['NO3', 'PO4', 'SiO2', 'NH4']\nnutrients_m = ['NO3', 'PO4', 'SiO3', 'NH4']\ntitles = ['NO₃', 'PO₄', 'SiO$_3$', 'NH₄']\n\n# --- Plot each nutrient ---\nfor i, nutrient in enumerate(nutrients):\n    # Observations\n    ax_obs = axes[i, 0]\n    obs_upper = extract_depth_avg(obs[nutrient].mean('HV'), upper_depth_range)\n    obs_lower = extract_depth_avg(obs[nutrient].mean('HV'), lower_depth_range)\n\n    ax_obs.plot(obs['date'], obs_upper, label='0-10m', marker='o', linestyle='-')\n    ax_obs.plot(obs['date'], obs_lower, label='20-40m', marker='s', linestyle='--')\n    ax_obs.set_title(f'{titles[i]} (Observed)')\n    ax_obs.set_ylabel('mmol/m$^3$')\n    ax_obs.legend()\n    ax_obs.tick_params(axis='x', rotation=45)  # Rotate x-axis labels\n\n\nfor i, nutrient in enumerate(nutrients_m):\n    # Model\n    ax_model = axes[i, 1]\n    model_upper = extract_depth_avg_model(bgc_sub[nutrient].mean('location'), upper_depth_range, time_dim='time')\n    model_lower = extract_depth_avg_model(bgc_sub[nutrient].mean('location'), lower_depth_range, time_dim='time')\n\n    ax_model.plot(bgc_sub['time'], model_upper, label='0-10m', marker='o', linestyle='-')\n    ax_model.plot(bgc_sub['time'], model_lower, label='20-40m', marker='s', linestyle='--')\n    ax_model.set_title(f'{titles[i]} (Model)')\n    ax_model.legend()\n    ax_model.tick_params(axis='x', rotation=45)  # Rotate x-axis labels\n\n\nplt.tight_layout()\nplt.show()\n","key":"ngGfKRQ5dZ"},{"type":"outputs","id":"blelYtbY0-QJMKv5O0qW2","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"a1c2d8eed182140ef5f7df7b217d47b0","path":"/a1c2d8eed182140ef5f7df7b217d47b0.png"},"text/plain":{"content":"<Figure size 1200x1300 with 8 Axes>","content_type":"text/plain"}}},"children":[],"key":"Jeq7BTnOpU"}],"key":"HTA9Z5553F"}],"key":"ZkKw4OnqGZ"}],"key":"RdTQtkkSj8"},"references":{"cite":{"order":[],"data":{}}}}